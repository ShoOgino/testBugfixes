{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":["27b51e98dfbe5e5df4f3714817b72c3742c0d903","5984f3962c191f46dc80585c9aefa49208aaabde"],"bugIntro":["3c8475e39c56b28600d2b496f3e78f7421190f62"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["3c8475e39c56b28600d2b496f3e78f7421190f62"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07a329260e086b42586dc44d6aa34592f6fc0dbb","date":1327682449,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e4d5fc8284faca306256427bbbb86017a32002cf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"221ff19d62d5ff429ffecf8e7f3e01ff93754854","date":1329974551,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4d5fc8284faca306256427bbbb86017a32002cf","date":1347055110,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      } else {\n        if (null != directoryFactory) {\n          // :HACK: normally we rely on updateHandler to do this, \n          // but what if updateHandler failed to init?\n          directoryFactory.close();\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (updateHandler != null) updateHandler.close();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d","3c8475e39c56b28600d2b496f3e78f7421190f62"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6d3fca4763c45f22581927b942c808dbb2e2aec","date":1347304121,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      } else {\n        if (null != directoryFactory) {\n          // :HACK: normally we rely on updateHandler to do this, \n          // but what if updateHandler failed to init?\n          directoryFactory.close();\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      } else {\n        if (null != directoryFactory) {\n          // :HACK: normally we rely on updateHandler to do this, \n          // but what if updateHandler failed to init?\n          directoryFactory.close();\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c8475e39c56b28600d2b496f3e78f7421190f62","date":1349102564,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    \n    if (updateHandler instanceof IndexWriterCloser) {\n      decrefSolrCoreState((IndexWriterCloser)updateHandler);\n    } else {\n      decrefSolrCoreState(null);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    synchronized (solrCoreState) {\n      if (solrCoreStateRefCnt == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      } else {\n        if (null != directoryFactory) {\n          // :HACK: normally we rely on updateHandler to do this, \n          // but what if updateHandler failed to init?\n          directoryFactory.close();\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["b05bc1c7371d421d25b9b27324a7dc6e7393911d","e22ffe8cc51a892ae103df018822d7873e901c2a","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","e4d5fc8284faca306256427bbbb86017a32002cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    \n    if (updateHandler instanceof IndexWriterCloser) {\n      decrefSolrCoreState((IndexWriterCloser)updateHandler);\n    } else {\n      decrefSolrCoreState(null);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    synchronized (solrCoreState) {\n      if (solrCoreStateRefCnt == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d","cc0c538deda78cdcde283c7037ae3f5fbb4944c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    \n    if (updateHandler instanceof IndexWriterCloser) {\n      decrefSolrCoreState((IndexWriterCloser)updateHandler);\n    } else {\n      decrefSolrCoreState(null);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    synchronized (solrCoreState) {\n      if (solrCoreStateRefCnt == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80ba0e0ced6273399ff97caaf301445b9fd24895","date":1356802943,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":["26f751079329fb2139e415fb8971781aabcc8866"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (InterruptedException e) {\n      searcherExecutor.shutdownNow();\n      try {\n        if (!searcherExecutor.awaitTermination(30, TimeUnit.SECONDS)) {\n          log.error(\"Timeout waiting for searchExecutor to terminate\");\n        }\n      } catch (InterruptedException e2) {\n        SolrException.log(log, e2);\n      }\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc0c538deda78cdcde283c7037ae3f5fbb4944c0","date":1360953151,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      if (solrCoreState.getSolrCoreStateRefCnt() == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b41f996b22bd5518650f897d050088ff808ec03","date":1360969107,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      if (solrCoreState.getSolrCoreStateRefCnt() == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (updateHandler instanceof IndexWriterCloser) {\n        decrefSolrCoreState((IndexWriterCloser) updateHandler);\n      } else {\n        decrefSolrCoreState(null);\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      synchronized (solrCoreState) {\n        if (solrCoreStateRefCnt == 0) {\n          try {\n            directoryFactory.close();\n          } catch (Throwable t) {\n            SolrException.log(log, t);\n          }\n        }\n      }\n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable t) {\n        SolrException.log(log, t);\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (solrCoreState != null) { // bad startup case\n      if (solrCoreState.getSolrCoreStateRefCnt() == 0) {\n        try {\n          directoryFactory.close();\n        } catch (Throwable t) {\n          SolrException.log(log, t);\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d","e4d5fc8284faca306256427bbbb86017a32002cf","cc0c538deda78cdcde283c7037ae3f5fbb4944c0"],"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27affa73e101ea5cb023d8ea037d86c352e6a563","date":1366746292,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable t) {\n        SolrException.log(log, t);\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable t) {\n        SolrException.log(log, t);\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable t) {\n        SolrException.log(log, t);\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["b05bc1c7371d421d25b9b27324a7dc6e7393911d","058801f8673d53a5abac8088204860ec29a40f0d"],"bugIntro":["26f751079329fb2139e415fb8971781aabcc8866"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26f751079329fb2139e415fb8971781aabcc8866","date":1415114472,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["27b51e98dfbe5e5df4f3714817b72c3742c0d903","80ba0e0ced6273399ff97caaf301445b9fd24895","8fe3c163c8df3fb3e4248c30f8ae8034cc786589","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd","date":1419078070,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","date":1423508552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul> \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":["5c03efd8cfee511e8fabfc468d0dd7c9303be8be","8b9c4a540a361ad7be858402dc9e3dea5fbc8eca","8a1078cf12e79f05e2424da47ec80c9ff418ddc1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul> \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":["ad28156288ac00b91352582904d97e6653205757"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul> \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);       \n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n      \n    }\n\n    \n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54bb8da55080e4569804e0661b83a3c72cbd8d4d","date":1429691126,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    // For debugging \n//    numCloses.incrementAndGet();\n//    openHandles.remove(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91e2345fb81b6c1c7faefa550ee5eaafadc54486","date":1469730189,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0265144286422ad99682a00904cc2536b79c8535","date":1482222684,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":["d79cc3ed7651d0765a5d13a6a4f9f8a085116c13"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad28156288ac00b91352582904d97e6653205757","date":1486850922,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"bugIntro":["2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f","date":1487384564,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":["ad28156288ac00b91352582904d97e6653205757"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d79cc3ed7651d0765a5d13a6a4f9f8a085116c13","date":1502789544,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":["0265144286422ad99682a00904cc2536b79c8535"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00aac053fdd75193eb8b6d45b64c26c3b586d5b","date":1503143818,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24792720c893049d53a1807bd0ae9b64d1cd7be5","date":1527536585,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6","date":1547236077,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   * <li>searcher</li>\n   * <li>updateHandler</li>\n   * <li>all CloseHooks will be notified</li>\n   * <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   * </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   * <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   * resources are released.\n   * </li>\n   * <li>If reference count is == 0, the resources are released.\n   * <li>If reference count is &lt; 0, and error is logged and no further action\n   * is taken.\n   * </li>\n   * </ul>\n   *\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this);\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.preClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    if (reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.postClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof  Error) {\n        throw (Error) e;\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n\n    if(reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    \n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    }  catch (Throwable e) {\n      SolrException.log(log,e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      \n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n           if (e instanceof Error) {\n             throw (Error) e;\n           }\n         }\n      }\n    }\n    \n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   * <li>searcher</li>\n   * <li>updateHandler</li>\n   * <li>all CloseHooks will be notified</li>\n   * <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   * </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   * <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   * resources are released.\n   * </li>\n   * <li>If reference count is == 0, the resources are released.\n   * <li>If reference count is &lt; 0, and error is logged and no further action\n   * is taken.\n   * </li>\n   * </ul>\n   *\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    MDCLoggingContext.clear(); // balance out open with close\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this);\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.preClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    if (reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.postClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   * <li>searcher</li>\n   * <li>updateHandler</li>\n   * <li>all CloseHooks will be notified</li>\n   * <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   * </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   * <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   * resources are released.\n   * </li>\n   * <li>If reference count is == 0, the resources are released.\n   * <li>If reference count is &lt; 0, and error is logged and no further action\n   * is taken.\n   * </li>\n   * </ul>\n   *\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this);\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.preClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    if (reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.postClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d16198391f70a4ee52a8c8792c91eb87a30f1d6","date":1596695552,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   * <li>searcher</li>\n   * <li>updateHandler</li>\n   * <li>all CloseHooks will be notified</li>\n   * <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   * </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   * <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   * resources are released.\n   * </li>\n   * <li>If reference count is == 0, the resources are released.\n   * <li>If reference count is &lt; 0, and error is logged and no further action\n   * is taken.\n   * </li>\n   * </ul>\n   *\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    MDCLoggingContext.clear(); // balance out open with close\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this);\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.preClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    if (reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.postClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   * <li>searcher</li>\n   * <li>updateHandler</li>\n   * <li>all CloseHooks will be notified</li>\n   * <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   * </li>\n   * </ul>\n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a reference count of 1)...\n   * </p>\n   * <ul>\n   * <li>If reference count is &gt; 0, the usage count is decreased by 1 and no\n   * resources are released.\n   * </li>\n   * <li>If reference count is == 0, the resources are released.\n   * <li>If reference count is &lt; 0, and error is logged and no further action\n   * is taken.\n   * </li>\n   * </ul>\n   *\n   * @see #isClosed()\n   */\n  @Override\n  public void close() {\n    MDCLoggingContext.clear(); // balance out open with close\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this);\n      assert false : \"Too many closes on SolrCore\";\n      return;\n    }\n    log.info(\"{} CLOSING SolrCore {}\", logid, this);\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreAsyncTaskExecutor);\n\n    // stop reporting metrics\n    try {\n      coreMetricManager.close();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.preClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    if (reqHandlers != null) reqHandlers.close();\n    responseWriters.close();\n    searchComponents.close();\n    qParserPlugins.close();\n    valueSourceParsers.close();\n    transformerFactories.close();\n\n    if (memClassLoader != null) {\n      try {\n        memClassLoader.close();\n      } catch (Exception e) {\n      }\n    }\n\n\n    try {\n      if (null != updateHandler) {\n        updateHandler.close();\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    boolean coreStateClosed = false;\n    try {\n      if (solrCoreState != null) {\n        if (updateHandler instanceof IndexWriterCloser) {\n          coreStateClosed = solrCoreState.decrefSolrCoreState((IndexWriterCloser) updateHandler);\n        } else {\n          coreStateClosed = solrCoreState.decrefSolrCoreState(null);\n        }\n      }\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(searcherExecutor);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n    assert ObjectReleaseTracker.release(searcherExecutor);\n\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n      try {\n        cleanupOldIndexDirectories(false);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n\n    try {\n      infoRegistry.clear();\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    // Close the snapshots meta-data directory.\n    Directory snapshotsDir = snapshotMgr.getSnapshotsDir();\n    try {\n      this.directoryFactory.release(snapshotsDir);\n    } catch (Throwable e) {\n      SolrException.log(log, e);\n      if (e instanceof Error) {\n        throw (Error) e;\n      }\n    }\n\n    if (coreStateClosed) {\n\n      try {\n        directoryFactory.close();\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n        if (e instanceof Error) {\n          throw (Error) e;\n        }\n      }\n    }\n\n    if (closeHooks != null) {\n      for (CloseHook hook : closeHooks) {\n        try {\n          hook.postClose(this);\n        } catch (Throwable e) {\n          SolrException.log(log, e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    }\n\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad28156288ac00b91352582904d97e6653205757":["0265144286422ad99682a00904cc2536b79c8535"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["5cab9a86bd67202d20b6adc463008c8e982b070a","221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["3c8475e39c56b28600d2b496f3e78f7421190f62"],"a6d3fca4763c45f22581927b942c808dbb2e2aec":["e4d5fc8284faca306256427bbbb86017a32002cf"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0265144286422ad99682a00904cc2536b79c8535"],"d79cc3ed7651d0765a5d13a6a4f9f8a085116c13":["2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f"],"3b41f996b22bd5518650f897d050088ff808ec03":["80ba0e0ced6273399ff97caaf301445b9fd24895","cc0c538deda78cdcde283c7037ae3f5fbb4944c0"],"0d16198391f70a4ee52a8c8792c91eb87a30f1d6":["ed5005b977107bba28c700351216f1595e7abe4f"],"f2126b84bd093fa3d921582a109a0ee578c28126":["3c8475e39c56b28600d2b496f3e78f7421190f62","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["27affa73e101ea5cb023d8ea037d86c352e6a563"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["c26f00b574427b55127e869b935845554afde1fa"],"91e2345fb81b6c1c7faefa550ee5eaafadc54486":["536b47681314488eb94706248be6047a3f142841"],"07a329260e086b42586dc44d6aa34592f6fc0dbb":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"536b47681314488eb94706248be6047a3f142841":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["e22ffe8cc51a892ae103df018822d7873e901c2a","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"26f751079329fb2139e415fb8971781aabcc8866":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"e4d5fc8284faca306256427bbbb86017a32002cf":["221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f":["ad28156288ac00b91352582904d97e6653205757"],"0265144286422ad99682a00904cc2536b79c8535":["91e2345fb81b6c1c7faefa550ee5eaafadc54486"],"058801f8673d53a5abac8088204860ec29a40f0d":["cc0c538deda78cdcde283c7037ae3f5fbb4944c0"],"3c8475e39c56b28600d2b496f3e78f7421190f62":["a6d3fca4763c45f22581927b942c808dbb2e2aec"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","80ba0e0ced6273399ff97caaf301445b9fd24895"],"c00aac053fdd75193eb8b6d45b64c26c3b586d5b":["2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f","d79cc3ed7651d0765a5d13a6a4f9f8a085116c13"],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ed5005b977107bba28c700351216f1595e7abe4f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","07a329260e086b42586dc44d6aa34592f6fc0dbb"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","9aea0485ecacb6734c17da2d02569816c23a69c1"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["e22ffe8cc51a892ae103df018822d7873e901c2a","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9aea0485ecacb6734c17da2d02569816c23a69c1":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","07a329260e086b42586dc44d6aa34592f6fc0dbb"],"27affa73e101ea5cb023d8ea037d86c352e6a563":["058801f8673d53a5abac8088204860ec29a40f0d"],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["d79cc3ed7651d0765a5d13a6a4f9f8a085116c13"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["07a329260e086b42586dc44d6aa34592f6fc0dbb","96d207426bd26fa5c1014e26d21d87603aea68b7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["536b47681314488eb94706248be6047a3f142841","91e2345fb81b6c1c7faefa550ee5eaafadc54486"],"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd":["26f751079329fb2139e415fb8971781aabcc8866"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["b96ad5eead3ef9b09cee72d7b54b8bfc369859bd"],"cc0c538deda78cdcde283c7037ae3f5fbb4944c0":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["536b47681314488eb94706248be6047a3f142841","91e2345fb81b6c1c7faefa550ee5eaafadc54486"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d16198391f70a4ee52a8c8792c91eb87a30f1d6"]},"commit2Childs":{"ad28156288ac00b91352582904d97e6653205757":["2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","80ba0e0ced6273399ff97caaf301445b9fd24895"],"a6d3fca4763c45f22581927b942c808dbb2e2aec":["3c8475e39c56b28600d2b496f3e78f7421190f62"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"d79cc3ed7651d0765a5d13a6a4f9f8a085116c13":["c00aac053fdd75193eb8b6d45b64c26c3b586d5b","24792720c893049d53a1807bd0ae9b64d1cd7be5"],"3b41f996b22bd5518650f897d050088ff808ec03":[],"0d16198391f70a4ee52a8c8792c91eb87a30f1d6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["26f751079329fb2139e415fb8971781aabcc8866"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"91e2345fb81b6c1c7faefa550ee5eaafadc54486":["0265144286422ad99682a00904cc2536b79c8535","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"07a329260e086b42586dc44d6aa34592f6fc0dbb":["fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b","5cab9a86bd67202d20b6adc463008c8e982b070a"],"536b47681314488eb94706248be6047a3f142841":["91e2345fb81b6c1c7faefa550ee5eaafadc54486","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["536b47681314488eb94706248be6047a3f142841"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"26f751079329fb2139e415fb8971781aabcc8866":["b96ad5eead3ef9b09cee72d7b54b8bfc369859bd"],"11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"e4d5fc8284faca306256427bbbb86017a32002cf":["a6d3fca4763c45f22581927b942c808dbb2e2aec"],"0265144286422ad99682a00904cc2536b79c8535":["ad28156288ac00b91352582904d97e6653205757","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"2e8212eeb107b0604d0c14c35e3332e8ff6e5e1f":["d79cc3ed7651d0765a5d13a6a4f9f8a085116c13","c00aac053fdd75193eb8b6d45b64c26c3b586d5b"],"058801f8673d53a5abac8088204860ec29a40f0d":["27affa73e101ea5cb023d8ea037d86c352e6a563"],"3c8475e39c56b28600d2b496f3e78f7421190f62":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"c00aac053fdd75193eb8b6d45b64c26c3b586d5b":[],"221ff19d62d5ff429ffecf8e7f3e01ff93754854":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e4d5fc8284faca306256427bbbb86017a32002cf"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["3b41f996b22bd5518650f897d050088ff808ec03","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cc0c538deda78cdcde283c7037ae3f5fbb4944c0"],"c26f00b574427b55127e869b935845554afde1fa":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"ed5005b977107bba28c700351216f1595e7abe4f":["0d16198391f70a4ee52a8c8792c91eb87a30f1d6"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["ed5005b977107bba28c700351216f1595e7abe4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["54bb8da55080e4569804e0661b83a3c72cbd8d4d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"27affa73e101ea5cb023d8ea037d86c352e6a563":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["11b67e7dc6d14dd8535564a49ca9c12ec5e8b2b6"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","221ff19d62d5ff429ffecf8e7f3e01ff93754854"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"b96ad5eead3ef9b09cee72d7b54b8bfc369859bd":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["07a329260e086b42586dc44d6aa34592f6fc0dbb","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cc0c538deda78cdcde283c7037ae3f5fbb4944c0":["3b41f996b22bd5518650f897d050088ff808ec03","058801f8673d53a5abac8088204860ec29a40f0d"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","3b41f996b22bd5518650f897d050088ff808ec03","f2126b84bd093fa3d921582a109a0ee578c28126","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c00aac053fdd75193eb8b6d45b64c26c3b586d5b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","78a55f24d9b493c2a1cecf79f1d78279062b545b","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}