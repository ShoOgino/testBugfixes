{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testCarryOverNewDeletesOnCommit().mjava","commits":[{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testCarryOverNewDeletesOnCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testCarryOverNewDeletes().mjava","sourceNew":"  public void testCarryOverNewDeletesOnCommit() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      boolean useSoftDeletes = random().nextBoolean();\n      CountDownLatch waitForMerge = new CountDownLatch(1);\n      CountDownLatch waitForUpdate = new CountDownLatch(1);\n      try (IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig()\n          .setMergePolicy(new MergeOnXMergePolicy(NoMergePolicy.INSTANCE, MergeTrigger.COMMIT)).setMaxFullFlushMergeWaitMillis(30 * 1000)\n          .setSoftDeletesField(\"soft_delete\")\n          .setMaxBufferedDocs(Integer.MAX_VALUE)\n          .setRAMBufferSizeMB(100)\n          .setMergeScheduler(new ConcurrentMergeScheduler())) {\n        @Override\n        protected void merge(MergePolicy.OneMerge merge) throws IOException {\n          waitForMerge.countDown();\n          try {\n            waitForUpdate.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n          super.merge(merge);\n        }\n      }) {\n\n        Document d1 = new Document();\n        d1.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        Document d2 = new Document();\n        d2.add(new StringField(\"id\", \"2\", Field.Store.NO));\n        Document d3 = new Document();\n        d3.add(new StringField(\"id\", \"3\", Field.Store.NO));\n        writer.addDocument(d1);\n        writer.flush();\n        writer.addDocument(d2);\n        boolean addThreeDocs = random().nextBoolean();\n        int expectedNumDocs = 2;\n        if (addThreeDocs) { // sometimes add another doc to ensure we don't have a fully deleted segment\n          expectedNumDocs = 3;\n          writer.addDocument(d3);\n        }\n        Thread t = new Thread(() -> {\n          try {\n            waitForMerge.await();\n            if (useSoftDeletes) {\n              writer.softUpdateDocument(new Term(\"id\", \"2\"), d2, new NumericDocValuesField(\"soft_delete\", 1));\n            } else {\n              writer.updateDocument(new Term(\"id\", \"2\"), d2);\n            }\n            writer.flush();\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            waitForUpdate.countDown();\n          }\n\n        });\n        t.start();\n        writer.commit();\n        t.join();\n        try (DirectoryReader open = new SoftDeletesDirectoryReaderWrapper(DirectoryReader.open(directory), \"soft_delete\")) {\n          assertEquals(expectedNumDocs, open.numDocs());\n          assertEquals(\"we should not have any deletes\", expectedNumDocs, open.maxDoc());\n        }\n\n        try (DirectoryReader open = DirectoryReader.open(writer)) {\n          assertEquals(expectedNumDocs, open.numDocs());\n          assertEquals(\"we should not have one delete\", expectedNumDocs+1, open.maxDoc());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testCarryOverNewDeletes() throws IOException, InterruptedException {\n    try (Directory directory = newDirectory()) {\n      boolean useSoftDeletes = random().nextBoolean();\n      CountDownLatch waitForMerge = new CountDownLatch(1);\n      CountDownLatch waitForUpdate = new CountDownLatch(1);\n      try (IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig()\n          .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitMillis(30 * 1000)\n          .setSoftDeletesField(\"soft_delete\")\n          .setMaxBufferedDocs(Integer.MAX_VALUE)\n          .setRAMBufferSizeMB(100)\n          .setMergeScheduler(new ConcurrentMergeScheduler())) {\n        @Override\n        protected void merge(MergePolicy.OneMerge merge) throws IOException {\n          waitForMerge.countDown();\n          try {\n            waitForUpdate.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n          super.merge(merge);\n        }\n      }) {\n\n        Document d1 = new Document();\n        d1.add(new StringField(\"id\", \"1\", Field.Store.NO));\n        Document d2 = new Document();\n        d2.add(new StringField(\"id\", \"2\", Field.Store.NO));\n        Document d3 = new Document();\n        d3.add(new StringField(\"id\", \"3\", Field.Store.NO));\n        writer.addDocument(d1);\n        writer.flush();\n        writer.addDocument(d2);\n        boolean addThreeDocs = random().nextBoolean();\n        int expectedNumDocs = 2;\n        if (addThreeDocs) { // sometimes add another doc to ensure we don't have a fully deleted segment\n          expectedNumDocs = 3;\n          writer.addDocument(d3);\n        }\n        Thread t = new Thread(() -> {\n          try {\n            waitForMerge.await();\n            if (useSoftDeletes) {\n              writer.softUpdateDocument(new Term(\"id\", \"2\"), d2, new NumericDocValuesField(\"soft_delete\", 1));\n            } else {\n              writer.updateDocument(new Term(\"id\", \"2\"), d2);\n            }\n            writer.flush();\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            waitForUpdate.countDown();\n          }\n\n        });\n        t.start();\n        writer.commit();\n        t.join();\n        try (DirectoryReader open = new SoftDeletesDirectoryReaderWrapper(DirectoryReader.open(directory), \"soft_delete\")) {\n          assertEquals(expectedNumDocs, open.numDocs());\n          assertEquals(\"we should not have any deletes\", expectedNumDocs, open.maxDoc());\n        }\n\n        try (DirectoryReader open = DirectoryReader.open(writer)) {\n          assertEquals(expectedNumDocs, open.numDocs());\n          assertEquals(\"we should not have one delete\", expectedNumDocs+1, open.maxDoc());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}