{"path":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","pathOld":"/dev/null","sourceNew":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b107346d6f511cbb411725ae85fa167de3cc916","date":1518457408,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","sourceNew":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n            case ALL:\n            case NONE:\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","sourceOld":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","sourceNew":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n            case ALL:\n            case NONE:\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","sourceOld":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8dd07c8ab4bfe0bb6c24e425b99fd7e1a409aa58","date":1551213531,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","sourceNew":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      if (range.other != null) {\n        switch (range.other) {\n          case BEFORE:\n            assert range.lower == null;\n            intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                range.includeUpper, FacetRangeOther.BEFORE.toString()));\n            break;\n          case AFTER:\n            assert range.upper == null;\n            after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n            break;\n          case BETWEEN:\n            intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n            break;\n          case ALL:\n          case NONE:\n            break;\n        }\n      } else {\n        intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n      }\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","sourceOld":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n            case ALL:\n            case NONE:\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"accbc347dd28993a84ae51e9e6f01e31a26a7184","date":1551252530,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RangeFacetProcessor#[T-extends-Comparable[T]]_getFacetRangeCountsDocValues(RangeFacetRequest).mjava","sourceNew":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      if (range.other != null) {\n        switch (range.other) {\n          case BEFORE:\n            assert range.lower == null;\n            intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                range.includeUpper, FacetRangeOther.BEFORE.toString()));\n            break;\n          case AFTER:\n            assert range.upper == null;\n            after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n            break;\n          case BETWEEN:\n            intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n            break;\n          case ALL:\n          case NONE:\n            break;\n        }\n      } else {\n        intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n      }\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","sourceOld":"  private <T extends Comparable<T>> NamedList<Object> getFacetRangeCountsDocValues(RangeFacetRequest rfr)\n      throws IOException, SyntaxError {\n\n    SchemaField sf = rfr.getSchemaField();\n    final NamedList<Object> res = new SimpleOrderedMap<>();\n    final NamedList<Integer> counts = new NamedList<>();\n    res.add(\"counts\", counts);\n\n    ArrayList<IntervalFacets.FacetInterval> intervals = new ArrayList<>();\n\n    // explicitly return the gap.  compute this early so we are more\n    // likely to catch parse errors before attempting math\n    res.add(\"gap\", rfr.getGapObj());\n\n    final int minCount = rfr.getMinCount();\n\n    boolean includeBefore = false;\n    boolean includeBetween = false;\n    boolean includeAfter = false;\n\n    Set<FacetRangeOther> others = rfr.getOthers();\n    // Intervals must be in order (see IntervalFacets.getSortedIntervals), if \"BEFORE\" or\n    // \"BETWEEN\" are set, they must be added first\n    // no matter what other values are listed, we don't do\n    // anything if \"none\" is specified.\n    if (!others.contains(FacetRangeOther.NONE)) {\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BEFORE)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBefore = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.BETWEEN)) {\n        // We'll add an interval later in this position\n        intervals.add(null);\n        includeBetween = true;\n      }\n\n      if (others.contains(FacetRangeOther.ALL) || others.contains(FacetRangeOther.AFTER)) {\n        includeAfter = true;\n      }\n    }\n\n    IntervalFacets.FacetInterval after = null;\n\n    for (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n      try {\n        FacetRangeOther other = FacetRangeOther.get(range.name);\n        if (other != null) {\n          switch (other) {\n            case BEFORE:\n              assert range.lower == null;\n              intervals.set(0, new IntervalFacets.FacetInterval(sf, \"*\", range.upper, range.includeLower,\n                  range.includeUpper, FacetRangeOther.BEFORE.toString()));\n              break;\n            case AFTER:\n              assert range.upper == null;\n              after = new IntervalFacets.FacetInterval(sf, range.lower, \"*\",\n                  range.includeLower, range.includeUpper, FacetRangeOther.AFTER.toString());\n              break;\n            case BETWEEN:\n              intervals.set(includeBefore ? 1 : 0, new IntervalFacets.FacetInterval(sf, range.lower, range.upper,\n                  range.includeLower, range.includeUpper, FacetRangeOther.BETWEEN.toString()));\n              break;\n            case ALL:\n            case NONE:\n              break;\n          }\n        }\n        continue;\n      } catch (SolrException e) {\n        // safe to ignore\n      }\n\n      intervals.add(new IntervalFacets.FacetInterval(sf, range.lower, range.upper, range.includeLower, range.includeUpper, range.lower));\n    }\n\n    if (includeAfter) {\n      assert after != null;\n      intervals.add(after);\n    }\n\n    IntervalFacets.FacetInterval[] intervalsArray = intervals.toArray(new IntervalFacets.FacetInterval[intervals.size()]);\n    // don't use the ArrayList anymore\n    intervals = null;\n\n    new IntervalFacets(sf, searcher, computeDocSet(docsOrig, rfr.getExcludeTags()), intervalsArray);\n\n    int intervalIndex = 0;\n    int lastIntervalIndex = intervalsArray.length - 1;\n    // if the user requested \"BEFORE\", it will be the first of the intervals. Needs to be added to the\n    // response named list instead of with the counts\n    if (includeBefore) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"BETWEEN\", it will be the first or second of the intervals (depending on if\n    // \"BEFORE\" was also requested). Needs to be added to the response named list instead of with the counts\n    if (includeBetween) {\n      res.add(intervalsArray[intervalIndex].getKey(), intervalsArray[intervalIndex].getCount());\n      intervalIndex++;\n    }\n\n    // if the user requested \"AFTER\", it will be the last of the intervals.\n    // Needs to be added to the response named list instead of with the counts\n    if (includeAfter) {\n      res.add(intervalsArray[lastIntervalIndex].getKey(), intervalsArray[lastIntervalIndex].getCount());\n      lastIntervalIndex--;\n    }\n    // now add all other intervals to the counts NL\n    while (intervalIndex <= lastIntervalIndex) {\n      IntervalFacets.FacetInterval interval = intervalsArray[intervalIndex];\n      if (interval.getCount() >= minCount) {\n        counts.add(interval.getKey(), interval.getCount());\n      }\n      intervalIndex++;\n    }\n\n    res.add(\"start\", rfr.getStartObj());\n    res.add(\"end\", rfr.getEndObj());\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b107346d6f511cbb411725ae85fa167de3cc916":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["22d0a81a05eba47d5e18976f17d88306b218cc22","7b107346d6f511cbb411725ae85fa167de3cc916"],"accbc347dd28993a84ae51e9e6f01e31a26a7184":["bfcdec9fcf0409223f35c5ec3bc14094314941b4","8dd07c8ab4bfe0bb6c24e425b99fd7e1a409aa58"],"8dd07c8ab4bfe0bb6c24e425b99fd7e1a409aa58":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["accbc347dd28993a84ae51e9e6f01e31a26a7184"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"7b107346d6f511cbb411725ae85fa167de3cc916":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["7b107346d6f511cbb411725ae85fa167de3cc916","bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["accbc347dd28993a84ae51e9e6f01e31a26a7184","8dd07c8ab4bfe0bb6c24e425b99fd7e1a409aa58"],"accbc347dd28993a84ae51e9e6f01e31a26a7184":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8dd07c8ab4bfe0bb6c24e425b99fd7e1a409aa58":["accbc347dd28993a84ae51e9e6f01e31a26a7184"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}