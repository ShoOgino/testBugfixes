{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Metric],String).mjava","commits":[{"id":"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef","date":1462373155,"type":0,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Metric],String).mjava","pathOld":"/dev/null","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param query A string for the query\n   * @return Enumerator of results\n   */\n  private Enumerable<Object> query(final Properties properties, final List<String> fields,\n                                   final String query, final List<String> order, final List<String> buckets,\n                                   final List<Metric> metrics, final String limit) {\n    // SolrParams should be a ModifiableParams instead of a map\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n\n    if (query == null) {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY);\n    } else {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY + \" AND \" + query);\n    }\n\n    // List<String> doesn't have add so must make a new ArrayList\n    List<String> fieldsList = new ArrayList<>(fields);\n\n    if (order.isEmpty()) {\n      if(limit != null && Integer.parseInt(limit) > -1) {\n        solrParams.put(CommonParams.SORT, DEFAULT_SCORE_FIELD + \" desc\");\n\n        // Make sure the default score field is in the field list\n        if (!fieldsList.contains(DEFAULT_SCORE_FIELD)) {\n          fieldsList.add(DEFAULT_SCORE_FIELD);\n        }\n      } else {\n        solrParams.put(CommonParams.SORT, DEFAULT_VERSION_FIELD + \" desc\");\n\n        // Make sure the default sort field is in the field list\n        if (!fieldsList.contains(DEFAULT_VERSION_FIELD)) {\n          fieldsList.add(DEFAULT_VERSION_FIELD);\n        }\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    if (fieldsList.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n    }\n\n    TupleStream tupleStream;\n    String zk = properties.getProperty(\"zk\");\n    try {\n      if(metrics.isEmpty()) {\n        if (limit == null) {\n          solrParams.put(CommonParams.QT, \"/export\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } else {\n          solrParams.put(CommonParams.ROWS, limit);\n          tupleStream = new LimitStream(new CloudSolrStream(zk, collection, solrParams), Integer.parseInt(limit));\n        }\n      } else {\n        Metric[] metricsArray = metrics.toArray(new Metric[metrics.size()]);\n        if(buckets.isEmpty()) {\n          solrParams.remove(CommonParams.FL);\n          solrParams.remove(CommonParams.SORT);\n          tupleStream = new StatsStream(zk, collection, solrParams, metricsArray);\n        } else {\n          List<Bucket> bucketsList = new ArrayList<>();\n          for(String bucket : buckets) {\n            bucketsList.add(new Bucket(bucket));\n          }\n\n          solrParams.put(CommonParams.QT, \"/export\");\n          for(Metric metric : metrics) {\n            fieldsList.remove(metric.getIdentifier());\n          }\n          solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n          tupleStream = new RollupStream(tupleStream, bucketsList.toArray(new Bucket[bucketsList.size()]), metricsArray);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    final TupleStream finalStream = tupleStream;\n\n    return new AbstractEnumerable<Object>() {\n      // Use original fields list to make sure only the fields specified are enumerated\n      public Enumerator<Object> enumerator() {\n        return new SolrEnumerator(finalStream, fields);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07aff67f9cb0c9aa9e65e72d68048f408871c951","date":1462378685,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Metric],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Metric],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param query A string for the query\n   * @return Enumerator of results\n   */\n  private Enumerable<Object> query(final Properties properties, final List<String> fields,\n                                   final String query, final List<String> order, final List<String> buckets,\n                                   final List<Metric> metrics, final String limit) {\n    // SolrParams should be a ModifiableParams instead of a map\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n\n    if (query == null) {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY);\n    } else {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY + \" AND \" + query);\n    }\n\n    // List<String> doesn't have add so must make a new ArrayList\n    List<String> fieldsList = new ArrayList<>(fields);\n    List<String> orderList = new ArrayList<>(order);\n\n    if (!metrics.isEmpty()) {\n      for(String bucket : buckets) {\n        orderList.add(bucket + \" desc\");\n      }\n    }\n\n    if (orderList.isEmpty()) {\n      if (limit != null && Integer.parseInt(limit) > -1) {\n        orderList.add(DEFAULT_SCORE_FIELD + \" desc\");\n\n        // Make sure the default score field is in the field list\n        if (!fieldsList.contains(DEFAULT_SCORE_FIELD)) {\n          fieldsList.add(DEFAULT_SCORE_FIELD);\n        }\n      } else {\n        orderList.add(DEFAULT_VERSION_FIELD + \" desc\");\n\n        // Make sure the default sort field is in the field list\n        if (!fieldsList.contains(DEFAULT_VERSION_FIELD)) {\n          fieldsList.add(DEFAULT_VERSION_FIELD);\n        }\n      }\n    }\n\n    solrParams.put(CommonParams.SORT, String.join(\",\", orderList));\n\n    if (fieldsList.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n    }\n\n    TupleStream tupleStream;\n    String zk = properties.getProperty(\"zk\");\n    try {\n      if (metrics.isEmpty()) {\n        if (limit == null) {\n          solrParams.put(CommonParams.QT, \"/export\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } else {\n          solrParams.put(CommonParams.ROWS, limit);\n          tupleStream = new LimitStream(new CloudSolrStream(zk, collection, solrParams), Integer.parseInt(limit));\n        }\n      } else {\n        Metric[] metricsArray = metrics.toArray(new Metric[metrics.size()]);\n        if(buckets.isEmpty()) {\n          solrParams.remove(CommonParams.FL);\n          solrParams.remove(CommonParams.SORT);\n          tupleStream = new StatsStream(zk, collection, solrParams, metricsArray);\n        } else {\n          List<Bucket> bucketsList = new ArrayList<>();\n          for(String bucket : buckets) {\n            bucketsList.add(new Bucket(bucket));\n          }\n\n          solrParams.put(CommonParams.QT, \"/export\");\n          for(Metric metric : metrics) {\n            fieldsList.remove(metric.getIdentifier());\n          }\n          solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n          tupleStream = new RollupStream(tupleStream, bucketsList.toArray(new Bucket[bucketsList.size()]), metricsArray);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    final TupleStream finalStream = tupleStream;\n\n    return new AbstractEnumerable<Object>() {\n      // Use original fields list to make sure only the fields specified are enumerated\n      public Enumerator<Object> enumerator() {\n        return new SolrEnumerator(finalStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param query A string for the query\n   * @return Enumerator of results\n   */\n  private Enumerable<Object> query(final Properties properties, final List<String> fields,\n                                   final String query, final List<String> order, final List<String> buckets,\n                                   final List<Metric> metrics, final String limit) {\n    // SolrParams should be a ModifiableParams instead of a map\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n\n    if (query == null) {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY);\n    } else {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY + \" AND \" + query);\n    }\n\n    // List<String> doesn't have add so must make a new ArrayList\n    List<String> fieldsList = new ArrayList<>(fields);\n\n    if (order.isEmpty()) {\n      if(limit != null && Integer.parseInt(limit) > -1) {\n        solrParams.put(CommonParams.SORT, DEFAULT_SCORE_FIELD + \" desc\");\n\n        // Make sure the default score field is in the field list\n        if (!fieldsList.contains(DEFAULT_SCORE_FIELD)) {\n          fieldsList.add(DEFAULT_SCORE_FIELD);\n        }\n      } else {\n        solrParams.put(CommonParams.SORT, DEFAULT_VERSION_FIELD + \" desc\");\n\n        // Make sure the default sort field is in the field list\n        if (!fieldsList.contains(DEFAULT_VERSION_FIELD)) {\n          fieldsList.add(DEFAULT_VERSION_FIELD);\n        }\n      }\n    } else {\n      solrParams.put(CommonParams.SORT, String.join(\",\", order));\n    }\n\n    if (fieldsList.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n    }\n\n    TupleStream tupleStream;\n    String zk = properties.getProperty(\"zk\");\n    try {\n      if(metrics.isEmpty()) {\n        if (limit == null) {\n          solrParams.put(CommonParams.QT, \"/export\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } else {\n          solrParams.put(CommonParams.ROWS, limit);\n          tupleStream = new LimitStream(new CloudSolrStream(zk, collection, solrParams), Integer.parseInt(limit));\n        }\n      } else {\n        Metric[] metricsArray = metrics.toArray(new Metric[metrics.size()]);\n        if(buckets.isEmpty()) {\n          solrParams.remove(CommonParams.FL);\n          solrParams.remove(CommonParams.SORT);\n          tupleStream = new StatsStream(zk, collection, solrParams, metricsArray);\n        } else {\n          List<Bucket> bucketsList = new ArrayList<>();\n          for(String bucket : buckets) {\n            bucketsList.add(new Bucket(bucket));\n          }\n\n          solrParams.put(CommonParams.QT, \"/export\");\n          for(Metric metric : metrics) {\n            fieldsList.remove(metric.getIdentifier());\n          }\n          solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n          tupleStream = new RollupStream(tupleStream, bucketsList.toArray(new Bucket[bucketsList.size()]), metricsArray);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    final TupleStream finalStream = tupleStream;\n\n    return new AbstractEnumerable<Object>() {\n      // Use original fields list to make sure only the fields specified are enumerated\n      public Enumerator<Object> enumerator() {\n        return new SolrEnumerator(finalStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cc8e977a08af3169747ab78c578cc3037d095d5","date":1462391783,"type":5,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Pair[String,String]],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#query(Properties,List[String],String,List[String],List[String],List[Metric],String).mjava","sourceNew":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param query A string for the query\n   * @return Enumerator of results\n   */\n  private Enumerable<Object> query(final Properties properties, final List<String> fields,\n                                   final String query, final List<String> order, final List<String> buckets,\n                                   final List<Pair<String, String>> metricPairs, final String limit) {\n    // SolrParams should be a ModifiableParams instead of a map\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n\n    if (query == null) {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY);\n    } else {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY + \" AND \" + query);\n    }\n\n    // List<String> doesn't have add so must make a new ArrayList\n    List<String> fieldsList = new ArrayList<>(fields);\n    List<String> orderList = new ArrayList<>(order);\n\n    List<Metric> metrics = buildMetrics(metricPairs);\n\n    if (!metrics.isEmpty()) {\n      for(String bucket : buckets) {\n        orderList.add(bucket + \" desc\");\n      }\n\n      for(Metric metric : metrics) {\n        for(String column : metric.getColumns()) {\n          if (!fieldsList.contains(column)) {\n            fieldsList.add(column);\n          }\n        }\n      }\n    }\n\n    if (orderList.isEmpty()) {\n      if (limit != null && Integer.parseInt(limit) > -1) {\n        orderList.add(DEFAULT_SCORE_FIELD + \" desc\");\n\n        // Make sure the default score field is in the field list\n        if (!fieldsList.contains(DEFAULT_SCORE_FIELD)) {\n          fieldsList.add(DEFAULT_SCORE_FIELD);\n        }\n      } else {\n        orderList.add(DEFAULT_VERSION_FIELD + \" desc\");\n\n        // Make sure the default sort field is in the field list\n        if (!fieldsList.contains(DEFAULT_VERSION_FIELD)) {\n          fieldsList.add(DEFAULT_VERSION_FIELD);\n        }\n      }\n    }\n\n    solrParams.put(CommonParams.SORT, String.join(\",\", orderList));\n\n    if (fieldsList.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n    }\n\n    TupleStream tupleStream;\n    String zk = properties.getProperty(\"zk\");\n    try {\n      if (metrics.isEmpty()) {\n        if (limit == null) {\n          solrParams.put(CommonParams.QT, \"/export\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } else {\n          solrParams.put(CommonParams.ROWS, limit);\n          tupleStream = new LimitStream(new CloudSolrStream(zk, collection, solrParams), Integer.parseInt(limit));\n        }\n      } else {\n        Metric[] metricsArray = metrics.toArray(new Metric[metrics.size()]);\n        if(buckets.isEmpty()) {\n          solrParams.remove(CommonParams.FL);\n          solrParams.remove(CommonParams.SORT);\n          tupleStream = new StatsStream(zk, collection, solrParams, metricsArray);\n        } else {\n          List<Bucket> bucketsList = new ArrayList<>();\n          for(String bucket : buckets) {\n            bucketsList.add(new Bucket(bucket));\n          }\n\n          solrParams.put(CommonParams.QT, \"/export\");\n          for(Metric metric : metrics) {\n            fieldsList.remove(metric.getIdentifier());\n          }\n          solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n          tupleStream = new RollupStream(tupleStream, bucketsList.toArray(new Bucket[bucketsList.size()]), metricsArray);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    final TupleStream finalStream = tupleStream;\n\n    return new AbstractEnumerable<Object>() {\n      // Use original fields list to make sure only the fields specified are enumerated\n      public Enumerator<Object> enumerator() {\n        return new SolrEnumerator(finalStream, fields);\n      }\n    };\n  }\n\n","sourceOld":"  /** Executes a Solr query on the underlying table.\n   *\n   * @param properties Connections properties\n   * @param fields List of fields to project\n   * @param query A string for the query\n   * @return Enumerator of results\n   */\n  private Enumerable<Object> query(final Properties properties, final List<String> fields,\n                                   final String query, final List<String> order, final List<String> buckets,\n                                   final List<Metric> metrics, final String limit) {\n    // SolrParams should be a ModifiableParams instead of a map\n    Map<String, String> solrParams = new HashMap<>();\n    solrParams.put(CommonParams.OMIT_HEADER, \"true\");\n\n    if (query == null) {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY);\n    } else {\n      solrParams.put(CommonParams.Q, DEFAULT_QUERY + \" AND \" + query);\n    }\n\n    // List<String> doesn't have add so must make a new ArrayList\n    List<String> fieldsList = new ArrayList<>(fields);\n    List<String> orderList = new ArrayList<>(order);\n\n    if (!metrics.isEmpty()) {\n      for(String bucket : buckets) {\n        orderList.add(bucket + \" desc\");\n      }\n    }\n\n    if (orderList.isEmpty()) {\n      if (limit != null && Integer.parseInt(limit) > -1) {\n        orderList.add(DEFAULT_SCORE_FIELD + \" desc\");\n\n        // Make sure the default score field is in the field list\n        if (!fieldsList.contains(DEFAULT_SCORE_FIELD)) {\n          fieldsList.add(DEFAULT_SCORE_FIELD);\n        }\n      } else {\n        orderList.add(DEFAULT_VERSION_FIELD + \" desc\");\n\n        // Make sure the default sort field is in the field list\n        if (!fieldsList.contains(DEFAULT_VERSION_FIELD)) {\n          fieldsList.add(DEFAULT_VERSION_FIELD);\n        }\n      }\n    }\n\n    solrParams.put(CommonParams.SORT, String.join(\",\", orderList));\n\n    if (fieldsList.isEmpty()) {\n      solrParams.put(CommonParams.FL, \"*\");\n    } else {\n      solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n    }\n\n    TupleStream tupleStream;\n    String zk = properties.getProperty(\"zk\");\n    try {\n      if (metrics.isEmpty()) {\n        if (limit == null) {\n          solrParams.put(CommonParams.QT, \"/export\");\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n        } else {\n          solrParams.put(CommonParams.ROWS, limit);\n          tupleStream = new LimitStream(new CloudSolrStream(zk, collection, solrParams), Integer.parseInt(limit));\n        }\n      } else {\n        Metric[] metricsArray = metrics.toArray(new Metric[metrics.size()]);\n        if(buckets.isEmpty()) {\n          solrParams.remove(CommonParams.FL);\n          solrParams.remove(CommonParams.SORT);\n          tupleStream = new StatsStream(zk, collection, solrParams, metricsArray);\n        } else {\n          List<Bucket> bucketsList = new ArrayList<>();\n          for(String bucket : buckets) {\n            bucketsList.add(new Bucket(bucket));\n          }\n\n          solrParams.put(CommonParams.QT, \"/export\");\n          for(Metric metric : metrics) {\n            fieldsList.remove(metric.getIdentifier());\n          }\n          solrParams.put(CommonParams.FL, String.join(\",\", fieldsList));\n          tupleStream = new CloudSolrStream(zk, collection, solrParams);\n          tupleStream = new RollupStream(tupleStream, bucketsList.toArray(new Bucket[bucketsList.size()]), metricsArray);\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    final TupleStream finalStream = tupleStream;\n\n    return new AbstractEnumerable<Object>() {\n      // Use original fields list to make sure only the fields specified are enumerated\n      public Enumerator<Object> enumerator() {\n        return new SolrEnumerator(finalStream, fields);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9cc8e977a08af3169747ab78c578cc3037d095d5":["07aff67f9cb0c9aa9e65e72d68048f408871c951"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07aff67f9cb0c9aa9e65e72d68048f408871c951":["724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef"],"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"9cc8e977a08af3169747ab78c578cc3037d095d5":[],"07aff67f9cb0c9aa9e65e72d68048f408871c951":["9cc8e977a08af3169747ab78c578cc3037d095d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"724e3cf71b4c55b1c634bb1d76caaa0d9daf26ef":["07aff67f9cb0c9aa9e65e72d68048f408871c951"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9cc8e977a08af3169747ab78c578cc3037d095d5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}