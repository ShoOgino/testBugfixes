{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","pathOld":"/dev/null","sourceNew":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", random().nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", random().nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(random().nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","pathOld":"/dev/null","sourceNew":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", random().nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", random().nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(random().nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5048c558f8802f1689d38203111379406b171418","date":1486467652,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","sourceNew":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    clearIndex();\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", random().nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", random().nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(random().nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n  }\n\n","sourceOld":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    del(\"*:*\");\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", random().nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", random().nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(random().nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","sourceNew":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    clearIndex();\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", r.nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", r.nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(r.nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n\n    log.info(\"ensureRtgWorksWithPartialUpdatesTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    clearIndex();\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", random().nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", random().nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(random().nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#ensureRtgWorksWithPartialUpdatesTest().mjava","sourceNew":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    clearIndex();\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", r.nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", r.nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(r.nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n\n    log.info(\"ensureRtgWorksWithPartialUpdatesTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void ensureRtgWorksWithPartialUpdatesTest() throws Exception {\n    clearIndex();\n    commit();\n\n    float inplace_updatable_float = 1;\n    String title = \"title100\";\n    long version = 0, currentVersion;\n\n    currentVersion = buildRandomIndex(100).get(0);\n    assertTrue(currentVersion > version);\n\n    // do an initial (non-inplace) update to ensure both the float & int fields we care about have (any) value\n    // that way all subsequent atomic updates will be inplace\n    currentVersion = addDocAndGetVersion(\"id\", 100,\n                                         \"inplace_updatable_float\", map(\"set\", r.nextFloat()),\n                                         \"inplace_updatable_int\", map(\"set\", r.nextInt()));\n    LEADER.commit();\n    \n    // get the internal docids of id=100 document from the three replicas\n    List<Integer> docids = getInternalDocIds(\"100\");\n\n    // update doc, set\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    SolrDocument sdoc = LEADER.getById(\"100\");  // RTG straight from the index\n    assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n    assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n    if(r.nextBoolean()) {\n      title = \"newtitle100\";\n      currentVersion = addDocAndGetVersion(\"id\", 100, \"title_s\", title, \"inplace_updatable_float\", inplace_updatable_float); // full indexing\n      assertTrue(currentVersion > version);\n      version = currentVersion;\n\n      sdoc = LEADER.getById(\"100\");  // RTG from the tlog\n      assertEquals(sdoc.toString(), (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(sdoc.toString(), title, sdoc.get(\"title_s\"));\n      assertEquals(sdoc.toString(), version, sdoc.get(\"_version_\"));\n\n      // we've done a full index, so we need to update the [docid] for each replica\n      LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n      docids = getInternalDocIds(\"100\");\n    }\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n    LEADER.commit();\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n    \n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_int\", map(\"set\", \"100\"));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    inplace_updatable_float++;\n    currentVersion = addDocAndGetVersion(\"id\", 100, \"inplace_updatable_float\", map(\"inc\", 1));\n    assertTrue(currentVersion > version);\n    version = currentVersion;\n\n    // RTG from tlog(s)\n    for (SolrClient client : clients) {\n      final String clientDebug = client.toString() + (LEADER.equals(client) ? \" (leader)\" : \" (not leader)\");\n      sdoc = client.getById(\"100\", params(\"distrib\", \"false\"));\n\n      assertEquals(clientDebug + \" => \"+ sdoc, (int) 100, sdoc.get(\"inplace_updatable_int\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, (float) inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, title, sdoc.get(\"title_s\"));\n      assertEquals(clientDebug + \" => \"+ sdoc, version, sdoc.get(\"_version_\"));\n    }\n    \n    // assert that the internal docid for id=100 document remains same, in each replica, as before\n    LEADER.commit(); // can't get (real) [docid] from the tlogs, need to force a commit\n    assertTrue(\"Earlier: \"+docids+\", now: \"+getInternalDocIds(\"100\"), docids.equals(getInternalDocIds(\"100\")));\n\n    log.info(\"ensureRtgWorksWithPartialUpdatesTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["5048c558f8802f1689d38203111379406b171418"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5048c558f8802f1689d38203111379406b171418":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","5048c558f8802f1689d38203111379406b171418"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["e98520789adb1d5ad05afb4956eca0944a929688"],"5048c558f8802f1689d38203111379406b171418":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}