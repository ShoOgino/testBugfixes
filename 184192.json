{"path":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","commits":[{"id":"faee9bc2585a43773210f032b2bdcff90d9a12bf","date":1450411263,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, amoung other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3646ead588297558973dbd1162e69791e822b944"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","sourceNew":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, among other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","sourceOld":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, amoung other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","bugFix":null,"bugIntro":["3646ead588297558973dbd1162e69791e822b944"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","sourceNew":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, among other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","sourceOld":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, amoung other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","sourceNew":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, among other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","sourceOld":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, amoung other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3646ead588297558973dbd1162e69791e822b944","date":1525482176,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateShardHandler#getRecoveryExecutor().mjava","sourceNew":"  /**\n   * \n   * @return executor for recovery operations\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","sourceOld":"  /**\n   * In general, RecoveryStrategy threads do not do disk IO, but they open and close SolrCores\n   * in async threads, among other things, and can trigger disk IO, so we use this alternate \n   * executor rather than the 'updateExecutor', which is interrupted on shutdown.\n   * \n   * @return executor for {@link RecoveryStrategy} thread which will not be interrupted on close.\n   */\n  public ExecutorService getRecoveryExecutor() {\n    return recoveryExecutor;\n  }\n\n","bugFix":["0158ced21948b6626f733c1c42c1e18d94449789","faee9bc2585a43773210f032b2bdcff90d9a12bf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"faee9bc2585a43773210f032b2bdcff90d9a12bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3646ead588297558973dbd1162e69791e822b944":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["faee9bc2585a43773210f032b2bdcff90d9a12bf","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3646ead588297558973dbd1162e69791e822b944"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["faee9bc2585a43773210f032b2bdcff90d9a12bf","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["faee9bc2585a43773210f032b2bdcff90d9a12bf"]},"commit2Childs":{"faee9bc2585a43773210f032b2bdcff90d9a12bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"3646ead588297558973dbd1162e69791e822b944":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["faee9bc2585a43773210f032b2bdcff90d9a12bf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["3646ead588297558973dbd1162e69791e822b944","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}