{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","commits":[{"id":"97bd2b0da4beced82821b752b29576be986cf1ff","date":1387747012,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      server.request(prepCmd);\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName)\n      throws SolrServerException, IOException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      \n      server.request(prepCmd);\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0d275eddd9810d17e658bef5d4b8c227e7bd0f7","date":1394728218,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      server.request(prepCmd);\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      server.request(prepCmd);\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":["97bd2b0da4beced82821b752b29576be986cf1ff"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fee8f787196eb664b953b851d18c52f0d8c9e157","date":1395630304,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      server.request(prepCmd);\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrClient server = new HttpSolrClient(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrServer server = new HttpSolrServer(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n    HttpSolrClient server = new HttpSolrClient(leaderBaseUrl);\n    try {\n      server.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = server.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    } finally {\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":["6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      if (!Slice.CONSTRUCTION.equals(slice.getState()) && !Slice.RECOVERY.equals(slice.getState())) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(ZkStateReader.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"610f5499a87a7113d53e5b621b616890f002e9f1","date":1450873010,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      log.info(\"Sending prep recovery command to {}; {}\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient(leaderBaseUrl)) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","date":1473679846,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"bugIntro":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"970a667af41fa94f5b9e55f7d08c90b51daf989d","date":1478330202,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        SolrServerException solrException = (SolrServerException) e.getCause();\n        if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n          LOG.warn(\"Socket timeout when send prep recovery cmd, retrying.. \");\n          continue;\n        }\n        throw  e;\n      }\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","2d750082a4223c20902ef11ff6a9831d55738ea4","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","97bd2b0da4beced82821b752b29576be986cf1ff","14d5815ecbef89580f5c48990bcd433f04f8563a","cc3b13b430571c2e169f98fe38e1e7666f88522d","610f5499a87a7113d53e5b621b616890f002e9f1","fee8f787196eb664b953b851d18c52f0d8c9e157","a219f1dcad1700e84807666bdbd2b573e8de7021"],"bugIntro":["85dde6afb72b4b033a03ca39ddbd90851775c7a1","8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        SolrServerException solrException = (SolrServerException) e.getCause();\n        if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n          LOG.warn(\"Socket timeout when send prep recovery cmd, retrying.. \");\n          continue;\n        }\n        throw  e;\n      }\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(30000);\n      WaitForState prepCmd = new WaitForState();\n      prepCmd.setCoreName(leaderCoreName);\n      prepCmd.setNodeName(zkController.getNodeName());\n      prepCmd.setCoreNodeName(coreZkNodeName);\n      prepCmd.setState(Replica.State.RECOVERING);\n      prepCmd.setCheckLive(true);\n      prepCmd.setOnlyIfLeader(true);\n      final Slice.State state = slice.getState();\n      if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n        prepCmd.setOnlyIfLeaderActive(true);\n      }\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n      \n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n      \n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85dde6afb72b4b033a03ca39ddbd90851775c7a1","date":1487554712,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof SolrServerException) {\n          SolrServerException solrException = (SolrServerException) e.getCause();\n          if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n            LOG.warn(\"Socket timeout on send prep recovery cmd, retrying.. \");\n            continue;\n          }\n        }\n        throw  e;\n      }\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        SolrServerException solrException = (SolrServerException) e.getCause();\n        if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n          LOG.warn(\"Socket timeout when send prep recovery cmd, retrying.. \");\n          continue;\n        }\n        throw  e;\n      }\n    }\n  }\n\n","bugFix":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"bugIntro":["8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof SolrServerException) {\n          SolrServerException solrException = (SolrServerException) e.getCause();\n          if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n            LOG.warn(\"Socket timeout on send prep recovery cmd, retrying.. \");\n            continue;\n          }\n        }\n        throw  e;\n      }\n    }\n  }\n\n","sourceOld":"  private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof SolrServerException) {\n          SolrServerException solrException = (SolrServerException) e.getCause();\n          if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n            LOG.warn(\"Socket timeout on send prep recovery cmd, retrying.. \");\n            continue;\n          }\n        }\n        throw  e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1","date":1499091633,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + 8000;\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof SolrServerException) {\n          SolrServerException solrException = (SolrServerException) e.getCause();\n          if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n            LOG.warn(\"Socket timeout on send prep recovery cmd, retrying.. \");\n            continue;\n          }\n        }\n        throw  e;\n      }\n    }\n  }\n\n","bugFix":["970a667af41fa94f5b9e55f7d08c90b51daf989d","97bd2b0da4beced82821b752b29576be986cf1ff","85dde6afb72b4b033a03ca39ddbd90851775c7a1"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + 8000;\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    final int maxTries = 30;\n    for (int numTries = 0; numTries < maxTries; numTries++) {\n      try {\n        sendPrepRecoveryCmd(leaderBaseUrl, prepCmd);\n        break;\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof SolrServerException) {\n          SolrServerException solrException = (SolrServerException) e.getCause();\n          if (solrException.getRootCause() instanceof SocketTimeoutException && numTries < maxTries) {\n            LOG.warn(\"Socket timeout on send prep recovery cmd, retrying.. \");\n            continue;\n          }\n        }\n        throw  e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + 8000;\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + 8000;\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      LOG.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + Integer.parseInt(System.getProperty(\"prepRecoveryReadTimeoutExtraWait\", \"8000\"));\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl)\n        .withHttpClient(cc.getUpdateShardHandler().getRecoveryOnlyHttpClient()).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + 8000;\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","bugFix":["8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1"],"bugIntro":["9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791","date":1562879086,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + Integer.parseInt(System.getProperty(\"prepRecoveryReadTimeoutExtraWait\", \"8000\"));\n    try (HttpSolrClient client = buildRecoverySolrClient(leaderBaseUrl)) {\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + Integer.parseInt(System.getProperty(\"prepRecoveryReadTimeoutExtraWait\", \"8000\"));\n    try (HttpSolrClient client = new HttpSolrClient.Builder(leaderBaseUrl)\n        .withHttpClient(cc.getUpdateShardHandler().getRecoveryOnlyHttpClient()).build()) {\n      client.setConnectionTimeout(10000);\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","bugFix":["8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#sendPrepRecoveryCmd(String,String,Slice).mjava","sourceNew":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + Integer.parseInt(System.getProperty(\"prepRecoveryReadTimeoutExtraWait\", \"8000\"));\n    try (HttpSolrClient client = buildRecoverySolrClient(leaderBaseUrl)) {\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd);\n\n      mrr.future.get();\n    }\n  }\n\n","sourceOld":"  final private void sendPrepRecoveryCmd(String leaderBaseUrl, String leaderCoreName, Slice slice)\n      throws SolrServerException, IOException, InterruptedException, ExecutionException {\n\n    WaitForState prepCmd = new WaitForState();\n    prepCmd.setCoreName(leaderCoreName);\n    prepCmd.setNodeName(zkController.getNodeName());\n    prepCmd.setCoreNodeName(coreZkNodeName);\n    prepCmd.setState(Replica.State.RECOVERING);\n    prepCmd.setCheckLive(true);\n    prepCmd.setOnlyIfLeader(true);\n    final Slice.State state = slice.getState();\n    if (state != Slice.State.CONSTRUCTION && state != Slice.State.RECOVERY && state != Slice.State.RECOVERY_FAILED) {\n      prepCmd.setOnlyIfLeaderActive(true);\n    }\n\n    int conflictWaitMs = zkController.getLeaderConflictResolveWait();\n    // timeout after 5 seconds more than the max timeout (conflictWait + 3 seconds) on the server side\n    int readTimeout = conflictWaitMs + Integer.parseInt(System.getProperty(\"prepRecoveryReadTimeoutExtraWait\", \"8000\"));\n    try (HttpSolrClient client = buildRecoverySolrClient(leaderBaseUrl)) {\n      client.setSoTimeout(readTimeout);\n      HttpUriRequestResponse mrr = client.httpUriRequest(prepCmd);\n      prevSendPreRecoveryHttpUriRequest = mrr.httpUriRequest;\n\n      log.info(\"Sending prep recovery command to [{}]; [{}]\", leaderBaseUrl, prepCmd.toString());\n\n      mrr.future.get();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"610f5499a87a7113d53e5b621b616890f002e9f1":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"97bd2b0da4beced82821b752b29576be986cf1ff":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["610f5499a87a7113d53e5b621b616890f002e9f1"],"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"ad4957cde742defe6db19689abdc267c5d948066":["9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","970a667af41fa94f5b9e55f7d08c90b51daf989d"],"bafca15d8e408346a67f4282ad1143b88023893b":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"970a667af41fa94f5b9e55f7d08c90b51daf989d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"89424def13674ea17829b41c5883c54ecc31a132":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b"],"0c924d4069ef5a5bc479a493befe0121aada6896":["cc3b13b430571c2e169f98fe38e1e7666f88522d","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","89424def13674ea17829b41c5883c54ecc31a132"],"85dde6afb72b4b033a03ca39ddbd90851775c7a1":["970a667af41fa94f5b9e55f7d08c90b51daf989d"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["fee8f787196eb664b953b851d18c52f0d8c9e157"],"8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1"],"30c8e5574b55d57947e989443dfde611646530ee":["7392b75d2c2f2aecf31188732a0764fe0dc74ade","8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"fee8f787196eb664b953b851d18c52f0d8c9e157":["f0d275eddd9810d17e658bef5d4b8c227e7bd0f7"],"f0d275eddd9810d17e658bef5d4b8c227e7bd0f7":["97bd2b0da4beced82821b752b29576be986cf1ff"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["610f5499a87a7113d53e5b621b616890f002e9f1","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["85dde6afb72b4b033a03ca39ddbd90851775c7a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad4957cde742defe6db19689abdc267c5d948066"]},"commit2Childs":{"610f5499a87a7113d53e5b621b616890f002e9f1":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"97bd2b0da4beced82821b752b29576be986cf1ff":["f0d275eddd9810d17e658bef5d4b8c227e7bd0f7"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","a219f1dcad1700e84807666bdbd2b573e8de7021"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b":["89424def13674ea17829b41c5883c54ecc31a132"],"ad4957cde742defe6db19689abdc267c5d948066":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"970a667af41fa94f5b9e55f7d08c90b51daf989d":["199dfa410f1fdbfd3294106b04096cce5ed34b21","85dde6afb72b4b033a03ca39ddbd90851775c7a1"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["610f5499a87a7113d53e5b621b616890f002e9f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["97bd2b0da4beced82821b752b29576be986cf1ff"],"9b62c5fc89bd60031bc1f51ff1f8a21c5b0bf791":["ad4957cde742defe6db19689abdc267c5d948066"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["970a667af41fa94f5b9e55f7d08c90b51daf989d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"85dde6afb72b4b033a03ca39ddbd90851775c7a1":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["bafca15d8e408346a67f4282ad1143b88023893b"],"8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","30c8e5574b55d57947e989443dfde611646530ee"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"30c8e5574b55d57947e989443dfde611646530ee":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"fee8f787196eb664b953b851d18c52f0d8c9e157":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"f0d275eddd9810d17e658bef5d4b8c227e7bd0f7":["fee8f787196eb664b953b851d18c52f0d8c9e157"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["8dcdc17e7cf73a4779ecf173ff719b51fe2a2dd1","30c8e5574b55d57947e989443dfde611646530ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","0c924d4069ef5a5bc479a493befe0121aada6896","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}