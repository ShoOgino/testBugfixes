{"path":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e1b576e3bbc8e6b8de040b53d75af6e7e907760e","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9","date":1270985469,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    boolean seenIndexFiles = false;\n    for (String fileName : directory.listAll()) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        seenIndexFiles = true;\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n    // to be null, because it means it's a fresh Directory. Therefore it cannot\n    // be any NFS cache issues - so just ignore.\n    if (currentCommitPoint == null && seenIndexFiles) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (seenIndexFiles) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10","date":1270996866,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    boolean seenIndexFiles = false;\n    for (String fileName : directory.listAll()) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        seenIndexFiles = true;\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n    // to be null, because it means it's a fresh Directory. Therefore it cannot\n    // be any NFS cache issues - so just ignore.\n    if (currentCommitPoint == null && seenIndexFiles) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (seenIndexFiles) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4","date":1271167458,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    boolean seenIndexFiles = false;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        seenIndexFiles = true;\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n    // to be null, because it means it's a fresh Directory. Therefore it cannot\n    // be any NFS cache issues - so just ignore.\n    if (currentCommitPoint == null && seenIndexFiles) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (seenIndexFiles) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"bugIntro":["e1b576e3bbc8e6b8de040b53d75af6e7e907760e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1b576e3bbc8e6b8de040b53d75af6e7e907760e","date":1276249504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    boolean seenIndexFiles = false;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        seenIndexFiles = true;\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n    // to be null, because it means it's a fresh Directory. Therefore it cannot\n    // be any NFS cache issues - so just ignore.\n    if (currentCommitPoint == null && seenIndexFiles) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (seenIndexFiles) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e","date":1277411648,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"caaf811ae0bc71da3f3062e76ef487f795c137e9","date":1277469444,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    boolean seenIndexFiles = false;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        seenIndexFiles = true;\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName, codecs);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    // If we haven't seen any Lucene files, then currentCommitPoint is expected\n    // to be null, because it means it's a fresh Directory. Therefore it cannot\n    // be any NFS cache issues - so just ignore.\n    if (currentCommitPoint == null && seenIndexFiles) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName(), codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (seenIndexFiles) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","date":1288192616,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","date":1288424244,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6","date":1288888250,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["f237ee05f4e8e1fae6614bce022e0dc66c5ed39e","955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, CodecProvider codecs) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null) {\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null) {\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, CodecProvider codecs) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null) {\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null) {\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos(codecs);\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos(codecs);\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter,CodecProvider).mjava","sourceNew":null,"sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter,\n                          CodecProvider codecs)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    indexFilenameFilter = new IndexFileNameFilter(codecs);\n    \n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {  \n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((indexFilenameFilter.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n        \n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream != null) {\n            message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName, codecs);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream != null) {\n              message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile, codecs);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e1b576e3bbc8e6b8de040b53d75af6e7e907760e":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"85a883878c0af761245ab048babc63d099f835f3":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["85a883878c0af761245ab048babc63d099f835f3","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"5f4e87790277826a2aea119328600dfb07761f32":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4","caaf811ae0bc71da3f3062e76ef487f795c137e9"],"caaf811ae0bc71da3f3062e76ef487f795c137e9":["f237ee05f4e8e1fae6614bce022e0dc66c5ed39e"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["caaf811ae0bc71da3f3062e76ef487f795c137e9"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["caaf811ae0bc71da3f3062e76ef487f795c137e9","ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e":["e1b576e3bbc8e6b8de040b53d75af6e7e907760e"]},"commit2Childs":{"e1b576e3bbc8e6b8de040b53d75af6e7e907760e":["f237ee05f4e8e1fae6614bce022e0dc66c5ed39e"],"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"85a883878c0af761245ab048babc63d099f835f3":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"caaf811ae0bc71da3f3062e76ef487f795c137e9":["5f4e87790277826a2aea119328600dfb07761f32","ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","ca0ffea399542e8aac8ed7608f34f8ec4cb8904d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["e1b576e3bbc8e6b8de040b53d75af6e7e907760e","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["85a883878c0af761245ab048babc63d099f835f3"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["85a883878c0af761245ab048babc63d099f835f3","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"f237ee05f4e8e1fae6614bce022e0dc66c5ed39e":["caaf811ae0bc71da3f3062e76ef487f795c137e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}