{"path":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"/dev/null","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":null,"sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"/dev/null","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd00dd91853514614379b0e680d65bd19cac0f30","date":1283087816,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b251fe1c921fcd21c43703b7483d1a223c67042","date":1283983459,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"99ae3203affce3343d4924964062c41727ea4ee3","date":1284074041,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                ,\"debugQuery\",\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7e2c5596ef3fbb03572368a66afb40a500404ab","date":1297903084,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":["dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c","66ab3886c1d845c59c9e5b23b2fb247b927db498"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n      // System.out.println(\"#########################################\" + f + \"=\" + v);\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // function query... just make sure it doesn't throw an exception\n       assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n            ,\"//result[@numFound='1']\"\n        );\n\n    }\n\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eeff6b8391d7b5e70e37193643d76c05a3abf75","date":1302902022,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80f6925d29ae169407185d52267ba1969126e1e2","date":1307134127,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03daa6ddcb4768a702115ec63799cab5fff3d92","date":1307140842,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7c99bd45fa88a3d93a03fdd773053bef72268e","date":1307218088,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n      \n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34","date":1309197122,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","pathOld":"solr/src/test/org/apache/solr/search/TestQueryTypes#testQueryTypes().mjava","sourceNew":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","sourceOld":"  public void testQueryTypes() {\n    assertU(adoc(\"id\",\"0\"));\n    assertU(adoc(\"id\",\"1\", \"v_t\",\"Hello Dude\"));\n    assertU(adoc(\"id\",\"2\", \"v_t\",\"Hello Yonik\"));\n    assertU(adoc(\"id\",\"3\", \"v_s\",\"{!literal}\"));\n    assertU(adoc(\"id\",\"4\", \"v_s\",\"other stuff\"));\n    assertU(adoc(\"id\",\"5\", \"v_f\",\"3.14159\"));\n    assertU(adoc(\"id\",\"6\", \"v_f\",\"8983\"));\n    assertU(adoc(\"id\",\"7\", \"v_f\",\"1.5\"));\n    assertU(adoc(\"id\",\"8\", \"v_ti\",\"5\"));\n    assertU(adoc(\"id\",\"9\", \"v_s\",\"internal\\\"quote\"));\n\n    Object[] arr = new Object[] {\n    \"id\",999.0\n    ,\"v_s\",\"wow dude\"\n    ,\"v_t\",\"wow\"\n    ,\"v_ti\",-1\n    ,\"v_tis\",-1\n    ,\"v_tl\",-1234567891234567890L\n    ,\"v_tls\",-1234567891234567890L\n    ,\"v_tf\",-2.0f\n    ,\"v_tfs\",-2.0f\n    ,\"v_td\",-2.0\n    ,\"v_tds\",-2.0\n    ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    ,\"v_tdts\",\"2002-08-26T01:01:01Z\"\n    };\n    String[] sarr = new String[arr.length];\n    for (int i=0; i<arr.length; i++) {\n      sarr[i] = arr[i].toString();\n    }\n\n    assertU(adoc(sarr));\n    assertU(optimize());\n\n    // test field queries\n    for (int i=0; i<arr.length; i+=2) {\n      String f = arr[i].toString();\n      String v = arr[i+1].toString();\n\n      // normal lucene fielded query\n      assertQ(req( \"q\",f+\":\\\"\"+v+'\"')\n              ,\"//result[@numFound='1']\"\n              ,\"//*[@name='id'][.='999.0']\"\n              ,\"//*[@name='\" + f + \"'][.='\" + v + \"']\"\n              );\n\n      // field qparser\n      assertQ(req( \"q\", \"{!field f=\"+f+\"}\"+v)\n              ,\"//result[@numFound='1']\"\n              );\n\n      // lucene range\n      assertQ(req( \"q\", f + \":[\\\"\" + v + \"\\\" TO \\\"\" + v + \"\\\"]\" )\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // frange and function query only work on single valued field types\n    Object[] fc_vals = new Object[] {\n      \"id\",999.0\n      ,\"v_s\",\"wow dude\"\n      ,\"v_ti\",-1\n      ,\"v_tl\",-1234567891234567890L\n      ,\"v_tf\",-2.0f\n      ,\"v_td\",-2.0\n      ,\"v_tdt\",\"2000-05-10T01:01:01Z\"\n    };\n    \n    for (int i=0; i<fc_vals.length; i+=2) {\n      String f = fc_vals[i].toString();\n      String v = fc_vals[i+1].toString();\n      \n      // frange qparser\n      assertQ(req( \"q\", \"{!frange v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter not cached\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n       // frange as filter run after the main query\n      assertQ(req( \"q\",\"*:*\", \"fq\", \"{!frange cache=false cost=100 v=\"+f+\" l='\"+v+\"' u='\"+v+\"'}\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // exists()\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      // boolean value of non-zero values (just leave off the exists from the prev test)\n      assertQ(req( \"fq\",\"id:999\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n              ,\"//result[@numFound='1']\"\n              );\n\n      if (!\"id\".equals(f)) {\n        assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(exists(\"+f+\"),1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n       // boolean value of zero/missing values (just leave off the exists from the prev test)\n       assertQ(req( \"fq\",\"id:1\", \"q\", \"{!frange l=1 u=1}if(\"+f+\",1,0)\" )\n            ,\"//result[@numFound='0']\"\n        );\n\n      }\n\n      // function query... just make sure it doesn't throw an exception\n      if (\"v_s\".equals(f)) continue;  // in this context, functions must be able to be interpreted as a float\n      assertQ(req( \"q\", \"+id:999 _val_:\\\"\" + f + \"\\\"\")\n              ,\"//result[@numFound='1']\"\n              );\n    }\n\n    // Some basic tests to ensure that parsing local params is working\n    assertQ(\"test prefix query\",\n            req(\"q\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    // no analysis is done, so these should match nothing\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_t}Hello\")\n            ,\"//result[@numFound='0']\"\n            );\n    assertQ(\"test raw query\",\n            req(\"q\",\"{!raw f=v_f}1.5\")\n            ,\"//result[@numFound='0']\"\n            );\n\n    // test \"term\" qparser, which should only do readableToIndexed\n    assertQ(\n            req(\"q\",\"{!term f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );\n    \n    // text fields are *not* analyzed since they may not be idempotent\n    assertQ(\n           req(\"q\",\"{!term f=v_t}Hello\")\n           ,\"//result[@numFound='0']\"\n           );\n     assertQ(\n           req(\"q\",\"{!term f=v_t}hello\")\n           ,\"//result[@numFound='2']\"\n           );\n\n\n    //\n    // test escapes in quoted strings\n    //\n\n    // the control... unescaped queries looking for internal\"quote\n    assertQ(req(\"q\",\"{!raw f=v_s}internal\\\"quote\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test that single quoted string needs no escape\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // but it's OK if the escape is done\n    assertQ(req(\"q\",\"{!raw f=v_s v='internal\\\\\\\"quote'}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test unicode escape\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\u0022quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // inside a quoted string, internal\"quote needs to be escaped\n    assertQ(req(\"q\",\"{!raw f=v_s v=\\\"internal\\\\\\\"quote\\\"}\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    assertQ(\"test custom plugin query\",\n            req(\"q\",\"{!foo f=v_t}hello\")\n            ,\"//result[@numFound='2']\"\n            );\n\n\n    assertQ(\"test single term field query on text type\",\n            req(\"q\",\"{!field f=v_t}HELLO\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test single term field query on type with diff internal rep\",\n            req(\"q\",\"{!field f=v_f}1.5\")\n            ,\"//result[@numFound='1']\"\n            );    \n\n    assertQ(\n            req(\"q\",\"{!field f=v_ti}5\")\n            ,\"//result[@numFound='1']\"\n            );\n\n     assertQ(\"test multi term field query on text type\",\n            req(\"q\",\"{!field f=v_t}Hello  DUDE\")\n            ,\"//result[@numFound='1']\"\n            );\n\n\n    assertQ(\"test prefix query with value in local params\",\n            req(\"q\",\"{!prefix f=v_t v=hel}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test optional quotes\",\n            req(\"q\",\"{!prefix f='v_t' v=\\\"hel\\\"}\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test extra whitespace\",\n            req(\"q\",\"{!prefix   f=v_t   v=hel   }\")\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test literal with {! in it\",\n            req(\"q\",\"{!prefix f=v_s}{!lit\")\n            ,\"//result[@numFound='1']\"\n    );\n\n    assertQ(\"test param subst\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_t\", \"my.v\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    // test wacky param names\n    assertQ(\n            req(\"q\",\"{!prefix f=$a/b/c v=$'a b/c'}\"\n                ,\"a/b/c\",\"v_t\", \"a b/c\", \"hel\"\n            )\n            ,\"//result[@numFound='2']\"\n    );\n\n    assertQ(\"test param subst with literal\",\n            req(\"q\",\"{!prefix f=$myf v=$my.v}\"\n                ,\"myf\",\"v_s\", \"my.v\", \"{!lit\"\n            )\n            ,\"//result[@numFound='1']\"\n    );\n\n   // lucene queries\n   assertQ(\"test lucene query\",\n            req(\"q\",\"{!lucene}v_t:hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene queries\n   assertQ(\"test lucene default field\",\n            req(\"q\",\"{!df=v_t}hel*\")\n            ,\"//result[@numFound='2']\"\n            );\n\n   // lucene operator\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=OR df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='2']\"\n            );\n   assertQ(\"test lucene operator\",\n            req(\"q\",\"{!q.op=AND df=v_t}Hello Yonik\")\n            ,\"//result[@numFound='1']\"\n            );\n\n    // test boost queries\n    assertQ(\"test boost\",\n            req(\"q\",\"{!boost b=sum(v_f,1)}id:[5 TO 6]\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//result[@numFound='2']\"\n            ,\"//doc[./float[@name='v_f']='3.14159' and ./float[@name='score']='4.14159']\"\n    );\n\n    assertQ(\"test boost and default type of func\",\n            req(\"q\",\"{!boost v=$q1 b=$q2}\"\n                ,\"q1\", \"{!func}v_f\", \"q2\",\"v_f\"\n                ,\"fl\",\"*,score\"\n            )\n            ,\"//doc[./float[@name='v_f']='1.5' and ./float[@name='score']='2.25']\"\n    );\n\n\n    // dismax query from std request handler\n    assertQ(\"test dismax query\",\n             req(\"q\",\"{!dismax}hello\"\n                ,\"qf\",\"v_t\"\n                ,\"bf\",\"sqrt(v_f)^100 log(sum(v_f,1))^50\"\n                ,\"bq\",\"{!prefix f=v_t}he\"\n                , CommonParams.DEBUG_QUERY,\"on\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    // dismax query from std request handler, using local params\n    assertQ(\"test dismax query w/ local params\",\n             req(\"q\",\"{!dismax qf=v_t}hello\"\n                ,\"qf\",\"v_f\"\n             )\n             ,\"//result[@numFound='2']\"\n             );\n\n    assertQ(\"test nested query\",\n            req(\"q\",\"_query_:\\\"{!query v=$q1}\\\"\", \"q1\",\"{!prefix f=v_t}hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n    assertQ(\"test nested nested query\",\n            req(\"q\",\"_query_:\\\"{!query defType=query v=$q1}\\\"\", \"q1\",\"{!v=$q2}\",\"q2\",\"{!prefix f=v_t v=$qqq}\",\"qqq\",\"hel\")\n            ,\"//result[@numFound='2']\"\n            );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["99ae3203affce3343d4924964062c41727ea4ee3","f7e2c5596ef3fbb03572368a66afb40a500404ab"],"c26f00b574427b55127e869b935845554afde1fa":["f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","99ae3203affce3343d4924964062c41727ea4ee3"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["bde51b089eb7f86171eb3406e38a274743f9b7ac","5eeff6b8391d7b5e70e37193643d76c05a3abf75"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34":["80f6925d29ae169407185d52267ba1969126e1e2"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":["135621f3a0670a9394eb563224a3b76cc4dddc0f","80f6925d29ae169407185d52267ba1969126e1e2"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","f7e2c5596ef3fbb03572368a66afb40a500404ab"],"80f6925d29ae169407185d52267ba1969126e1e2":["5eeff6b8391d7b5e70e37193643d76c05a3abf75"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","5eeff6b8391d7b5e70e37193643d76c05a3abf75"],"2553b00f699380c64959ccb27991289aae87be2e":["1e7c99bd45fa88a3d93a03fdd773053bef72268e","f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["80f6925d29ae169407185d52267ba1969126e1e2","f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["a3776dccca01c11e7046323cfad46a3b4a471233","80f6925d29ae169407185d52267ba1969126e1e2"],"cd00dd91853514614379b0e680d65bd19cac0f30":["1da8d55113b689b06716246649de6f62430f15c0"],"5eeff6b8391d7b5e70e37193643d76c05a3abf75":["f7e2c5596ef3fbb03572368a66afb40a500404ab"],"f7e2c5596ef3fbb03572368a66afb40a500404ab":["99ae3203affce3343d4924964062c41727ea4ee3"],"99ae3203affce3343d4924964062c41727ea4ee3":["5b251fe1c921fcd21c43703b7483d1a223c67042"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"5b251fe1c921fcd21c43703b7483d1a223c67042":["cd00dd91853514614379b0e680d65bd19cac0f30"],"a3776dccca01c11e7046323cfad46a3b4a471233":["f7e2c5596ef3fbb03572368a66afb40a500404ab","5eeff6b8391d7b5e70e37193643d76c05a3abf75"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"f1bdbf92da222965b46c0a942c3857ba56e5c638":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd00dd91853514614379b0e680d65bd19cac0f30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"c03daa6ddcb4768a702115ec63799cab5fff3d92":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"80f6925d29ae169407185d52267ba1969126e1e2":["f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34","c03daa6ddcb4768a702115ec63799cab5fff3d92","d083e83f225b11e5fdd900e83d26ddb385b6955c","1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c03daa6ddcb4768a702115ec63799cab5fff3d92"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["2553b00f699380c64959ccb27991289aae87be2e"],"cd00dd91853514614379b0e680d65bd19cac0f30":["5b251fe1c921fcd21c43703b7483d1a223c67042"],"5eeff6b8391d7b5e70e37193643d76c05a3abf75":["d493718201f0d0c54c773fb323d87bbd2fbffe41","80f6925d29ae169407185d52267ba1969126e1e2","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233"],"f7e2c5596ef3fbb03572368a66afb40a500404ab":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","5eeff6b8391d7b5e70e37193643d76c05a3abf75","a3776dccca01c11e7046323cfad46a3b4a471233"],"99ae3203affce3343d4924964062c41727ea4ee3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","f7e2c5596ef3fbb03572368a66afb40a500404ab"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a3776dccca01c11e7046323cfad46a3b4a471233":["1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"5b251fe1c921fcd21c43703b7483d1a223c67042":["99ae3203affce3343d4924964062c41727ea4ee3"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d493718201f0d0c54c773fb323d87bbd2fbffe41","c03daa6ddcb4768a702115ec63799cab5fff3d92","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}