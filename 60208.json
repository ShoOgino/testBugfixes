{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","commits":[{"id":"937923083e4d137932336fc80f3d78758ff698a6","date":1454691519,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62cc423073d23f01208c6cf85844dedd80011121","date":1454731549,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: GeoUtils APIs are still buggy for large distances:\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        boolean expected = distanceMeters <= radiusMeters;\n\n        boolean actual = hits.contains(docID);\n        if (actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec60431d008a694828dacb4bc3cda775b6c44a9f","date":1458570843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3","date":1458680048,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testGeoRelations().mjava","sourceNew":null,"sourceOld":"  /** Tests consistency of GeoEncodingUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */\n  public void testGeoRelations() throws Exception {\n\n    int numDocs = atLeast(1000);\n    \n    boolean useSmallRanges = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + numDocs + \" docs useSmallRanges=\" + useSmallRanges);\n    }\n\n    double[] docLons = new double[numDocs];\n    double[] docLats = new double[numDocs];\n    for(int docID=0;docID<numDocs;docID++) {\n      docLons[docID] = randomLon(useSmallRanges);\n      docLats[docID] = randomLat(useSmallRanges);\n      if (VERBOSE) {\n        System.out.println(\"  doc=\" + docID + \": lon=\" + docLons[docID] + \" lat=\" + docLats[docID]);\n      }\n    }\n\n    int iters = atLeast(10);\n\n    iters = atLeast(50);\n    \n    for(int iter=0;iter<iters;iter++) {\n\n      Cell.nextCellID = 0;\n\n      double centerLon = randomLon(useSmallRanges);\n      double centerLat = randomLat(useSmallRanges);\n\n      // So the circle covers at most 50% of the earth's surface:\n\n      double radiusMeters;\n\n      // TODO: large exotic rectangles created by BKD may be inaccurate up to 2 times DISTANCE_PCT_ERR.\n      // restricting size until LUCENE-6994 can be addressed\n      if (true || useSmallRanges) {\n        // Approx 3 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 333000;\n      } else {\n        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;\n      }\n\n      StringWriter sw = new StringWriter();\n      PrintWriter log = new PrintWriter(sw, true);\n\n      if (VERBOSE) {\n        log.println(\"\\nTEST: iter=\" + iter + \" radiusMeters=\" + radiusMeters + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat);\n      }\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n      \n      Set<Integer> hits = new HashSet<>();\n\n      if (bbox.maxLon < bbox.minLon) {\n        // Crosses dateline\n        log.println(\"  circle crosses dateline; first left query\");\n        double unwrappedLon = centerLon;\n        if (unwrappedLon > bbox.maxLon) {\n          // unwrap left\n          unwrappedLon += -360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             -180, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n        log.println(\"  circle crosses dateline; now right query\");\n        if (unwrappedLon < bbox.maxLon) {\n          // unwrap right\n          unwrappedLon += 360.0D;\n        }\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             180, bbox.maxLat,\n                             0),\n                    unwrappedLon, centerLat, radiusMeters, docLons, docLats);\n      } else {\n        // Start with the root cell that fully contains the shape:\n        findMatches(hits, log,\n                    new Cell(null,\n                             bbox.minLon, bbox.minLat,\n                             bbox.maxLon, bbox.maxLat,\n                             0),\n                    centerLon, centerLat, radiusMeters,\n                    docLons, docLats);\n      }\n\n      if (VERBOSE) {\n        log.println(\"  \" + hits.size() + \" hits\");\n      }\n\n      int failCount = 0;\n\n      // Done matching, now verify:\n      for(int docID=0;docID<numDocs;docID++) {\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, docLats[docID], docLons[docID]);\n        final Boolean expected;\n        final double percentError = Math.abs(distanceMeters - radiusMeters) / distanceMeters;\n        if (percentError <= DISTANCE_PCT_ERR) {\n          expected = null;\n        } else {\n          expected = distanceMeters <= radiusMeters;\n        }\n\n        boolean actual = hits.contains(docID);\n        if (expected != null && actual != expected) {\n          if (actual) {\n            log.println(\"doc=\" + docID + \" matched but should not with distance error \" + percentError + \" on iteration \" + iter);\n          } else {\n            log.println(\"doc=\" + docID + \" did not match but should with distance error \" + percentError + \" on iteration \" + iter);\n          }\n          log.println(\"  lon=\" + docLons[docID] + \" lat=\" + docLats[docID] + \" distanceMeters=\" + distanceMeters + \" vs radiusMeters=\" + radiusMeters);\n          failCount++;\n        }\n      }\n\n      if (failCount != 0) {\n        System.out.print(sw.toString());\n        fail(failCount + \" incorrect hits (see above)\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["5a207d19eac354d649c3f0e2cce070017c78125e"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"5a207d19eac354d649c3f0e2cce070017c78125e":["937923083e4d137932336fc80f3d78758ff698a6","62cc423073d23f01208c6cf85844dedd80011121"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","62cc423073d23f01208c6cf85844dedd80011121"],"62cc423073d23f01208c6cf85844dedd80011121":["937923083e4d137932336fc80f3d78758ff698a6"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"937923083e4d137932336fc80f3d78758ff698a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"]},"commit2Childs":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"],"5a207d19eac354d649c3f0e2cce070017c78125e":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","937923083e4d137932336fc80f3d78758ff698a6"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"62cc423073d23f01208c6cf85844dedd80011121":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"937923083e4d137932336fc80f3d78758ff698a6":["5a207d19eac354d649c3f0e2cce070017c78125e","62cc423073d23f01208c6cf85844dedd80011121"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}