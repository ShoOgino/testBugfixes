{"path":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","commits":[{"id":"02a71af6b0525092e8cdc9e3649fa77150cc7814","date":1115339520,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnetlc/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"235efcba838a273934c5dd0ef66bb07c7fb0d718","date":1201256475,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a","date":1221082732,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e6ba22024a1d0bb31aef11a445223f30d0a2c22","date":1221135063,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4256bc1b3c94786287ccdfc751230374521843cf","date":1254612273,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = (String) i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n        writer.setUseCompoundFile(true); // why?\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69d87d34a81230de56333f52f590caeb6d80667","date":1257848306,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, ana, true, IndexWriter.MaxFieldLength.LIMITED);\n          writer.setUseCompoundFile(true); // why?\n          Iterator i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = (String) i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c69d87d34a81230de56333f52f590caeb6d80667":["4256bc1b3c94786287ccdfc751230374521843cf"],"8e6ba22024a1d0bb31aef11a445223f30d0a2c22":["b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a"],"235efcba838a273934c5dd0ef66bb07c7fb0d718":["02a71af6b0525092e8cdc9e3649fa77150cc7814"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["8e6ba22024a1d0bb31aef11a445223f30d0a2c22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"02a71af6b0525092e8cdc9e3649fa77150cc7814":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a":["235efcba838a273934c5dd0ef66bb07c7fb0d718"],"4256bc1b3c94786287ccdfc751230374521843cf":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c69d87d34a81230de56333f52f590caeb6d80667"]},"commit2Childs":{"c69d87d34a81230de56333f52f590caeb6d80667":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8e6ba22024a1d0bb31aef11a445223f30d0a2c22":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"235efcba838a273934c5dd0ef66bb07c7fb0d718":["b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["4256bc1b3c94786287ccdfc751230374521843cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["02a71af6b0525092e8cdc9e3649fa77150cc7814"],"02a71af6b0525092e8cdc9e3649fa77150cc7814":["235efcba838a273934c5dd0ef66bb07c7fb0d718"],"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a":["8e6ba22024a1d0bb31aef11a445223f30d0a2c22"],"4256bc1b3c94786287ccdfc751230374521843cf":["c69d87d34a81230de56333f52f590caeb6d80667"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}