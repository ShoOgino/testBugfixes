{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","commits":[{"id":"c8376c8b9c659015b6e2a23a8c7275ea203eeef3","date":1428508284,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      fromWriter.forceMerge(1);\n      toWriter.forceMerge(1);\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","date":1449514606,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b51ee14e04858fe1f47f241ac29486de23b215b5","date":1456734355,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3","f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier \n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n     \n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      \n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n      \n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n        \n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n        \n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n          \n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6448f67be45147de82a85cd903fec34e8930da75","date":1477041277,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e674dc2e016a8076b73f622fc19cd7bbde9f8a4a","date":1497865319,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        final int nextInt = random.nextInt(Integer.MAX_VALUE);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n      int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n      subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n      Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b","date":1518443389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > terms.docID()) {\n              terms.advance(doc);\n            }\n            final BytesRef joinValue;\n            if (doc == terms.docID()) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiTerms.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    final Random random = random();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random,\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomNumbers.randomIntBetween(random, 1, 4);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        // the trick is to generate values which will be ordered similarly for string, ints&longs, positive nums makes it easier\n        //\n        // Additionally in order to avoid precision loss when joining via a float field we can't generate values higher than\n        // 0xFFFFFF, so we can't use Integer#MAX_VALUE as upper bound here:\n        final int nextInt = random.nextInt(0xFFFFFF);\n        uniqueRandomValue = String.format(Locale.ROOT, \"%08x\", nextInt);\n        assert nextInt == Integer.parseUnsignedInt(uniqueRandomValue,16);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n\n      context.randomFrom[i] = random.nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n\n    }\n\n    List<String> randomUniqueValuesReplica = new ArrayList<>(Arrays.asList(context.randomUniqueValues));\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random.nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random, \"id\", id, Field.Store.YES));\n      document.add(newTextField(random, \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? Math.min(2 + random.nextInt(10), context.randomUniqueValues.length) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      final List<String> subValues;\n      {\n        int start = randomUniqueValuesReplica.size()==numberOfLinkValues? 0 : random.nextInt(randomUniqueValuesReplica.size()-numberOfLinkValues);\n        subValues = randomUniqueValuesReplica.subList(start, start+numberOfLinkValues);\n        Collections.shuffle(subValues, random);\n      }\n      for (String linkValue : subValues) {\n\n        assert !docs[i].linkValues.contains(linkValue);\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"from\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          addLinkFields(random, document,  \"to\", linkValue, multipleValuesPerDocument, globalOrdinalJoin);\n        }\n      }\n\n      w.addDocument(document);\n      if (random.nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random.nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now force merge\");\n      }\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (doc > docTermOrds.docID()) {\n              docTermOrds.advance(doc);\n            }\n            if (doc == docTermOrds.docID()) {\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorable scorer;\n          private BinaryDocValues terms;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        Terms terms = MultiFields.getTerms(topLevelReader, toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>();\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            TermsEnum termsEnum = terms.iterator();\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue;\n            if (terms.advanceExact(doc)) {\n              joinValue = terms.binaryValue();\n            } else {\n              // missing;\n              joinValue = new BytesRef(BytesRef.EMPTY_BYTES);\n            }\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorable scorer) {\n          }\n\n          @Override\n          public org.apache.lucene.search.ScoreMode scoreMode() {\n            return org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = OrdinalMap.build(\n          null, values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"af2638813028b254a88b418ebeafb541afb49653":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","b51ee14e04858fe1f47f241ac29486de23b215b5"],"e674dc2e016a8076b73f622fc19cd7bbde9f8a4a":["d211216c83f01894810543d1c107160a9ae3650b"],"957c610636f393a85a38f1af670540028db13e6b":["28288370235ed02234a64753cdbf0c6ec096304a"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["e674dc2e016a8076b73f622fc19cd7bbde9f8a4a"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["417142ff08fda9cf0b72d5133e63097a166c6458","81f64a6570bc5d216c5d575c3b29ecb106fa0e6b"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["af2638813028b254a88b418ebeafb541afb49653"],"d211216c83f01894810543d1c107160a9ae3650b":["6448f67be45147de82a85cd903fec34e8930da75"],"6448f67be45147de82a85cd903fec34e8930da75":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["0e7bc21595222ae4f75509300fbb7726691f387f","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["957c610636f393a85a38f1af670540028db13e6b"],"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b":["417142ff08fda9cf0b72d5133e63097a166c6458"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["d211216c83f01894810543d1c107160a9ae3650b","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"417142ff08fda9cf0b72d5133e63097a166c6458":["957c610636f393a85a38f1af670540028db13e6b","9fc47cb7b4346802411bb432f501ed0673d7119e"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","957c610636f393a85a38f1af670540028db13e6b"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["0e7bc21595222ae4f75509300fbb7726691f387f"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6448f67be45147de82a85cd903fec34e8930da75"],"0e7bc21595222ae4f75509300fbb7726691f387f":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["d211216c83f01894810543d1c107160a9ae3650b","e674dc2e016a8076b73f622fc19cd7bbde9f8a4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"af2638813028b254a88b418ebeafb541afb49653":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"e674dc2e016a8076b73f622fc19cd7bbde9f8a4a":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"957c610636f393a85a38f1af670540028db13e6b":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["af2638813028b254a88b418ebeafb541afb49653","b51ee14e04858fe1f47f241ac29486de23b215b5"],"d211216c83f01894810543d1c107160a9ae3650b":["e674dc2e016a8076b73f622fc19cd7bbde9f8a4a","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"6448f67be45147de82a85cd903fec34e8930da75":["d211216c83f01894810543d1c107160a9ae3650b","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["6448f67be45147de82a85cd903fec34e8930da75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"81f64a6570bc5d216c5d575c3b29ecb106fa0e6b":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"28288370235ed02234a64753cdbf0c6ec096304a":["957c610636f393a85a38f1af670540028db13e6b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"417142ff08fda9cf0b72d5133e63097a166c6458":["bfcdec9fcf0409223f35c5ec3bc14094314941b4","81f64a6570bc5d216c5d575c3b29ecb106fa0e6b"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["af2638813028b254a88b418ebeafb541afb49653"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"285244982ce6aa163d1e60a707f0e6e121736ce5":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"0e7bc21595222ae4f75509300fbb7726691f387f":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}