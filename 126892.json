{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiThreadedSessionsCache().mjava","commits":[{"id":"e17627eb9673daf01d17fdfb583c621c55c34208","date":1593028963,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiThreadedSessionsCache().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Verify number of sessions allocated when parallel session requests arrive is reasonable.\n   * Test takes about 3 seconds to run.\n   */\n  @Test\n  @Slow\n  public void testMultiThreadedSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    final Set<PolicyHelper.SessionWrapper> seenSessions = Sets.newHashSet();\n    final AtomicInteger completedThreads = new AtomicInteger(0);\n\n    final int COUNT_THREADS = 100;\n    Thread[] threads = new Thread[COUNT_THREADS];\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          // This thread requests a session, computes using it for 50ms then returns is, executes for 1000ms more,\n          // releases the sessions and finishes.\n          PolicyHelper.SessionWrapper session = PolicyHelper.getSession(solrCloudManager);\n          seenSessions.add(session);\n          Thread.sleep(50);\n          session.returnSession(session.get());\n          Thread.sleep(1000);\n          session.release();\n\n          completedThreads.incrementAndGet();\n        } catch (InterruptedException | IOException ignored) {\n        }\n      });\n      threads[i].start();\n    }\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i].join(12000);\n    }\n\n    assertEquals(COUNT_THREADS, completedThreads.get());\n    // The value asserted below is somewhat arbitrary. Running locally max seen is 10, so hopefully 30 is safe.\n    // Idea is to verify we do not allocate a high number of sessions even if many concurrent session\n    // requests arrive at the same time. The session computing time is short in purpose. If it were long, it would be\n    // expected for more sessions to be allocated.\n    assertTrue(\"Too many sessions created: \" + seenSessions.size(), seenSessions.size() < 30);\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4ce1bb652d1afbfea536fe363eff1bf2ed43c300"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ce1bb652d1afbfea536fe363eff1bf2ed43c300","date":1594134802,"type":3,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiThreadedSessionsCache().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiThreadedSessionsCache().mjava","sourceNew":"  /**\n   * Verify number of sessions allocated when parallel session requests arrive is reasonable.\n   * Test takes about 3 seconds to run.\n   */\n  @Test\n  @Slow\n  public void testMultiThreadedSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    final Set<PolicyHelper.SessionWrapper> seenSessions = Sets.newHashSet();\n    final AtomicInteger completedThreads = new AtomicInteger(0);\n\n    final int COUNT_THREADS = 100;\n    Thread[] threads = new Thread[COUNT_THREADS];\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          // This thread requests a session, computes using it for 25ms then returns is, executes for 1000ms more,\n          // releases the sessions and finishes.\n          PolicyHelper.SessionWrapper session = PolicyHelper.getSession(solrCloudManager);\n          synchronized (seenSessions) {\n            seenSessions.add(session);\n          }\n          Thread.sleep(25);\n          session.returnSession(session.get());\n          Thread.sleep(1000);\n          session.release();\n\n          completedThreads.incrementAndGet();\n        } catch (InterruptedException | IOException ignored) {\n        }\n      });\n      threads[i].start();\n    }\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i].join(12000);\n    }\n\n    assertEquals(COUNT_THREADS, completedThreads.get());\n    // The value asserted below is somewhat arbitrary. Running locally usually uses up to 5 sessions, so hopefully 30 is\n    // safe. Idea is to verify we do not allocate a high number of sessions even if many concurrent session\n    // requests arrive at the same time. The session computing time is short in purpose. If it were long, it would be\n    // expected for more sessions to be needed.\n    // Note we joined with all the threads having updated seenSessions so no need to synchronize (\"All actions in a thread\n    // happen before any other thread successfully returns from a join() on that thread\" - JSR-133)\n    assertTrue(\"Too many (>=30) sessions created: \" + seenSessions.size(), seenSessions.size() < 30);\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","sourceOld":"  /**\n   * Verify number of sessions allocated when parallel session requests arrive is reasonable.\n   * Test takes about 3 seconds to run.\n   */\n  @Test\n  @Slow\n  public void testMultiThreadedSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    final Set<PolicyHelper.SessionWrapper> seenSessions = Sets.newHashSet();\n    final AtomicInteger completedThreads = new AtomicInteger(0);\n\n    final int COUNT_THREADS = 100;\n    Thread[] threads = new Thread[COUNT_THREADS];\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          // This thread requests a session, computes using it for 50ms then returns is, executes for 1000ms more,\n          // releases the sessions and finishes.\n          PolicyHelper.SessionWrapper session = PolicyHelper.getSession(solrCloudManager);\n          seenSessions.add(session);\n          Thread.sleep(50);\n          session.returnSession(session.get());\n          Thread.sleep(1000);\n          session.release();\n\n          completedThreads.incrementAndGet();\n        } catch (InterruptedException | IOException ignored) {\n        }\n      });\n      threads[i].start();\n    }\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i].join(12000);\n    }\n\n    assertEquals(COUNT_THREADS, completedThreads.get());\n    // The value asserted below is somewhat arbitrary. Running locally max seen is 10, so hopefully 30 is safe.\n    // Idea is to verify we do not allocate a high number of sessions even if many concurrent session\n    // requests arrive at the same time. The session computing time is short in purpose. If it were long, it would be\n    // expected for more sessions to be allocated.\n    assertTrue(\"Too many sessions created: \" + seenSessions.size(), seenSessions.size() < 30);\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","bugFix":["e17627eb9673daf01d17fdfb583c621c55c34208"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiThreadedSessionsCache().mjava","sourceNew":null,"sourceOld":"  /**\n   * Verify number of sessions allocated when parallel session requests arrive is reasonable.\n   * Test takes about 3 seconds to run.\n   */\n  @Test\n  @Slow\n  public void testMultiThreadedSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    final Set<PolicyHelper.SessionWrapper> seenSessions = Sets.newHashSet();\n    final AtomicInteger completedThreads = new AtomicInteger(0);\n\n    final int COUNT_THREADS = 100;\n    Thread[] threads = new Thread[COUNT_THREADS];\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          // This thread requests a session, computes using it for 25ms then returns is, executes for 1000ms more,\n          // releases the sessions and finishes.\n          PolicyHelper.SessionWrapper session = PolicyHelper.getSession(solrCloudManager);\n          synchronized (seenSessions) {\n            seenSessions.add(session);\n          }\n          Thread.sleep(25);\n          session.returnSession(session.get());\n          Thread.sleep(1000);\n          session.release();\n\n          completedThreads.incrementAndGet();\n        } catch (InterruptedException | IOException ignored) {\n        }\n      });\n      threads[i].start();\n    }\n\n    for (int i = 0; i < COUNT_THREADS; i++) {\n      threads[i].join(12000);\n    }\n\n    assertEquals(COUNT_THREADS, completedThreads.get());\n    // The value asserted below is somewhat arbitrary. Running locally usually uses up to 5 sessions, so hopefully 30 is\n    // safe. Idea is to verify we do not allocate a high number of sessions even if many concurrent session\n    // requests arrive at the same time. The session computing time is short in purpose. If it were long, it would be\n    // expected for more sessions to be needed.\n    // Note we joined with all the threads having updated seenSessions so no need to synchronize (\"All actions in a thread\n    // happen before any other thread successfully returns from a join() on that thread\" - JSR-133)\n    assertTrue(\"Too many (>=30) sessions created: \" + seenSessions.size(), seenSessions.size() < 30);\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e17627eb9673daf01d17fdfb583c621c55c34208":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["4ce1bb652d1afbfea536fe363eff1bf2ed43c300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ce1bb652d1afbfea536fe363eff1bf2ed43c300":["e17627eb9673daf01d17fdfb583c621c55c34208"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"e17627eb9673daf01d17fdfb583c621c55c34208":["4ce1bb652d1afbfea536fe363eff1bf2ed43c300"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e17627eb9673daf01d17fdfb583c621c55c34208"],"4ce1bb652d1afbfea536fe363eff1bf2ed43c300":["3f504512a03d978990cbff30db0522b354e846db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}