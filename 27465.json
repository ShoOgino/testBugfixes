{"path":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":null,"sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98a8a68e6714cb8742c790308b9f5180d63417d4","date":1272554039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(facetExecutor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n        counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640642adafc49be01395b16e49b46df4e59389fc","date":1275590800,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(facetExecutor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"755f2f419306d7297c8feee10d1897addf4b2dd0","date":1294442354,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String).mjava","sourceNew":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  public NamedList<Integer> getTermCounts(String field) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<Integer>();\n    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);\n\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    String method = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    boolean enumMethod = FacetParams.FACET_METHOD_enum.equals(method);\n\n    // TODO: default to per-segment or not?\n    boolean per_segment = FacetParams.FACET_METHOD_fcs.equals(method);\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      enumMethod = true;\n    }\n    boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    if (TrieField.getMainValuePrefix(ft) != null) {\n      // A TrieField with multiple parts indexed per value... currently only\n      // UnInvertedField can handle this case, so force it's use.\n      enumMethod = false;\n      multiToken = true;\n    }\n\n    // unless the enum method is explicitly specified, use a counting method.\n    if (enumMethod) {\n      counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount,missing,sort,prefix);\n    } else {\n      if (multiToken) {\n        UnInvertedField uif = UnInvertedField.getUnInvertedField(field, searcher);\n        counts = uif.getCounts(searcher, base, offset, limit, mincount,missing,sort,prefix);\n      } else {\n        // TODO: future logic could use filters instead of the fieldcache if\n        // the number of terms in the field is small enough.\n\n        if (per_segment) {\n          PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix);\n          Executor executor = threads==0 ? directExecutor : facetExecutor;\n          ps.setNumThreads(threads);\n          counts = ps.getFacetCounts(executor);\n        } else {\n          counts = getFieldCacheCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix);         \n        }\n\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["755f2f419306d7297c8feee10d1897addf4b2dd0","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"640642adafc49be01395b16e49b46df4e59389fc":["98a8a68e6714cb8742c790308b9f5180d63417d4"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["755f2f419306d7297c8feee10d1897addf4b2dd0"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["640642adafc49be01395b16e49b46df4e59389fc"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["640642adafc49be01395b16e49b46df4e59389fc","755f2f419306d7297c8feee10d1897addf4b2dd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98a8a68e6714cb8742c790308b9f5180d63417d4":["1da8d55113b689b06716246649de6f62430f15c0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["755f2f419306d7297c8feee10d1897addf4b2dd0"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["640642adafc49be01395b16e49b46df4e59389fc","755f2f419306d7297c8feee10d1897addf4b2dd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"640642adafc49be01395b16e49b46df4e59389fc":["755f2f419306d7297c8feee10d1897addf4b2dd0","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"1da8d55113b689b06716246649de6f62430f15c0":["98a8a68e6714cb8742c790308b9f5180d63417d4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","868da859b43505d9d2a023bfeae6dd0c795f5295"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"98a8a68e6714cb8742c790308b9f5180d63417d4":["640642adafc49be01395b16e49b46df4e59389fc"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}