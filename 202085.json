{"path":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"/dev/null","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      QueryParsing.StrParser parser = new QueryParsing.StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b603d25269568087504c2caeb6f72834699ffdbd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"/dev/null","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      QueryParsing.StrParser parser = new QueryParsing.StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"051c3069a96e986b8fa0435398a73a922ce85418","date":1447853599,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      QueryParsing.StrParser parser = new QueryParsing.StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["b603d25269568087504c2caeb6f72834699ffdbd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e54328e840e7c382f0493f8aea3eea51d03b8225","date":1471858567,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c82557b0a8c9d4012f208e5de912ae7500ea351","date":1471888093,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16bac49f6115a1b41829c30623e001005ebb7ad7","date":1475239647,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    int end = 0;\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          sb.append(expandedReplacement);\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b603d25269568087504c2caeb6f72834699ffdbd","date":1600804019,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/macro/MacroExpander#_expand(String).mjava","sourceNew":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    StringBuilder sb = null;\n    for (;;) {\n      assert idx >= start;\n      idx = val.indexOf(macroStart, idx);\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        break;\n      }\n\n      // found unescaped \"${\"\n      final int matchedStart = idx;\n\n      int rbrace = val.indexOf('}', matchedStart + macroStart.length());\n      if (rbrace == -1) {\n        // no matching close brace...\n        if (failOnMissingParams) {\n          return null;\n        }\n        break;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val, start, matchedStart);\n      }\n\n      // update \"start\" to be at the end of ${...}\n      idx = start = rbrace + 1;\n\n      // String in-between braces\n      StrParser parser = new StrParser(val, matchedStart + macroStart.length(), rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        if (failOnMissingParams) {\n          return null;\n        }\n        // append the part we would have skipped\n        sb.append(val, matchedStart, start);\n      }\n    } // loop idx\n\n    if (sb == null) {\n      return val;\n    }\n    sb.append(val, start, val.length());\n    return sb.toString();\n  }\n\n","sourceOld":"  private String _expand(String val) {\n    // quickest short circuit\n    int idx = val.indexOf(macroStart.charAt(0));\n    if (idx < 0) return val;\n\n    int start = 0;  // start of the unprocessed part of the string\n    StringBuilder sb = null;\n    for (;;) {\n      idx = val.indexOf(macroStart, idx);\n      int matchedStart = idx;\n\n      // check if escaped\n      if (idx > 0) {\n        // check if escaped...\n        // TODO: what if you *want* to actually have a backslash... perhaps that's when we allow changing\n        // of the escape character?\n\n        char ch = val.charAt(idx-1);\n        if (ch == escape) {\n          idx += macroStart.length();\n          continue;\n        }\n      }\n      else if (idx < 0) {\n        if (sb == null) return val;\n        sb.append(val.substring(start));\n        return sb.toString();\n      }\n\n      // found unescaped \"${\"\n      idx += macroStart.length();\n\n      int rbrace = val.indexOf('}', idx);\n      if (rbrace == -1) {\n        // no matching close brace...\n        continue;\n      }\n\n      if (sb == null) {\n        sb = new StringBuilder(val.length()*2);\n      }\n\n      if (matchedStart > 0) {\n        sb.append(val.substring(start, matchedStart));\n      }\n\n      // update \"start\" to be at the end of ${...}\n      start = rbrace + 1;\n\n      // String inbetween = val.substring(idx, rbrace);\n      StrParser parser = new StrParser(val, idx, rbrace);\n      try {\n        String paramName = parser.getId();\n        String defVal = null;\n        boolean hasDefault = parser.opt(':');\n        if (hasDefault) {\n          defVal = val.substring(parser.pos, rbrace);\n        }\n\n        // in the event that expansions become context dependent... consult original?\n        String[] replacementList = orig.get(paramName);\n\n        // TODO - handle a list somehow...\n        String replacement = replacementList!=null ? replacementList[0] : defVal;\n        if (replacement != null) {\n          String expandedReplacement = expand(replacement);\n          if (failOnMissingParams && expandedReplacement == null) {\n            return null;\n          }\n          sb.append(expandedReplacement);\n        }\n        else if (failOnMissingParams) {\n          return null;\n        }\n\n      } catch (SyntaxError syntaxError) {\n        // append the part we would have skipped\n        sb.append( val.substring(matchedStart, start) );\n        continue;\n      }\n\n    }\n\n  }\n\n","bugFix":["051c3069a96e986b8fa0435398a73a922ce85418","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"16bac49f6115a1b41829c30623e001005ebb7ad7":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["051c3069a96e986b8fa0435398a73a922ce85418","e54328e840e7c382f0493f8aea3eea51d03b8225"],"b603d25269568087504c2caeb6f72834699ffdbd":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","16bac49f6115a1b41829c30623e001005ebb7ad7"],"051c3069a96e986b8fa0435398a73a922ce85418":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["051c3069a96e986b8fa0435398a73a922ce85418","0c82557b0a8c9d4012f208e5de912ae7500ea351"],"e54328e840e7c382f0493f8aea3eea51d03b8225":["051c3069a96e986b8fa0435398a73a922ce85418"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["051c3069a96e986b8fa0435398a73a922ce85418","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b603d25269568087504c2caeb6f72834699ffdbd"]},"commit2Childs":{"16bac49f6115a1b41829c30623e001005ebb7ad7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"b603d25269568087504c2caeb6f72834699ffdbd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["b603d25269568087504c2caeb6f72834699ffdbd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"051c3069a96e986b8fa0435398a73a922ce85418":["0c82557b0a8c9d4012f208e5de912ae7500ea351","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","e54328e840e7c382f0493f8aea3eea51d03b8225","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","051c3069a96e986b8fa0435398a73a922ce85418"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["16bac49f6115a1b41829c30623e001005ebb7ad7","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e54328e840e7c382f0493f8aea3eea51d03b8225":["0c82557b0a8c9d4012f208e5de912ae7500ea351"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}