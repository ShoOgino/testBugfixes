{"path":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","commits":[{"id":"ff6fd241dc6610f7f81b62e3ba4cedf105939623","date":1307331653,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexSearcher searcher = new IndexSearcher(dir, false);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      searcher = new IndexSearcher(dir, false);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n    }\n\n    writer.close();\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79c2cb24929f2649a8875fb629086171f914d5ce","date":1307332717,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexSearcher searcher = new IndexSearcher(dir, false);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      searcher = new IndexSearcher(dir, false);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n    }\n\n    writer.close();\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexSearcher searcher = new IndexSearcher(dir, false);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      searcher = new IndexSearcher(dir, false);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n    }\n\n    writer.close();\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3a0403b45dfe384fae4a1b6e96c3265d000c498","date":1321445981,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir, false);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir, false);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexSearcher searcher = new IndexSearcher(dir, false);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      searcher = new IndexSearcher(dir, false);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n    }\n\n    writer.close();\n    searcher = new IndexSearcher(dir, false);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c5b026d03cbbb03ca4c0b97d14e9839682281dc","date":1323049298,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir, false);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir, false);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir, false);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir, false);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir, false);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir, false);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir, false);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    searcher.close();\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      searcher.close();\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    searcher.close();\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterCommit#testCommitOnCloseAbort().mjava","sourceNew":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    r.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  /*\n   * Simple test for \"commit on close\": open writer, then\n   * add a bunch of docs, making sure reader does not see\n   * them until writer has closed.  Then instead of\n   * closing the writer, call abort and verify reader sees\n   * nothing was added.  Then verify we can open the index\n   * and add docs to it.\n   */\n  public void testCommitOnCloseAbort() throws IOException {\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(10));\n    for (int i = 0; i < 14; i++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    writer.close();\n\n    Term searchTerm = new Term(\"content\", \"aaa\");\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    ScoreDoc[] hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"first number of hits\", 14, hits.length);\n    reader.close();\n\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n    for(int j=0;j<17;j++) {\n      TestIndexWriter.addDoc(writer);\n    }\n    // Delete all docs:\n    writer.deleteDocuments(searchTerm);\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n    reader.close();\n\n    // Now, close the writer:\n    writer.rollback();\n\n    TestIndexWriter.assertNoUnreferencedFiles(dir, \"unreferenced files remain after rollback()\");\n\n    reader = IndexReader.open(dir);\n    searcher = new IndexSearcher(reader);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"saw changes after writer.abort\", 14, hits.length);\n    reader.close();\n\n    // Now make sure we can re-open the index, add docs,\n    // and all is good:\n    writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random))\n      .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));\n\n    // On abort, writer in fact may write to the same\n    // segments_N file:\n    dir.setPreventDoubleWrite(false);\n\n    for(int i=0;i<12;i++) {\n      for(int j=0;j<17;j++) {\n        TestIndexWriter.addDoc(writer);\n      }\n      IndexReader r = IndexReader.open(dir);\n      searcher = new IndexSearcher(r);\n      hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n      assertEquals(\"reader incorrectly sees changes from writer\", 14, hits.length);\n      r.close();\n    }\n\n    writer.close();\n    IndexReader r = IndexReader.open(dir);\n    searcher = new IndexSearcher(r);\n    hits = searcher.search(new TermQuery(searchTerm), null, 1000).scoreDocs;\n    assertEquals(\"didn't see changes after close\", 218, hits.length);\n    r.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"79c2cb24929f2649a8875fb629086171f914d5ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","1c5b026d03cbbb03ca4c0b97d14e9839682281dc"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["79c2cb24929f2649a8875fb629086171f914d5ce","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"79c2cb24929f2649a8875fb629086171f914d5ce":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff6fd241dc6610f7f81b62e3ba4cedf105939623","79c2cb24929f2649a8875fb629086171f914d5ce","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["0e7c2454a6a8237bfd0e953f5b940838408c9055","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60","1c5b026d03cbbb03ca4c0b97d14e9839682281dc"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["79c2cb24929f2649a8875fb629086171f914d5ce","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}