{"path":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","commits":[{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp < 0 || (cmp == 0 && doc + docBase > bottom.doc)) {\n              // Definitely not competitive.\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp < 0 || (cmp == 0 && doc + docBase > bottom.doc)) {\n              // Definitely not competitive.\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ef4d3aeb733ae886f562af3b735f50503926a12","date":1438854939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0","date":1488289604,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":["e4184751347df4dfb7bc0e2d4dc1b412857f301d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4184751347df4dfb7bc0e2d4dc1b412857f301d","date":1512652126,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":["404d1ab7f6f396235047017c88d545fec15dafb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            // Compute score only if it is competitive.\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d71c47cb42702580f18a54321282c0238c2d2a","date":1532960436,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          float score = Float.NaN;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc, score);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc, score));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate && totalHits >= totalHitsThreshold) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            final int cmp = reverseMul * comparator.compareBottom(doc);\n            if (cmp <= 0) {\n              // not competitive since documents are visited in doc id order\n              if (canEarlyTerminate && totalHits >= totalHitsThreshold) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5003664d14ef48a0557ce1d8a684b15d62efe912","date":1539883534,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"741f39e242cff4c0c77a2beea34fb865a3fd2372","date":1542392009,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5374ec368ef9441d694af8df95b2ffbae3d7f03b","date":1548748689,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits > totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits > totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32dc2e73f68d239029f9fe76729eda505b75bb6e","date":1569593453,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO || shouldUpdateMinScore()) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f00d3f1ad3bbb957062c4871ec23f49edda800c6","date":1569925943,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer, true);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO || shouldUpdateMinScore()) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74844ead01492c17079ed382d0924f4df2fa72e3","date":1569970726,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer, true);\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer, true);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db0ef4e326916fc107ab6e066754d3ecba5197b","date":1570005243,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if we just\n                // reached totalHitsThreshold\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer);\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer, true);\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c10c01b195758b50e02599868e4093eb712f57","date":1570008306,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if we just\n                // reached totalHitsThreshold\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer);\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we can start setting the min competitive score if we just\n              // reached totalHitsThreshold\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e0066943a75c6f4af395bcd7728a812943cbb63","date":1570723011,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5ef5e55dd4bfc1d77144e2189634aaee22a824a","date":1571657799,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.GREATER_THAN_OR_EQUAL_TO) {\n                  updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9bcfed304f4a24121ffcf592ea90abdda674363","date":1582808749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n\n      return new TopFieldLeafCollector(queue, sort, context) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          countHit(doc);\n          if (queueFull) {\n            if (thresholdCheck(doc)) {\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            collectCompetitiveHit(doc);\n          } else {\n            collectedHits++;\n            collectAnyHit(doc, collectedHits);\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul()) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          //System.out.println(\"  collect doc=\" + doc);\n\n          totalHits++;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            // Fastmatch: return if this hit is no better than\n            // the worst hit currently in the queue:\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n\n            updateBottom(doc);\n\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            collectedHits++;\n\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = collectedHits - 1;\n            //System.out.println(\"    slot=\" + slot);\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n\n            bottom = pq.add(new Entry(slot, docBase + doc));\n            queueFull = collectedHits == numHits;\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e18fac0122568cb02eb2c92608ca703a723bbbd6","date":1592942698,"type":3,"author":"Mayya Sharipova","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n\n      return new TopFieldLeafCollector(queue, sort, context) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          countHit(doc);\n          if (queueFull) {\n            if (thresholdCheck(doc)) {\n              return;\n            }\n          }\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // check if totalHitsThreshold is reached and we can update competitive score\n              // necessary to account for possible update to global min competitive score\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n          if (queueFull) {\n            collectCompetitiveHit(doc);\n          } else {\n            collectedHits++;\n            collectAnyHit(doc, collectedHits);\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n      final int afterDoc = after.doc - docBase;\n\n      return new TopFieldLeafCollector(queue, sort, context) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          countHit(doc);\n          if (queueFull) {\n            if (thresholdCheck(doc)) {\n              return;\n            }\n          }\n\n          final int topCmp = reverseMul * comparator.compareTop(doc);\n          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {\n            // Already collected on a previous page\n            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n              // we just reached totalHitsThreshold, we can start setting the min\n              // competitive score now\n              updateMinCompetitiveScore(scorer);\n            }\n            return;\n          }\n\n          if (queueFull) {\n            collectCompetitiveHit(doc);\n          } else {\n            collectedHits++;\n            collectAnyHit(doc, collectedHits);\n          }\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["e19eef45a852c3316ae52fdf941731448ece967a"],"e4184751347df4dfb7bc0e2d4dc1b412857f301d":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0","404d1ab7f6f396235047017c88d545fec15dafb7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["417142ff08fda9cf0b72d5133e63097a166c6458","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0":["0ef4d3aeb733ae886f562af3b735f50503926a12"],"0ef4d3aeb733ae886f562af3b735f50503926a12":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"741f39e242cff4c0c77a2beea34fb865a3fd2372":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"f0c10c01b195758b50e02599868e4093eb712f57":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["741f39e242cff4c0c77a2beea34fb865a3fd2372"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["32dc2e73f68d239029f9fe76729eda505b75bb6e"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"807314aa41c10866aec273a0e54fd0d24d8971de":["f0c10c01b195758b50e02599868e4093eb712f57"],"404d1ab7f6f396235047017c88d545fec15dafb7":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0"],"b9bcfed304f4a24121ffcf592ea90abdda674363":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"901e951cec2e6af4e503209a6721c8834db23279":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"b5ef5e55dd4bfc1d77144e2189634aaee22a824a":["6e0066943a75c6f4af395bcd7728a812943cbb63"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"417142ff08fda9cf0b72d5133e63097a166c6458":["1aad05eeff7818b0833c02ac6b743aa72054963b","e4184751347df4dfb7bc0e2d4dc1b412857f301d"],"6e0066943a75c6f4af395bcd7728a812943cbb63":["807314aa41c10866aec273a0e54fd0d24d8971de"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","b5ef5e55dd4bfc1d77144e2189634aaee22a824a"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["74844ead01492c17079ed382d0924f4df2fa72e3"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["901e951cec2e6af4e503209a6721c8834db23279"],"74844ead01492c17079ed382d0924f4df2fa72e3":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"e18fac0122568cb02eb2c92608ca703a723bbbd6":["b9bcfed304f4a24121ffcf592ea90abdda674363"],"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e18fac0122568cb02eb2c92608ca703a723bbbd6"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["32dc2e73f68d239029f9fe76729eda505b75bb6e","3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"32dc2e73f68d239029f9fe76729eda505b75bb6e":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"e4184751347df4dfb7bc0e2d4dc1b412857f301d":["417142ff08fda9cf0b72d5133e63097a166c6458"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["741f39e242cff4c0c77a2beea34fb865a3fd2372"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["e4184751347df4dfb7bc0e2d4dc1b412857f301d","417142ff08fda9cf0b72d5133e63097a166c6458"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7"],"0ef4d3aeb733ae886f562af3b735f50503926a12":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["901e951cec2e6af4e503209a6721c8834db23279"],"741f39e242cff4c0c77a2beea34fb865a3fd2372":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"f0c10c01b195758b50e02599868e4093eb712f57":["807314aa41c10866aec273a0e54fd0d24d8971de"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["e19eef45a852c3316ae52fdf941731448ece967a"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"807314aa41c10866aec273a0e54fd0d24d8971de":["6e0066943a75c6f4af395bcd7728a812943cbb63"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"b9bcfed304f4a24121ffcf592ea90abdda674363":["e18fac0122568cb02eb2c92608ca703a723bbbd6"],"901e951cec2e6af4e503209a6721c8834db23279":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["74844ead01492c17079ed382d0924f4df2fa72e3"],"b5ef5e55dd4bfc1d77144e2189634aaee22a824a":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"6e0066943a75c6f4af395bcd7728a812943cbb63":["b5ef5e55dd4bfc1d77144e2189634aaee22a824a"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f0c10c01b195758b50e02599868e4093eb712f57"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["b9bcfed304f4a24121ffcf592ea90abdda674363"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["0ef4d3aeb733ae886f562af3b735f50503926a12"],"74844ead01492c17079ed382d0924f4df2fa72e3":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1d3f7ab1a502671bbdb03bcced21e764d2483221"],"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"e18fac0122568cb02eb2c92608ca703a723bbbd6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}