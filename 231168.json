{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","commits":[{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","pathOld":"/dev/null","sourceNew":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n    currentFrame.termState.isRealTerm = true;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","sourceNew":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","sourceOld":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n    currentFrame.termState.isRealTerm = true;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","sourceNew":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","sourceOld":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n    currentFrame.termState.isRealTerm = true;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","sourceNew":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","sourceOld":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n    currentFrame.termState.isRealTerm = true;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/IntersectTermsEnum#skipPastLastAutoPrefixTerm().mjava","sourceNew":null,"sourceOld":"  private boolean skipPastLastAutoPrefixTerm() throws IOException {\n    assert currentFrame.isAutoPrefixTerm;\n    useAutoPrefixTerm = false;\n\n    // If we last returned an auto-prefix term, we must now skip all\n    // actual terms sharing that prefix.  At most, that skipping\n    // requires popping one frame, but it can also require simply\n    // scanning ahead within the current frame.  This scanning will\n    // skip sub-blocks that contain many terms, which is why the\n    // optimization \"works\":\n    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;\n\n    boolean isSubBlock;\n\n    if (floorSuffixLeadEnd == -1) {\n      // An ordinary prefix, e.g. foo*\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n      if (suffix == 0) {\n\n        // Easy case: the prefix term's suffix is the empty string,\n        // meaning the prefix corresponds to all terms in the\n        // current block, so we just pop this entire block:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        return popPushNext();\n\n      } else {\n\n        // Just next() until we hit an entry that doesn't share this\n        // prefix.  The first next should be a sub-block sharing the\n        // same prefix, because if there are enough terms matching a\n        // given prefix to warrant an auto-prefix term, then there\n        // must also be enough to make a sub-block (assuming\n        // minItemsInPrefix > minItemsInBlock):\n        scanPrefix:\n        while (true) {\n          if (currentFrame.nextEnt == currentFrame.entCount) {\n            if (currentFrame.isLastInFloor == false) {\n              currentFrame.loadNextFloorBlock();\n            } else if (currentFrame.ord == 0) {\n              throw NoMoreTermsException.INSTANCE;\n            } else {\n              // Pop frame, which also means we've moved beyond this\n              // auto-prefix term:\n              currentFrame = stack[currentFrame.ord-1];\n              currentTransition = currentFrame.transition;\n\n              return popPushNext();\n            }\n          }\n          isSubBlock = currentFrame.next();\n          for(int i=0;i<suffix;i++) {\n            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n              break scanPrefix;\n            }\n          }\n        }\n      }\n    } else {\n      // Floor'd auto-prefix term; in this case we must skip all\n      // terms e.g. matching foo[a-m]*.  We are currently \"on\" fooa,\n      // which the automaton accepted (fooa* through foom*), and\n      // floorSuffixLeadEnd is m, so we must now scan to foon:\n      int prefix = currentFrame.prefix;\n      int suffix = currentFrame.suffix;\n\n      if (currentFrame.floorSuffixLeadStart == -1) {\n        suffix++;\n      }\n\n      if (suffix == 0) {\n\n        // This means current frame is fooa*, so we have to first\n        // pop the current frame, then scan in parent frame:\n        if (currentFrame.ord == 0) {\n          throw NoMoreTermsException.INSTANCE;\n        }\n        currentFrame = stack[currentFrame.ord-1];\n        currentTransition = currentFrame.transition;\n\n        // Current (parent) frame is now foo*, so now we just scan\n        // until the lead suffix byte is > floorSuffixLeadEnd\n        //assert currentFrame.prefix == prefix-1;\n        //prefix = currentFrame.prefix;\n\n        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on\n        // its first term = floor prefix term 41[7-9], popping to block 4*:\n        prefix = currentFrame.prefix;\n\n        suffix = term.length - currentFrame.prefix;\n      } else {\n        // No need to pop; just scan in currentFrame:\n      }\n\n      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd\n      scanFloor:\n      while (true) {\n        if (currentFrame.nextEnt == currentFrame.entCount) {\n          if (currentFrame.isLastInFloor == false) {\n            currentFrame.loadNextFloorBlock();\n          } else if (currentFrame.ord == 0) {\n            throw NoMoreTermsException.INSTANCE;\n          } else {\n            // Pop frame, which also means we've moved beyond this\n            // auto-prefix term:\n            currentFrame = stack[currentFrame.ord-1];\n            currentTransition = currentFrame.transition;\n\n            return popPushNext();\n          }\n        }\n        isSubBlock = currentFrame.next();\n        for(int i=0;i<suffix-1;i++) {\n          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {\n            break scanFloor;\n          }\n        }\n        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {\n          // Done scanning: we are now on the first term after all\n          // terms matched by this auto-prefix term\n          break;\n        }\n      }\n    }\n\n    return isSubBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["59db5e5f780185e0155d296a323e440a6ecfd3b6","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["59db5e5f780185e0155d296a323e440a6ecfd3b6","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd96a930cc08d72beee719cc11ce465b9d9861c3"]},"commit2Childs":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["dd96a930cc08d72beee719cc11ce465b9d9861c3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}