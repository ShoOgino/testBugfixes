{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","commits":[{"id":"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7","date":1290867534,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac","date":1290886721,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5947ccd7ba3770dcba5a0713dbd5496678256d9","date":1291744634,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n            segmentInfos.changed();\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","date":1291778725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n            segmentInfos.changed();\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n            segmentInfos.changed();\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        // It's possible another flush (that did not close\n        // the open do stores) snuck in after the flush we\n        // just did, so we remove any tail segments\n        // referencing the open doc store from the\n        // SegmentInfos we are about to sync (the main\n        // SegmentInfos will keep them):\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final String dss = docWriter.getDocStoreSegment();\n        if (dss != null) {\n          while(true) {\n            final String dss2 = toSync.info(toSync.size()-1).getDocStoreSegment();\n            if (dss2 == null || !dss2.equals(dss)) {\n              break;\n            }\n            toSync.remove(toSync.size()-1);\n            changeCount++;\n            segmentInfos.changed();\n          }\n        }\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cfd641edd796340315609425e9f70819e6d9ef0e","date":1295970051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        if (!keepFullyDeletedSegments) {\n          toSync.pruneDeletedSegments();\n        }\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        if (!keepFullyDeletedSegments) {\n          toSync.pruneDeletedSegments();\n        }\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","date":1297940445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        if (!keepFullyDeletedSegments) {\n          toSync.pruneDeletedSegments();\n        }\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n        \n        toSync = (SegmentInfos) segmentInfos.clone();\n        if (!keepFullyDeletedSegments) {\n          toSync.pruneDeletedSegments();\n        }\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit();\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n        \n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n        \n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n        \n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n        \n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n        \n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"850aca8525380ccb7df9626d7caa89678005dd31","date":1307569142,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean pendingCommitSet = false;\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitSet = true;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (!pendingCommitSet) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":["975460c64e0309e8a78d230321879ec18e65dc0a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean pendingCommitSet = false;\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitSet = true;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (!pendingCommitSet) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean pendingCommitSet = false;\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitSet = true;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (!pendingCommitSet) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (pendingCommit == null) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00afe74a80796ed1f30a9509b150ff104746a1f","date":1312881735,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(SegmentInfos,Map[String,String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#startCommit(Map[String,String]).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(final SegmentInfos toSync, final Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null) {\n        message(\"startCommit(): start\");\n      }\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n\n        if (pendingCommitChangeCount == lastCommitChangeCount) {\n          if (infoStream != null) {\n            message(\"  skip startCommit(): no changes pending\");\n          }\n          deleter.decRef(toSync);\n          return;\n        }\n\n        if (infoStream != null) {\n          message(\"startCommit index=\" + segString(toSync) + \" changeCount=\" + changeCount);\n        }\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null) {\n          toSync.setUserData(commitUserData);\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean pendingCommitSet = false;\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommitSet = true;\n          pendingCommit = toSync;\n        }\n\n        if (infoStream != null) {\n          message(\"done all syncs\");\n        }\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (!pendingCommitSet) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            // Hit exception\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n    assert pendingCommit == null;\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start\");\n\n      final SegmentInfos toSync;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n        myChangeCount = changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip startCommit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() all files\n        // referenced by toSync, in the background.\n\n        if (infoStream != null)\n          message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n\n        readerPool.commit(segmentInfos);\n        toSync = (SegmentInfos) segmentInfos.clone();\n\n        assert filesExist(toSync);\n\n        if (commitUserData != null)\n          toSync.setUserData(commitUserData);\n\n        // This protects the segmentInfos we are now going\n        // to commit.  This is important in case, eg, while\n        // we are trying to sync all referenced files, a\n        // merge completes which would otherwise have\n        // removed the files we are now syncing.\n        deleter.incRef(toSync, false);\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean pendingCommitSet = false;\n\n      try {\n        // This call can take a long time -- 10s of seconds\n        // or more.  We do it without sync:\n        directory.sync(toSync.files(directory, false));\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n\n          assert pendingCommit == null;\n\n          assert segmentInfos.getGeneration() == toSync.getGeneration();\n\n          // Exception here means nothing is prepared\n          // (this method unwinds everything it did on\n          // an exception)\n          toSync.prepareCommit(directory);\n\n          pendingCommit = toSync;\n          pendingCommitSet = true;\n          pendingCommitChangeCount = myChangeCount;\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n\n          // Have our master segmentInfos record the\n          // generations we just prepared.  We do this\n          // on error or success so we don't\n          // double-write a segments_N file.\n          segmentInfos.updateGeneration(toSync);\n\n          if (!pendingCommitSet) {\n            if (infoStream != null) {\n              message(\"hit exception committing segments file\");\n            }\n\n            deleter.decRef(toSync);\n          }\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":["47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"850aca8525380ccb7df9626d7caa89678005dd31":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c5947ccd7ba3770dcba5a0713dbd5496678256d9":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a3776dccca01c11e7046323cfad46a3b4a471233","850aca8525380ccb7df9626d7caa89678005dd31"],"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"cfd641edd796340315609425e9f70819e6d9ef0e":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["850aca8525380ccb7df9626d7caa89678005dd31"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["cfd641edd796340315609425e9f70819e6d9ef0e"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["3bb13258feba31ab676502787ab2e1779f129b7a"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","cfd641edd796340315609425e9f70819e6d9ef0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["135621f3a0670a9394eb563224a3b76cc4dddc0f","850aca8525380ccb7df9626d7caa89678005dd31"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["c5947ccd7ba3770dcba5a0713dbd5496678256d9"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3"],"3bb13258feba31ab676502787ab2e1779f129b7a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac":["8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7"]},"commit2Childs":{"850aca8525380ccb7df9626d7caa89678005dd31":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","c00afe74a80796ed1f30a9509b150ff104746a1f","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"c5947ccd7ba3770dcba5a0713dbd5496678256d9":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7":["d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"cfd641edd796340315609425e9f70819e6d9ef0e":["e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3","29ef99d61cda9641b6250bf9567329a6e65f901d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["850aca8525380ccb7df9626d7caa89678005dd31","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e69553ac9cbe3b2693b93c2fb0c211529b8ee4c3":["f1bdbf92da222965b46c0a942c3857ba56e5c638","b3e06be49006ecac364d39d12b9c9f74882f9b9f","a3776dccca01c11e7046323cfad46a3b4a471233","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ebf8c7f71c978cb9cdc8f49ff9f14751927f8a7","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3bb13258feba31ab676502787ab2e1779f129b7a"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["cfd641edd796340315609425e9f70819e6d9ef0e","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"3bb13258feba31ab676502787ab2e1779f129b7a":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac":["c5947ccd7ba3770dcba5a0713dbd5496678256d9","3bb13258feba31ab676502787ab2e1779f129b7a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}