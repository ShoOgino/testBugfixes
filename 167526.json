{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[#-extends-GeoPoint]).mjava","commits":[{"id":"06729f5a814f91b46fa06d668ae86a5d257ba644","date":1461675413,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[#-extends-GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint]).mjava","sourceNew":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<? extends GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","sourceOld":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":2,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[#-extends-GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint],double).mjava","sourceNew":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<? extends GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input, final double leniencyValue) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":2,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[#-extends-GeoPoint]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#filterPoints(List[GeoPoint],double).mjava","sourceNew":"  /** Filter duplicate points.\n   * @param input with input list of points\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<? extends GeoPoint> input) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    return noIdenticalPoints;\n  }\n\n","sourceOld":"  /** Filter duplicate points and coplanar points.\n   * @param input with input list of points\n   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons\n   * @return the filtered list, or null if we can't get a legit polygon from the input.\n   */\n  static List<GeoPoint> filterPoints(final List<GeoPoint> input, final double leniencyValue) {\n    \n    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());\n    \n    // Backtrack to find something different from the first point\n    int startIndex = -1;\n    final GeoPoint comparePoint = input.get(0);\n    for (int i = 0; i < input.size()-1; i++) {\n      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));\n      if (!thePoint.isNumericallyIdentical(comparePoint)) {\n        startIndex = getLegalIndex(-i, input.size());\n        break;\n      }\n    }\n    if (startIndex == -1) {\n      return null;\n    }\n    \n    // Now we can start the process of walking around, removing duplicate points.\n    int currentIndex = startIndex;\n    while (true) {\n      final GeoPoint currentPoint = input.get(currentIndex);\n      noIdenticalPoints.add(currentPoint);\n      while (true) {\n        currentIndex = getLegalIndex(currentIndex + 1, input.size());\n        if (currentIndex == startIndex) {\n          break;\n        }\n        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);\n        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {\n          break;\n        }\n      }\n      if (currentIndex == startIndex) {\n        break;\n      }\n    }\n    \n    if (noIdenticalPoints.size() < 3) {\n      return null;\n    }\n    \n    // Now, do the depth-first search needed to find a path that has no coplanarities in it.\n    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.\n    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.\n    // But we have to produce a polygon that is safe no matter which way it is looked at.\n    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.\n    // This algorithmically awful in the worst case, but luckily we can presume that real-life data\n    // does not require more than a couple of iterations.\n    \n    for  (int i = 0; i < noIdenticalPoints.size(); i++) {\n      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);\n      // Search, with this as the start path.\n      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);\n      if (resultPath != null && resultPath.previous != null) {\n        // Read out result, maintaining ordering\n        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());\n        resultPath.fillInList(rval);\n        return rval;\n      }\n    }\n    // No path found.  This means that everything was coplanar.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"06729f5a814f91b46fa06d668ae86a5d257ba644":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","06729f5a814f91b46fa06d668ae86a5d257ba644"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"]},"commit2Childs":{"06729f5a814f91b46fa06d668ae86a5d257ba644":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06729f5a814f91b46fa06d668ae86a5d257ba644","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}