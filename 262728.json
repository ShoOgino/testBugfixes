{"path":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","commits":[{"id":"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753","date":1416999434,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 2000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91efc148b027dbb57e9dbdf18b654785c1d716f2","date":1417123160,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","sourceNew":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 2000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","sourceNew":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    assumeFalse(\"we directly delete files\", TestUtil.hasVirusChecker(root));\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","sourceNew":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    assumeFalse(\"we directly delete files\", TestUtil.hasVirusChecker(root));\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader#testRandomMultipleSchemaGens().mjava","sourceNew":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 200);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","sourceOld":"  public void testRandomMultipleSchemaGens() throws Exception {\n\n    AtomicLong currentSchemaGen = new AtomicLong();\n    ReindexingReader reindexer = null;\n\n    // TODO: separate refresh thread, search threads, indexing threads\n    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 1000);\n    int maxID = 0;\n    Path root = createTempDir();\n    int refreshEveryNumDocs = 100;\n    int commitCloseNumDocs = 1000;\n    for(int i=0;i<numDocs;i++) {\n      if (reindexer == null) {\n        reindexer = getReindexerNewDVFields(root, currentSchemaGen);\n      }\n\n      Document doc = new Document();\n      String id;\n      String updateID;\n      if (maxID > 0 && random().nextInt(10) == 7) {\n        // Replace a doc\n        id = \"\" + random().nextInt(maxID);\n        updateID = id;\n      } else {\n        id = \"\" + (maxID++);\n        updateID = null;\n      }\n        \n      doc.add(newStringField(\"id\", id, Field.Store.NO));\n      doc.add(newTextField(\"text\", \"number \" + random().nextLong(), Field.Store.YES));\n      if (updateID == null) {\n        reindexer.w.addDocument(doc);\n      } else {\n        reindexer.w.updateDocument(new Term(\"id\", updateID), doc);\n      }\n      if (random().nextInt(refreshEveryNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: refresh @ \" + (i+1) + \" docs\");\n        reindexer.mgr.maybeRefresh();\n\n        DirectoryReader r = reindexer.mgr.acquire();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: got reader=\" + r);\n        try {\n          checkAllNumberDVs(r, \"number_\" + currentSchemaGen.get(), true, 1);\n        } finally {\n          reindexer.mgr.release(r);\n        }\n        if (DEBUG) reindexer.printRefCounts();\n        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);\n      }\n\n      if (random().nextInt(500) == 17) {\n        currentSchemaGen.incrementAndGet();\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: advance schemaGen to \" + currentSchemaGen);\n      }\n\n      if (i > 0 && random().nextInt(10) == 7) {\n        // Random delete:\n        reindexer.w.deleteDocuments(new Term(\"id\", \"\"+random().nextInt(i)));\n      }\n\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: commit @ \" + (i+1) + \" docs\");\n        reindexer.commit();\n        //reindexer.printRefCounts();\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n\n      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:\n      if (random().nextInt(commitCloseNumDocs) == 17) {\n        if (DEBUG) System.out.println(Thread.currentThread().getName() + \": TEST TOP: close writer @ \" + (i+1) + \" docs\");\n        reindexer.close();\n        reindexer = null;\n        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);\n      }\n    }\n\n    if (reindexer != null) {\n      reindexer.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["91efc148b027dbb57e9dbdf18b654785c1d716f2"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"91efc148b027dbb57e9dbdf18b654785c1d716f2":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["91efc148b027dbb57e9dbdf18b654785c1d716f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":[],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["91efc148b027dbb57e9dbdf18b654785c1d716f2"],"91efc148b027dbb57e9dbdf18b654785c1d716f2":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}