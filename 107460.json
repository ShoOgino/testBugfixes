{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89d71e0157fcc66ac45395765150cc85ee28aec","date":1458134775,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // TODO: range checks\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20 * polyLons.length; // TODO: make this fancier, but currently linear with number of vertices\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":["33bb6bd7295e66f93f182556f5353b97243e62ba","1904709ea0185dc04e3d77ea01c79e909caf2796","94ee361295fb38310ac4d53cb4773d1622423d68","2b63007489248c99b5cdc766ce55938891f5d969"],"bugIntro":["82235a501cff963da53cb98d86009e33e15cf47f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // TODO: range checks\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,\n                                                                                polyLats, polyLons,\n                                                                                minLat, maxLat, minLon, maxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,\n                                                                                polyLats, polyLons,\n                                                                                minLat, maxLat, minLon, maxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoRelationUtils.pointInPolygon(polyLats, polyLons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20 * polyLons.length; // TODO: make this fancier, but currently linear with number of vertices\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // TODO: range checks\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20 * polyLons.length; // TODO: make this fancier, but currently linear with number of vertices\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95ddcac9ac08381985af6eac8f8b77ba881d4ad8","date":1459477726,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final GeoRect box = Polygon.getBoundingBox(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // TODO: range checks\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,\n                                                                                polyLats, polyLons,\n                                                                                minLat, maxLat, minLon, maxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,\n                                                                                polyLats, polyLons,\n                                                                                minLat, maxLat, minLon, maxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoRelationUtils.pointInPolygon(polyLats, polyLons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20 * polyLons.length; // TODO: make this fancier, but currently linear with number of vertices\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["82235a501cff963da53cb98d86009e33e15cf47f","925fce43f3bac029d912b9b7de03c789e258a333"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43ddc1b7a872fafd838d3f3129984ca661e29b36","date":1459526591,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final GeoRect box = GeoRect.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final GeoRect box = Polygon.getBoundingBox(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final GeoRect box = GeoRect.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82235a501cff963da53cb98d86009e33e15cf47f","date":1459788663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(LatLonPoint.encodeLatitude(box.minLat), \n                                           LatLonPoint.encodeLatitude(box.maxLat),\n                                           LatLonPoint.encodeLongitude(box.minLon),\n                                           LatLonPoint.encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8","1904709ea0185dc04e3d77ea01c79e909caf2796","b89d71e0157fcc66ac45395765150cc85ee28aec"],"bugIntro":["bc0f1175d994495cbd5763445c91c22f543d8687"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(LatLonPoint.encodeLatitude(box.minLat), \n                                           LatLonPoint.encodeLatitude(box.maxLat),\n                                           LatLonPoint.encodeLongitude(box.minLon),\n                                           LatLonPoint.encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (Polygon.contains(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (Polygon.crosses(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (Polygon.contains(polygons, docLatitude, docLongitude)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","date":1460056040,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(LatLonPoint.encodeLatitude(box.minLat), \n                                           LatLonPoint.encodeLatitude(box.maxLat),\n                                           LatLonPoint.encodeLongitude(box.minLon),\n                                           LatLonPoint.encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["bc0f1175d994495cbd5763445c91c22f543d8687","925fce43f3bac029d912b9b7de03c789e258a333"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09f15823cf5eb6e807005579e875e117d8598f95","date":1460066385,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(LatLonPoint.encodeLatitude(box.minLat), \n                                           LatLonPoint.encodeLatitude(box.maxLat),\n                                           LatLonPoint.encodeLongitude(box.minLon),\n                                           LatLonPoint.encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"034996547ca41c5004216fdd0178acbf06438da2","date":1461284133,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747","925fce43f3bac029d912b9b7de03c789e258a333"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    // TODO: make this fancier, but currently linear with number of vertices\n    float cumulativeCost = 0;\n    for (Polygon polygon : polygons) {\n      cumulativeCost += 20 * (polygon.getPolyLats().length + polygon.getHoles().length);\n    }\n    final float matchCost = cumulativeCost;\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                int latitudeBits = (int)(encoded >> 32);\n                int longitudeBits = (int)(encoded & 0xFFFFFFFF);\n                if (grid.contains(latitudeBits, longitudeBits)) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return matchCost;\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc0f1175d994495cbd5763445c91c22f543d8687","date":1461352263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonTree[] tree = LatLonTree.build(polygons);\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), tree);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return LatLonTree.relate(tree, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":["82235a501cff963da53cb98d86009e33e15cf47f","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"bugIntro":["925fce43f3bac029d912b9b7de03c789e258a333"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6503769018230fc19993dfa830c8d301e12aa32f","date":1461538070,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonTree[] tree = LatLonTree.build(polygons);\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), tree);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return LatLonTree.relate(tree, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonTree[] tree = LatLonTree.build(polygons);\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), tree);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return LatLonTree.relate(tree, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonTree[] tree = LatLonTree.build(polygons);\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), tree);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return LatLonTree.relate(tree, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8","034996547ca41c5004216fdd0178acbf06438da2","bc0f1175d994495cbd5763445c91c22f543d8687","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","date":1461676641,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final LatLonGrid grid = new LatLonGrid(encodeLatitude(box.minLat),\n                                           encodeLatitude(box.maxLat),\n                                           encodeLongitude(box.minLon),\n                                           encodeLongitude(box.maxLon), polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return;\n                             }\n                             if (grid.contains(NumericUtils.sortableBytesToInt(packedValue, 0), \n                                               NumericUtils.sortableBytesToInt(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return Polygon.relate(polygons, cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","date":1461772947,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f976862431a9be6f9f76f958b5a9a04aa2342747","date":1464099811,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":["034996547ca41c5004216fdd0178acbf06438da2","1904709ea0185dc04e3d77ea01c79e909caf2796","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               adder.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n    \n    // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons\n    // these are pre-encoded with LatLonPoint's encoding\n    final Rectangle box = Rectangle.fromPolygon(polygons);\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n\n    final Polygon2D tree = Polygon2D.create(polygons);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field, \n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             if (tree.contains(decodeLatitude(packedValue, 0), \n                                               decodeLongitude(packedValue, Integer.BYTES))) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0 ||\n                                 StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0) {\n                               // outside of global bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                             \n                             double cellMinLat = decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             return tree.relate(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon);\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"82235a501cff963da53cb98d86009e33e15cf47f":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"bc0f1175d994495cbd5763445c91c22f543d8687":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8"],"95ddcac9ac08381985af6eac8f8b77ba881d4ad8":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["b89d71e0157fcc66ac45395765150cc85ee28aec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"f976862431a9be6f9f76f958b5a9a04aa2342747":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"09f15823cf5eb6e807005579e875e117d8598f95":["82235a501cff963da53cb98d86009e33e15cf47f","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["09f15823cf5eb6e807005579e875e117d8598f95","034996547ca41c5004216fdd0178acbf06438da2"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","f976862431a9be6f9f76f958b5a9a04aa2342747"],"83870855d82aba6819217abeff5a40779dbb28b4":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","0e121d43b5a10f2df530f406f935102656e9c4e8"],"6503769018230fc19993dfa830c8d301e12aa32f":["bc0f1175d994495cbd5763445c91c22f543d8687"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["82235a501cff963da53cb98d86009e33e15cf47f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"925fce43f3bac029d912b9b7de03c789e258a333":["6503769018230fc19993dfa830c8d301e12aa32f"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","82235a501cff963da53cb98d86009e33e15cf47f"],"b89d71e0157fcc66ac45395765150cc85ee28aec":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["925fce43f3bac029d912b9b7de03c789e258a333"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","94ee361295fb38310ac4d53cb4773d1622423d68"],"034996547ca41c5004216fdd0178acbf06438da2":["09f15823cf5eb6e807005579e875e117d8598f95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"]},"commit2Childs":{"82235a501cff963da53cb98d86009e33e15cf47f":["09f15823cf5eb6e807005579e875e117d8598f95","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"bc0f1175d994495cbd5763445c91c22f543d8687":["6503769018230fc19993dfa830c8d301e12aa32f"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"95ddcac9ac08381985af6eac8f8b77ba881d4ad8":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["95ddcac9ac08381985af6eac8f8b77ba881d4ad8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["94ee361295fb38310ac4d53cb4773d1622423d68","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"94ee361295fb38310ac4d53cb4773d1622423d68":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["82235a501cff963da53cb98d86009e33e15cf47f","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"f976862431a9be6f9f76f958b5a9a04aa2342747":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"09f15823cf5eb6e807005579e875e117d8598f95":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","034996547ca41c5004216fdd0178acbf06438da2"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["bc0f1175d994495cbd5763445c91c22f543d8687","f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"6503769018230fc19993dfa830c8d301e12aa32f":["925fce43f3bac029d912b9b7de03c789e258a333"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["f976862431a9be6f9f76f958b5a9a04aa2342747","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["09f15823cf5eb6e807005579e875e117d8598f95"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"925fce43f3bac029d912b9b7de03c789e258a333":["a61b5b0e4cf8ab04d7674f9ae117ddc60be22005"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"b89d71e0157fcc66ac45395765150cc85ee28aec":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["b89d71e0157fcc66ac45395765150cc85ee28aec"],"034996547ca41c5004216fdd0178acbf06438da2":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}