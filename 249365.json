{"path":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object).mjava","commits":[{"id":"e1eb6b3ce884c0b9e064e112da158013ec33cd91","date":1402692077,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * primitiveSizes.get(componentClazz);\n          } else {\n            size += (long) NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e1019a365f90871803e0de296165d291865c2ce","date":1402929675,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object,Filter).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/RamUsageTester#measureObjectSize(Object).mjava","sourceNew":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth\n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).\n   */\n  private static long measureObjectSize(Object root, Filter filter) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            if (filter.accept(f)) {\n              // Fast path to eliminate redundancies.\n              final Object o = f.get(ob);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","sourceOld":"  /*\n   * Non-recursive version of object descend. This consumes more memory than recursive in-depth \n   * traversal but prevents stack overflows on long chains of objects\n   * or complex graphs (a max. recursion depth on my machine was ~5000 objects linked in a chain\n   * so not too much).  \n   */\n  private static long measureObjectSize(Object root) {\n    // Objects seen so far.\n    final IdentityHashSet<Object> seen = new IdentityHashSet<>();\n    // Class cache with reference Field and precalculated shallow size. \n    final IdentityHashMap<Class<?>, ClassCache> classCache = new IdentityHashMap<>();\n    // Stack of objects pending traversal. Recursion caused stack overflows. \n    final ArrayList<Object> stack = new ArrayList<>();\n    stack.add(root);\n\n    long totalSize = 0;\n    while (!stack.isEmpty()) {\n      final Object ob = stack.remove(stack.size() - 1);\n\n      if (ob == null || seen.contains(ob)) {\n        continue;\n      }\n      seen.add(ob);\n\n      final Class<?> obClazz = ob.getClass();\n      assert obClazz != null : \"jvm bug detected (Object.getClass() == null). please report this to your vendor\";\n      if (obClazz.isArray()) {\n        /*\n         * Consider an array, possibly of primitive types. Push any of its references to\n         * the processing stack and accumulate this array's shallow size. \n         */\n        long size = RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;\n        final int len = Array.getLength(ob);\n        if (len > 0) {\n          Class<?> componentClazz = obClazz.getComponentType();\n          if (componentClazz.isPrimitive()) {\n            size += (long) len * RamUsageEstimator.shallowSizeOfInstance(componentClazz);\n          } else {\n            size += (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * len;\n\n            // Push refs for traversal later.\n            for (int i = len; --i >= 0 ;) {\n              final Object o = Array.get(ob, i);\n              if (o != null && !seen.contains(o)) {\n                stack.add(o);\n              }\n            }            \n          }\n        }\n        totalSize += RamUsageEstimator.alignObjectSize(size);\n      } else {\n        /*\n         * Consider an object. Push any references it has to the processing stack\n         * and accumulate this object's shallow size. \n         */\n        try {\n          ClassCache cachedInfo = classCache.get(obClazz);\n          if (cachedInfo == null) {\n            classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));\n          }\n\n          for (Field f : cachedInfo.referenceFields) {\n            // Fast path to eliminate redundancies.\n            final Object o = f.get(ob);\n            if (o != null && !seen.contains(o)) {\n              stack.add(o);\n            }\n          }\n\n          totalSize += cachedInfo.alignedShallowInstanceSize;\n        } catch (IllegalAccessException e) {\n          // this should never happen as we enabled setAccessible().\n          throw new RuntimeException(\"Reflective field access failed?\", e);\n        }\n      }\n    }\n\n    // Help the GC (?).\n    seen.clear();\n    stack.clear();\n    classCache.clear();\n\n    return totalSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4e1019a365f90871803e0de296165d291865c2ce":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4e1019a365f90871803e0de296165d291865c2ce"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"4e1019a365f90871803e0de296165d291865c2ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["4e1019a365f90871803e0de296165d291865c2ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}