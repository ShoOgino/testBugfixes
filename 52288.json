{"path":"lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchHighlighter#testHighlightMoreQueriesAtOnceShowoff().mjava","commits":[{"id":"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0","date":1599736633,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchHighlighter#testHighlightMoreQueriesAtOnceShowoff().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testHighlightMoreQueriesAtOnceShowoff() throws IOException {\n    // Match highlighter underlying components are powerful enough to build interesting,\n    // if not always super-practical, things. In this case, we would like to highlight\n    // a set of matches of *more than one* query over the same set of input documents. This includes\n    // highest-scoring passage resolution (from multiple hits) and different highlight markers\n    // for each query.\n    new IndexBuilder(this::toField)\n        .doc(FLD_TEXT1, \"foo bar baz\")\n        .doc(FLD_TEXT1, \"foo baz bar\")\n        .build(analyzer, reader -> {\n          // Let's start with the two queries. The first one will be an unordered\n          // query for (foo, baz) with a max gap of 1; let's use intervals for this.\n          Query q1 = new IntervalQuery(FLD_TEXT1,\n                  Intervals.maxgaps(1,\n                      Intervals.unordered(\n                          Intervals.term(\"foo\"),\n                          Intervals.term(\"baz\"))));\n\n          // The second one will be a simpler term query for \"bar\".\n          Query q2 = new TermQuery(new Term(FLD_TEXT1, \"bar\"));\n\n          // Let's fetch matching documents by combining the two into a Boolean query.\n          Query query = new BooleanQuery.Builder()\n              .add(q1, BooleanClause.Occur.SHOULD)\n              .add(q2, BooleanClause.Occur.SHOULD)\n              .build();\n\n          IndexSearcher searcher = new IndexSearcher(reader);\n          Sort sortOrder = Sort.INDEXORDER; // So that results are consistently ordered.\n          TopDocs topDocs = searcher.search(query, 10, sortOrder);\n\n          // If we use the \"regular\" highlighter, the result will be slightly odd: a nested\n          // highlight over \"bar\" within the first match. Also, you can't distinguish which of the sub-queries\n          // caused which highlight marker... but if it were HTML then you could give the span\n          // some semi-translucent background and layered matches would be visible.\n          MatchHighlighter highlighter =\n              new MatchHighlighter(searcher, analyzer)\n                  .appendFieldHighlighter(FieldValueHighlighters.highlighted(\n                      80 * 3, 1, new PassageFormatter(\"...\", \"<span>\", \"</span>\"), FLD_TEXT1::equals))\n                  .appendFieldHighlighter(FieldValueHighlighters.skipRemaining());\n\n          assertHighlights(toDocList(highlighter.highlight(topDocs, query)),\n              \"0. text1: <span>foo <span>bar</span> baz</span>\",\n              \"1. text1: <span>foo baz</span> <span>bar</span>\");\n\n          // To separate highlights for multiple queries we'll pass them separately to the\n          // highlighter and differentiate highlight markers upon their application. Let's start with the customized\n          // field highlighter first. This utilizes the fact that match ranges passed from MatchHighlighter\n          // contain a reference to the original query which brought up the match.\n          class SeparateMarkerFieldHighlighter implements MatchHighlighter.FieldValueHighlighter {\n            private final String field;\n            private final Map<Query, String> queryClassMap;\n\n            SeparateMarkerFieldHighlighter(String field, Map<Query, String> queryClassMap) {\n              this.field = field;\n              this.queryClassMap = queryClassMap;\n            }\n\n            @Override\n            public boolean isApplicable(String field, boolean hasMatches) {\n              return Objects.equals(field, this.field) && hasMatches;\n            }\n\n            @Override\n            public List<String> format(String field, String[] values, String contiguousValue,\n                                       List<OffsetRange> valueRanges, List<MatchHighlighter.QueryOffsetRange> matchOffsets) {\n              PassageSelector passageSelector = new PassageSelector();\n              int maxPassageWindow = 80;\n              int maxPassages = 3;\n              List<Passage> bestPassages =\n                  passageSelector.pickBest(contiguousValue, matchOffsets, maxPassageWindow, maxPassages, valueRanges);\n\n              // We know the offset ranges passed to us by MatchHighlighter are instances of QueryOffsetRange\n              // so we compute the class based on that.\n              Function<OffsetRange, String> queryToClass =\n                  (range) -> queryClassMap.get(((MatchHighlighter.QueryOffsetRange) range).query);\n\n              PassageFormatter passageFormatter = new PassageFormatter(\"...\",\n                  (range) -> \"<span class='\" + queryToClass.apply(range) + \"'>\",\n                  (range) -> \"</span>\");\n\n              return passageFormatter.format(contiguousValue, bestPassages, valueRanges);\n            }\n          }\n\n          // And this is pretty much it. We now set up query classes to display, set up the highlighter...\n          Map<Query, String> queryClassMap = Map.of(q1, \"q1\", q2, \"q2\");\n          highlighter =\n              new MatchHighlighter(searcher, analyzer)\n                  .appendFieldHighlighter(new SeparateMarkerFieldHighlighter(FLD_TEXT1, queryClassMap))\n                  .appendFieldHighlighter(FieldValueHighlighters.skipRemaining());\n\n          // ...and run highlighting. Note the query passed to the highlighter are individual sub-clauses\n          // of the Boolean query used to fetch documents.\n          assertHighlights(toDocList(highlighter.highlight(topDocs, q1, q2)),\n              \"0. text1: <span class='q1'>foo <span class='q2'>bar</span> baz</span>\",\n              \"1. text1: <span class='q1'>foo baz</span> <span class='q2'>bar</span>\");\n        });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["930e5c340e08514a7f57a54cf65e2f8f1f90c8f0"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["930e5c340e08514a7f57a54cf65e2f8f1f90c8f0"],"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}