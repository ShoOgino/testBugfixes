{"path":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","commits":[{"id":"16502203cfbb2b9695ec18dbb9d2d2c70dd1ff80","date":1532111887,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/ExportWriter#write(OutputStream).mjava","sourceNew":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if (sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if (sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if (sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer) req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if (fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else {\n      fields = fl.split(\",\");\n\n      for (int i = 0; i < fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if (fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n\n  }\n\n","sourceOld":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","sourceNew":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if (sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if (sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if (sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer) req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if (fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else {\n      fields = fl.split(\",\");\n\n      for (int i = 0; i < fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if (fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    String expr = params.get(StreamParams.EXPR);\n    if (expr != null) {\n      StreamFactory streamFactory = initialStreamContext.getStreamFactory();\n      streamFactory.withDefaultSort(params.get(CommonParams.SORT));\n      try {\n        StreamExpression expression = StreamExpressionParser.parse(expr);\n        if (streamFactory.isEvaluator(expression)) {\n          streamExpression = new StreamExpression(StreamParams.TUPLE);\n          streamExpression.addParameter(new StreamExpressionNamedParameter(StreamParams.RETURN_VALUE, expression));\n        } else {\n          streamExpression = expression;\n        }\n      } catch (Exception e) {\n        writeException(e, writer, true);\n        return;\n      }\n      streamContext = new StreamContext();\n      streamContext.setRequestParams(params);\n      streamContext.setLocal(true);\n\n      streamContext.workerID = 0;\n      streamContext.numWorkers = 1;\n      streamContext.setSolrClientCache(initialStreamContext.getSolrClientCache());\n      streamContext.setModelCache(initialStreamContext.getModelCache());\n      streamContext.setObjectCache(initialStreamContext.getObjectCache());\n      streamContext.put(\"core\", req.getCore().getName());\n      streamContext.put(\"solr-core\", req.getCore());\n      streamContext.put(CommonParams.SORT, params.get(CommonParams.SORT));\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n    if (streamContext != null) {\n      streamContext = null;\n    }\n  }\n\n","sourceOld":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if (sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if (sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if (sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer) req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if (fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else {\n      fields = fl.split(\",\");\n\n      for (int i = 0; i < fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if (fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee","date":1593704090,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/export/ExportWriter#write(OutputStream).mjava","sourceNew":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if (sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if (sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if (sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer) req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if (fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else {\n      fields = fl.split(\",\");\n\n      for (int i = 0; i < fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if (fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    String expr = params.get(StreamParams.EXPR);\n    if (expr != null) {\n      StreamFactory streamFactory = initialStreamContext.getStreamFactory();\n      streamFactory.withDefaultSort(params.get(CommonParams.SORT));\n      try {\n        StreamExpression expression = StreamExpressionParser.parse(expr);\n        if (streamFactory.isEvaluator(expression)) {\n          streamExpression = new StreamExpression(StreamParams.TUPLE);\n          streamExpression.addParameter(new StreamExpressionNamedParameter(StreamParams.RETURN_VALUE, expression));\n        } else {\n          streamExpression = expression;\n        }\n      } catch (Exception e) {\n        writeException(e, writer, true);\n        return;\n      }\n      streamContext = new StreamContext();\n      streamContext.setRequestParams(params);\n      streamContext.setLocal(true);\n\n      streamContext.workerID = 0;\n      streamContext.numWorkers = 1;\n      streamContext.setSolrClientCache(initialStreamContext.getSolrClientCache());\n      streamContext.setModelCache(initialStreamContext.getModelCache());\n      streamContext.setObjectCache(initialStreamContext.getObjectCache());\n      streamContext.put(\"core\", req.getCore().getName());\n      streamContext.put(\"solr-core\", req.getCore());\n      streamContext.put(CommonParams.SORT, params.get(CommonParams.SORT));\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, os, iw, sort));\n      });\n    });\n    if (streamContext != null) {\n      streamContext = null;\n    }\n  }\n\n","sourceOld":"  public void write(OutputStream os) throws IOException {\n    QueryResponseWriter rw = req.getCore().getResponseWriters().get(wt);\n    if (rw instanceof BinaryResponseWriter) {\n      //todo add support for other writers after testing\n      writer = new JavaBinCodec(os, null);\n    } else {\n      respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n      writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    }\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if (sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if (sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if (sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer) req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if (fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else {\n      fields = fl.split(\",\");\n\n      for (int i = 0; i < fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if (fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    String expr = params.get(StreamParams.EXPR);\n    if (expr != null) {\n      StreamFactory streamFactory = initialStreamContext.getStreamFactory();\n      streamFactory.withDefaultSort(params.get(CommonParams.SORT));\n      try {\n        StreamExpression expression = StreamExpressionParser.parse(expr);\n        if (streamFactory.isEvaluator(expression)) {\n          streamExpression = new StreamExpression(StreamParams.TUPLE);\n          streamExpression.addParameter(new StreamExpressionNamedParameter(StreamParams.RETURN_VALUE, expression));\n        } else {\n          streamExpression = expression;\n        }\n      } catch (Exception e) {\n        writeException(e, writer, true);\n        return;\n      }\n      streamContext = new StreamContext();\n      streamContext.setRequestParams(params);\n      streamContext.setLocal(true);\n\n      streamContext.workerID = 0;\n      streamContext.numWorkers = 1;\n      streamContext.setSolrClientCache(initialStreamContext.getSolrClientCache());\n      streamContext.setModelCache(initialStreamContext.getModelCache());\n      streamContext.setObjectCache(initialStreamContext.getObjectCache());\n      streamContext.put(\"core\", req.getCore().getName());\n      streamContext.put(\"solr-core\", req.getCore());\n      streamContext.put(CommonParams.SORT, params.get(CommonParams.SORT));\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n    if (streamContext != null) {\n      streamContext = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee":["804a8d5358fe7b7563b85ee7838714d720b89272"],"16502203cfbb2b9695ec18dbb9d2d2c70dd1ff80":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"804a8d5358fe7b7563b85ee7838714d720b89272":["16502203cfbb2b9695ec18dbb9d2d2c70dd1ff80"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee"]},"commit2Childs":{"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"16502203cfbb2b9695ec18dbb9d2d2c70dd1ff80":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["16502203cfbb2b9695ec18dbb9d2d2c70dd1ff80"],"804a8d5358fe7b7563b85ee7838714d720b89272":["1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}