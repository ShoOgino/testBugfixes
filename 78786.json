{"path":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"432127b09840b2b70209e404d242e7029421ef0a","date":1280433941,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef02613bb5b67b98ca5caf41e8d6e016a0158923","date":1283980033,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"755f2f419306d7297c8feee10d1897addf4b2dd0","date":1294442354,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList facet_counts = new SimpleOrderedMap();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList facet_queries = new SimpleOrderedMap();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList facet_fields = new SimpleOrderedMap();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList fieldCounts = new NamedList(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1c5c000a4f7db9f84794088342aa428d80dfa37","date":1303079085,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":["9ac277fcde6efbfb4b34a6b2cdbda483003cda18","9eeefc9a351a2910959c41bf241877a3d60eec37","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0833d477d790b0926422e7ac018b1bcee73ad5bd","date":1303334953,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n      for (int i=dff.offset; i<end; i++) {\n        if (counts[i].count < dff.minCount) {\n          if (countSorted) break;  // if sorted by count, we can break out of loop early\n          else continue;\n        }\n        fieldCounts.add(counts[i].name, num(counts[i].count));\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    // TODO: facet dates & numbers\n    facet_counts.add(\"facet_dates\", new SimpleOrderedMap());\n    facet_counts.add(\"facet_ranges\", new SimpleOrderedMap());\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","sourceOld":"  @Override\n  public void finishStage(ResponseBuilder rb) {\n    if (!rb.doFacets || rb.stage != ResponseBuilder.STAGE_GET_FIELDS) return;\n    // wait until STAGE_GET_FIELDS\n    // so that \"result\" is already stored in the response (for aesthetics)\n\n\n    FacetInfo fi = rb._facetInfo;\n\n    NamedList<Object> facet_counts = new SimpleOrderedMap<Object>();\n\n    if (fi.exceptionList != null) {\n      facet_counts.add(\"exception\",fi.exceptionList);\n    }\n\n    NamedList<Number> facet_queries = new SimpleOrderedMap<Number>();\n    facet_counts.add(\"facet_queries\",facet_queries);\n    for (QueryFacet qf : fi.queryFacets.values()) {\n      facet_queries.add(qf.getKey(), num(qf.count));\n    }\n\n    NamedList<Object> facet_fields = new SimpleOrderedMap<Object>();\n    facet_counts.add(\"facet_fields\", facet_fields);\n\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      NamedList<Object> fieldCounts = new NamedList<Object>(); // order is more important for facets\n      facet_fields.add(dff.getKey(), fieldCounts);\n\n      ShardFacetCount[] counts;\n      boolean countSorted = dff.sort.equals(FacetParams.FACET_SORT_COUNT);\n      if (countSorted) {\n        counts = dff.countSorted;\n        if (counts == null || dff.needRefinements) {\n          counts = dff.getCountSorted();\n        }\n      } else if (dff.sort.equals(FacetParams.FACET_SORT_INDEX)) {\n          counts = dff.getLexSorted();\n      } else { // TODO: log error or throw exception?\n          counts = dff.getLexSorted();\n      }\n\n      if (countSorted) {\n        int end = dff.limit < 0 ? counts.length : Math.min(dff.offset + dff.limit, counts.length);\n        for (int i=dff.offset; i<end; i++) {\n          if (counts[i].count < dff.minCount) {\n            break;\n          }\n          fieldCounts.add(counts[i].name, num(counts[i].count));\n        }\n      } else {\n        int off = dff.offset;\n        int lim = dff.limit >= 0 ? dff.limit : Integer.MAX_VALUE;\n\n        // index order...\n        for (int i=0; i<counts.length; i++) {\n          long count = counts[i].count;\n          if (count < dff.minCount) continue;\n          if (off > 0) {\n            off--;\n            continue;\n          }\n          if (lim <= 0) {\n            break;\n          }\n          lim--;\n          fieldCounts.add(counts[i].name, num(count));\n        }\n      }\n\n      if (dff.missing) {\n        fieldCounts.add(null, num(dff.missingCount));\n      }\n    }\n\n    facet_counts.add(\"facet_dates\", fi.dateFacets);\n    facet_counts.add(\"facet_ranges\", fi.rangeFacets);\n\n    rb.rsp.add(\"facet_counts\", facet_counts);\n\n    rb._facetInfo = null;  // could be big, so release asap\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["432127b09840b2b70209e404d242e7029421ef0a"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["0833d477d790b0926422e7ac018b1bcee73ad5bd","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"432127b09840b2b70209e404d242e7029421ef0a":["1da8d55113b689b06716246649de6f62430f15c0"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["868da859b43505d9d2a023bfeae6dd0c795f5295","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a3776dccca01c11e7046323cfad46a3b4a471233"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"a3776dccca01c11e7046323cfad46a3b4a471233":["755f2f419306d7297c8feee10d1897addf4b2dd0","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ef02613bb5b67b98ca5caf41e8d6e016a0158923","755f2f419306d7297c8feee10d1897addf4b2dd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0833d477d790b0926422e7ac018b1bcee73ad5bd":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["0833d477d790b0926422e7ac018b1bcee73ad5bd"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","755f2f419306d7297c8feee10d1897addf4b2dd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["755f2f419306d7297c8feee10d1897addf4b2dd0"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","755f2f419306d7297c8feee10d1897addf4b2dd0","29ef99d61cda9641b6250bf9567329a6e65f901d"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"432127b09840b2b70209e404d242e7029421ef0a":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"1da8d55113b689b06716246649de6f62430f15c0":["432127b09840b2b70209e404d242e7029421ef0a","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"0833d477d790b0926422e7ac018b1bcee73ad5bd":["c26f00b574427b55127e869b935845554afde1fa","135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a3776dccca01c11e7046323cfad46a3b4a471233","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["0833d477d790b0926422e7ac018b1bcee73ad5bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}