{"path":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd00dd91853514614379b0e680d65bd19cac0f30","date":1283087816,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43adc163640856c8b07e4cf1b2046c9af56d3ae7","date":1286989273,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","date":1292210954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder();\n    rb.req = req;\n    rb.rsp = rsp;\n    rb.components = components;\n    rb.setDebug(req.getParams().getBool(CommonParams.DEBUG_QUERY, false));\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (rb.shards == null) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if( rb.getDebugInfo() == null ) {\n          rb.setDebugInfo( new SimpleOrderedMap<Object>() );\n        }\n        rb.getDebugInfo().add( \"timing\", timer.asNamedList() );\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"785c5e6bc8889b740445ed7f2b278a442ad92f7f","date":1307558822,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"828f199c76d70a5ea0ddc4d9605063f1d323a28d","date":1308738340,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      HttpCommComponent comm = new HttpCommComponent();\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardHandler = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardHandler == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardHandler);\n              }\n              comm.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = comm.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              comm.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","785c5e6bc8889b740445ed7f2b278a442ad92f7f"],"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["cd00dd91853514614379b0e680d65bd19cac0f30"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["828f199c76d70a5ea0ddc4d9605063f1d323a28d","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"2553b00f699380c64959ccb27991289aae87be2e":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["785c5e6bc8889b740445ed7f2b278a442ad92f7f"],"785c5e6bc8889b740445ed7f2b278a442ad92f7f":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["785c5e6bc8889b740445ed7f2b278a442ad92f7f","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"cd00dd91853514614379b0e680d65bd19cac0f30":["1da8d55113b689b06716246649de6f62430f15c0"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","785c5e6bc8889b740445ed7f2b278a442ad92f7f"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["cd00dd91853514614379b0e680d65bd19cac0f30","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["2553b00f699380c64959ccb27991289aae87be2e"],"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"785c5e6bc8889b740445ed7f2b278a442ad92f7f":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","828f199c76d70a5ea0ddc4d9605063f1d323a28d","d083e83f225b11e5fdd900e83d26ddb385b6955c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd00dd91853514614379b0e680d65bd19cac0f30":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd00dd91853514614379b0e680d65bd19cac0f30"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","785c5e6bc8889b740445ed7f2b278a442ad92f7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}