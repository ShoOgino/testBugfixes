{"path":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","commits":[{"id":"0f719faa74f7213d4a395510dbc1f1b7cb178484","date":1410881394,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43b3034cd34b8cb87874ebdd7b1cfb2281200623","date":1498354741,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n\n    final CollectorState states[] = new CollectorState[statsArr.length];\n    for (int count = 0; count < statsArr.length; count++) {\n      states[count] = new CollectorState();\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      private final CollectorState collectorState[] = states;\n\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n\n    final CollectorState states[] = new CollectorState[statsArr.length];\n    for (int count = 0; count < statsArr.length; count++) {\n      states[count] = new CollectorState();\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      private final CollectorState collectorState[] = states;\n\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2d13525f1dc36cdefcb92f649c930405104dbe8","date":1498512806,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n\n    final CollectorState states[] = new CollectorState[statsArr.length];\n    for (int count = 0; count < statsArr.length; count++) {\n      states[count] = new CollectorState();\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      private final CollectorState collectorState[] = states;\n\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n\n    final CollectorState states[] = new CollectorState[statsArr.length];\n    for (int count = 0; count < statsArr.length; count++) {\n      states[count] = new CollectorState();\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      private final CollectorState collectorState[] = states;\n\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count], collectorState[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c495edcca4d0bc51bf62d9be3527c87bf9b44ded","date":1498673617,"type":4,"author":"Dennis Gove","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/statistics/StatsCollectorSupplierFactory#create(IndexSchema,List[ExpressionRequest]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Builds a Supplier that will generate identical arrays of new StatsCollectors.\n   * \n   * @param schema The Schema being used.\n   * @param exRequests The expression requests to generate a StatsCollector[] from.\n   * @return A Supplier that will return an array of new StatsCollector.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Supplier<StatsCollector[]> create(IndexSchema schema, List<ExpressionRequest> exRequests ) {\n    final Map<String, Set<String>> collectorStats =  new TreeMap<>();\n    final Map<String, Set<Integer>> collectorPercs =  new TreeMap<>();\n    final Map<String, ValueSource> collectorSources =  new TreeMap<>();\n    \n    // Iterate through all expression request to make a list of ValueSource strings\n    // and statistics that need to be calculated on those ValueSources.\n    for (ExpressionRequest expRequest : exRequests) {\n      String statExpression = expRequest.getExpressionString();\n      Set<String> statistics = getStatistics(statExpression);\n      if (statistics == null) {\n        continue;\n      }\n      for (String statExp : statistics) {\n        String stat;\n        String operands;\n        try {\n          stat = statExp.substring(0, statExp.indexOf('(')).trim();\n          operands = statExp.substring(statExp.indexOf('(')+1, statExp.lastIndexOf(')')).trim();\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Unable to parse statistic: [\"+statExpression+\"]\",e);\n        }\n        String[] arguments = ExpressionFactory.getArguments(operands);\n        String source = arguments[0];\n        if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {\n          // The statistic is a percentile, extra parsing is required\n          if (arguments.length<2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too few arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          } else if (arguments.length>2) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n          }\n          source = arguments[1];\n          Set<Integer> percs = collectorPercs.get(source);\n          if (percs == null) {\n            percs = new HashSet<>();\n            collectorPercs.put(source, percs);\n          }\n          try {\n            int perc = Integer.parseInt(arguments[0]);\n            if (perc>0 && perc<100) {\n              percs.add(perc);\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"The percentile in [\"+statExp+\"] is not between 0 and 100, exculsive.\");\n            }\n          } catch (NumberFormatException e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\"\\\"\"+arguments[0]+\"\\\" cannot be converted into a percentile.\",e);\n          }\n        } else if (arguments.length>1) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Too many arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } else if (arguments.length==0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"No arguments given for \"+stat+\"() in [\"+statExp+\"].\");\n        } \n        // Only unique ValueSources will be made; therefore statistics must be accumulated for\n        // each ValueSource, even across different expression requests\n        Set<String> stats = collectorStats.get(source);\n        if (stats == null) {\n          stats = new HashSet<>();\n          collectorStats.put(source, stats);\n        }\n        if(AnalyticsParams.STAT_PERCENTILE.equals(stat)) {\n          stats.add(stat + \"_\"+ arguments[0]);\n        } else {\n          stats.add(stat);\n        }\n      }\n    }\n    String[] keys = collectorStats.keySet().toArray(new String[0]);\n    for (String sourceStr : keys) {\n      // Build one ValueSource for each unique value source string\n      ValueSource source = buildSourceTree(schema, sourceStr);\n      if (source == null) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"The statistic [\"+sourceStr+\"] could not be parsed.\");\n      }\n      String builtString = source.toString();\n      collectorSources.put(builtString,source);\n      // Replace the user given string with the correctly built string\n      if (!builtString.equals(sourceStr)) {\n        Set<String> stats = collectorStats.remove(sourceStr);\n        if (stats!=null) {\n          collectorStats.put(builtString, stats);\n        }\n        Set<Integer> percs = collectorPercs.remove(sourceStr);\n        if (percs!=null) {\n          collectorPercs.put(builtString, percs);\n        }\n        for (ExpressionRequest er : exRequests) {\n          er.setExpressionString(er.getExpressionString().replace(sourceStr, builtString));\n        }\n      }\n    }\n    if (collectorSources.size()==0) {\n      return new Supplier<StatsCollector[]>() {\n        @Override\n        public StatsCollector[] get() {\n          return new StatsCollector[0];\n        }\n      };\n    }\n    \n    log.info(\"Stats objects: \"+collectorStats.size()+\" sr=\"+collectorSources.size()+\" pr=\"+collectorPercs.size() );\n    \n    // All information is stored in final arrays so that nothing \n    // has to be computed when the Supplier's get() method is called.\n    final Set<String>[] statsArr = collectorStats.values().toArray(new Set[0]);\n    final ValueSource[] sourceArr = collectorSources.values().toArray(new ValueSource[0]);\n    final boolean[] uniqueBools = new boolean[statsArr.length];\n    final boolean[] medianBools = new boolean[statsArr.length];\n    final boolean[] numericBools = new boolean[statsArr.length];\n    final boolean[] dateBools = new boolean[statsArr.length];\n    final double[][] percsArr = new double[statsArr.length][];\n    final String[][] percsNames = new String[statsArr.length][];\n    for (int count = 0; count < sourceArr.length; count++) {\n      uniqueBools[count] = statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);\n      medianBools[count] = statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);\n      numericBools[count] = statsArr[count].contains(AnalyticsParams.STAT_SUM)||statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES)||statsArr[count].contains(AnalyticsParams.STAT_MEAN)||statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);\n      dateBools[count] = (sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);\n      Set<Integer> ps = collectorPercs.get(sourceArr[count].toString());\n      if (ps!=null) {\n        percsArr[count] = new double[ps.size()];\n        percsNames[count] = new String[ps.size()];\n        int percCount = 0;\n        for (int p : ps) {\n          percsArr[count][percCount] = p/100.0;\n          percsNames[count][percCount++] = AnalyticsParams.STAT_PERCENTILE+\"_\"+p;\n        }\n      }\n    }\n    // Making the Supplier\n    return new Supplier<StatsCollector[]>() {\n      public StatsCollector[] get() {\n        StatsCollector[] collectors = new StatsCollector[statsArr.length];\n        for (int count = 0; count < statsArr.length; count++) {\n          if(numericBools[count]){\n            StatsCollector sc = new NumericStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          } else if (dateBools[count]) {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new DateMedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n           collectors[count]=sc;\n          } else {\n            StatsCollector sc = new MinMaxStatsCollector(sourceArr[count], statsArr[count]);\n            if(uniqueBools[count]) sc = new UniqueStatsCollector(sc);\n            if(medianBools[count]) sc = new MedianStatsCollector(sc);\n            if(percsArr[count]!=null) sc = new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);\n            collectors[count]=sc;\n          }\n        }\n        return collectors;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a2d13525f1dc36cdefcb92f649c930405104dbe8":["43b3034cd34b8cb87874ebdd7b1cfb2281200623"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","a2d13525f1dc36cdefcb92f649c930405104dbe8"],"43b3034cd34b8cb87874ebdd7b1cfb2281200623":["0f719faa74f7213d4a395510dbc1f1b7cb178484"],"30c8e5574b55d57947e989443dfde611646530ee":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","28288370235ed02234a64753cdbf0c6ec096304a"],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["a2d13525f1dc36cdefcb92f649c930405104dbe8"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["0f719faa74f7213d4a395510dbc1f1b7cb178484","43b3034cd34b8cb87874ebdd7b1cfb2281200623"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["0f719faa74f7213d4a395510dbc1f1b7cb178484","c495edcca4d0bc51bf62d9be3527c87bf9b44ded"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"a2d13525f1dc36cdefcb92f649c930405104dbe8":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","c495edcca4d0bc51bf62d9be3527c87bf9b44ded"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f719faa74f7213d4a395510dbc1f1b7cb178484"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["30c8e5574b55d57947e989443dfde611646530ee"],"43b3034cd34b8cb87874ebdd7b1cfb2281200623":["a2d13525f1dc36cdefcb92f649c930405104dbe8","b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"30c8e5574b55d57947e989443dfde611646530ee":[],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["43b3034cd34b8cb87874ebdd7b1cfb2281200623","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}