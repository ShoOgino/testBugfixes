{"path":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","commits":[{"id":"e166cc9c5f45f78a8dd02332b5ac100221063fd8","date":1421678965,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"/dev/null","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers);\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"251e6911800e3a02e1da3bfd4dc49a914aef9778","date":1423063783,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1);\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers);\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eebe1eb6c118902a9d33eaecaa4cbaf63ae3513","date":1430308154,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1);\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    });\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, true, 0, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testSubScorerNextIsNotMatch().mjava","sourceNew":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorable scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","sourceOld":"  // Make sure that BooleanScorer keeps working even if the sub clauses return\n  // next matching docs which are less than the actual next match\n  public void testSubScorerNextIsNotMatch() throws IOException {\n    final List<BulkScorer> optionalScorers = Arrays.asList(\n        scorer(100000, 1000001, 9999999),\n        scorer(4000, 1000051),\n        scorer(5000, 100000, 9999998, 9999999)\n    );\n    Collections.shuffle(optionalScorers, random());\n    BooleanScorer scorer = new BooleanScorer(null, optionalScorers, 1, random().nextBoolean());\n    final List<Integer> matches = new ArrayList<>();\n    scorer.score(new LeafCollector() {\n\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {}\n\n      @Override\n      public void collect(int doc) throws IOException {\n        matches.add(doc);\n      }\n      \n    }, null);\n    assertEquals(Arrays.asList(4000, 5000, 100000, 1000001, 1000051, 9999998, 9999999), matches);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["e166cc9c5f45f78a8dd02332b5ac100221063fd8"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["9eebe1eb6c118902a9d33eaecaa4cbaf63ae3513"],"e166cc9c5f45f78a8dd02332b5ac100221063fd8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9eebe1eb6c118902a9d33eaecaa4cbaf63ae3513":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["c8a0e442f7b61f811680273b25da95994a724466"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8a0e442f7b61f811680273b25da95994a724466":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0f4464508ee83288c8c4585b533f9faaa93aa314","c8a0e442f7b61f811680273b25da95994a724466"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285244982ce6aa163d1e60a707f0e6e121736ce5"]},"commit2Childs":{"251e6911800e3a02e1da3bfd4dc49a914aef9778":["9eebe1eb6c118902a9d33eaecaa4cbaf63ae3513"],"e166cc9c5f45f78a8dd02332b5ac100221063fd8":["251e6911800e3a02e1da3bfd4dc49a914aef9778"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"9eebe1eb6c118902a9d33eaecaa4cbaf63ae3513":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e166cc9c5f45f78a8dd02332b5ac100221063fd8"],"c8a0e442f7b61f811680273b25da95994a724466":["285244982ce6aa163d1e60a707f0e6e121736ce5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}