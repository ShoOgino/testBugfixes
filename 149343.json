{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","date":1329061481,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isActive()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"839ca1793cd9a8eb5bd7c7c62918192d47972f73","date":1399544004,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThread.unlock();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"122251c49e5a9fa95f056ea257ae3ab452099fc7","date":1464820065,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized()\n          && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee67a99e7e36da49a4b68758a01d1ac09ff5472c","date":1547653069,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock();\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock(Thread\n        .currentThread(), documentsWriter);\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  DocumentsWriterPerThread obtainAndLock() throws IOException {\n    while (closed == false) {\n      final DocumentsWriterPerThread perThread = perThreadPool.getAndLock();\n      if (perThread.deleteQueue == documentsWriter.deleteQueue) {\n        // simply return the DWPT even in a flush all case since we already hold the lock and the DWPT is not stale\n        // since it has the current delete queue associated with it. This means we have established a happens-before\n        // relationship and all docs indexed into this DWPT are guaranteed to not be flushed with the currently\n        // progress full flush.\n        return perThread;\n      } else {\n        try {\n          // we must first assert otherwise the full flush might make progress once we unlock the dwpt\n          assert fullFlush && fullFlushMarkDone == false :\n              \"found a stale DWPT but full flush mark phase is already done fullFlush: \"\n                  + fullFlush  + \" markDone: \" + fullFlushMarkDone;\n        } finally {\n          perThread.unlock();\n          // There is a flush-all in process and this DWPT is\n          // now stale - try another one\n        }\n      }\n    }\n    throw new AlreadyClosedException(\"flush control is closed\");\n  }\n\n","sourceOld":"  ThreadState obtainAndLock() {\n    final ThreadState perThread = perThreadPool.getAndLock();\n    boolean success = false;\n    try {\n      if (perThread.isInitialized() && perThread.dwpt.deleteQueue != documentsWriter.deleteQueue) {\n        // There is a flush-all in process and this DWPT is\n        // now stale -- enroll it for flush and try for\n        // another DWPT:\n        addFlushableState(perThread);\n      }\n      success = true;\n      // simply return the ThreadState even in a flush all case sine we already hold the lock\n      return perThread;\n    } finally {\n      if (!success) { // make sure we unlock if this fails\n        perThreadPool.release(perThread);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49f1924bd448393fbdfef8b5ebed799f938169d3","date":1600069616,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  DocumentsWriterPerThread obtainAndLock() {\n    while (closed == false) {\n      final DocumentsWriterPerThread perThread = perThreadPool.getAndLock();\n      if (perThread.deleteQueue == documentsWriter.deleteQueue) {\n        // simply return the DWPT even in a flush all case since we already hold the lock and the DWPT is not stale\n        // since it has the current delete queue associated with it. This means we have established a happens-before\n        // relationship and all docs indexed into this DWPT are guaranteed to not be flushed with the currently\n        // progress full flush.\n        return perThread;\n      } else {\n        try {\n          // we must first assert otherwise the full flush might make progress once we unlock the dwpt\n          assert fullFlush && fullFlushMarkDone == false :\n              \"found a stale DWPT but full flush mark phase is already done fullFlush: \"\n                  + fullFlush  + \" markDone: \" + fullFlushMarkDone;\n        } finally {\n          perThread.unlock();\n          // There is a flush-all in process and this DWPT is\n          // now stale - try another one\n        }\n      }\n    }\n    throw new AlreadyClosedException(\"flush control is closed\");\n  }\n\n","sourceOld":"  DocumentsWriterPerThread obtainAndLock() throws IOException {\n    while (closed == false) {\n      final DocumentsWriterPerThread perThread = perThreadPool.getAndLock();\n      if (perThread.deleteQueue == documentsWriter.deleteQueue) {\n        // simply return the DWPT even in a flush all case since we already hold the lock and the DWPT is not stale\n        // since it has the current delete queue associated with it. This means we have established a happens-before\n        // relationship and all docs indexed into this DWPT are guaranteed to not be flushed with the currently\n        // progress full flush.\n        return perThread;\n      } else {\n        try {\n          // we must first assert otherwise the full flush might make progress once we unlock the dwpt\n          assert fullFlush && fullFlushMarkDone == false :\n              \"found a stale DWPT but full flush mark phase is already done fullFlush: \"\n                  + fullFlush  + \" markDone: \" + fullFlushMarkDone;\n        } finally {\n          perThread.unlock();\n          // There is a flush-all in process and this DWPT is\n          // now stale - try another one\n        }\n      }\n    }\n    throw new AlreadyClosedException(\"flush control is closed\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcf8f79417865e5028d753e669fae06457e8369","date":1600073240,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#obtainAndLock().mjava","sourceNew":"  DocumentsWriterPerThread obtainAndLock() {\n    while (closed == false) {\n      final DocumentsWriterPerThread perThread = perThreadPool.getAndLock();\n      if (perThread.deleteQueue == documentsWriter.deleteQueue) {\n        // simply return the DWPT even in a flush all case since we already hold the lock and the DWPT is not stale\n        // since it has the current delete queue associated with it. This means we have established a happens-before\n        // relationship and all docs indexed into this DWPT are guaranteed to not be flushed with the currently\n        // progress full flush.\n        return perThread;\n      } else {\n        try {\n          // we must first assert otherwise the full flush might make progress once we unlock the dwpt\n          assert fullFlush && fullFlushMarkDone == false :\n              \"found a stale DWPT but full flush mark phase is already done fullFlush: \"\n                  + fullFlush  + \" markDone: \" + fullFlushMarkDone;\n        } finally {\n          perThread.unlock();\n          // There is a flush-all in process and this DWPT is\n          // now stale - try another one\n        }\n      }\n    }\n    throw new AlreadyClosedException(\"flush control is closed\");\n  }\n\n","sourceOld":"  DocumentsWriterPerThread obtainAndLock() throws IOException {\n    while (closed == false) {\n      final DocumentsWriterPerThread perThread = perThreadPool.getAndLock();\n      if (perThread.deleteQueue == documentsWriter.deleteQueue) {\n        // simply return the DWPT even in a flush all case since we already hold the lock and the DWPT is not stale\n        // since it has the current delete queue associated with it. This means we have established a happens-before\n        // relationship and all docs indexed into this DWPT are guaranteed to not be flushed with the currently\n        // progress full flush.\n        return perThread;\n      } else {\n        try {\n          // we must first assert otherwise the full flush might make progress once we unlock the dwpt\n          assert fullFlush && fullFlushMarkDone == false :\n              \"found a stale DWPT but full flush mark phase is already done fullFlush: \"\n                  + fullFlush  + \" markDone: \" + fullFlushMarkDone;\n        } finally {\n          perThread.unlock();\n          // There is a flush-all in process and this DWPT is\n          // now stale - try another one\n        }\n      }\n    }\n    throw new AlreadyClosedException(\"flush control is closed\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"264935965977b4a9e2f3920420647072c9c49176":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"49f1924bd448393fbdfef8b5ebed799f938169d3":["264935965977b4a9e2f3920420647072c9c49176"],"7af110b00ea8df9429309d83e38e0533d82e144f":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0dcf8f79417865e5028d753e669fae06457e8369":["264935965977b4a9e2f3920420647072c9c49176","49f1924bd448393fbdfef8b5ebed799f938169d3"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600","7af110b00ea8df9429309d83e38e0533d82e144f"],"6483e4260c08168709c02238ae083a51519a28dd":["839ca1793cd9a8eb5bd7c7c62918192d47972f73","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"191128ac5b85671b1671e2c857437694283b6ebf":["839ca1793cd9a8eb5bd7c7c62918192d47972f73","6483e4260c08168709c02238ae083a51519a28dd"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["839ca1793cd9a8eb5bd7c7c62918192d47972f73","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["839ca1793cd9a8eb5bd7c7c62918192d47972f73","191128ac5b85671b1671e2c857437694283b6ebf"],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"839ca1793cd9a8eb5bd7c7c62918192d47972f73":["7af110b00ea8df9429309d83e38e0533d82e144f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["191128ac5b85671b1671e2c857437694283b6ebf"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["839ca1793cd9a8eb5bd7c7c62918192d47972f73"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dcf8f79417865e5028d753e669fae06457e8369"]},"commit2Childs":{"264935965977b4a9e2f3920420647072c9c49176":["49f1924bd448393fbdfef8b5ebed799f938169d3","0dcf8f79417865e5028d753e669fae06457e8369"],"49f1924bd448393fbdfef8b5ebed799f938169d3":["0dcf8f79417865e5028d753e669fae06457e8369"],"7af110b00ea8df9429309d83e38e0533d82e144f":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","839ca1793cd9a8eb5bd7c7c62918192d47972f73"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f64b5c281a42c5a4634b39a4fcb8f21a0cba1600"],"0dcf8f79417865e5028d753e669fae06457e8369":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["6483e4260c08168709c02238ae083a51519a28dd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"f64b5c281a42c5a4634b39a4fcb8f21a0cba1600":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"839ca1793cd9a8eb5bd7c7c62918192d47972f73":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","122251c49e5a9fa95f056ea257ae3ab452099fc7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["264935965977b4a9e2f3920420647072c9c49176"],"122251c49e5a9fa95f056ea257ae3ab452099fc7":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}