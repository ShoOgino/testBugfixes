{"path":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","commits":[{"id":"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee","date":1410650745,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          byte[] buffer = new byte[8192];\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72fe0b51e0cceded28af2898cb5388a9173f8a28","date":1410651299,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          byte[] buffer = new byte[8192];\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad53237cd844da2787711b60f12768c5d6288b3b","date":1417053965,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44a0466296f4b2d9deac60e3e524628c97aa5191","date":1454532248,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir. You must pass it a clean destDir.\n   *\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir. You must pass it a clean destDir.\n   *\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir. You must pass it a clean destDir.\n   *\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(InputStream,Path).mjava","sourceNew":"  /** \n   * Convenience method unzipping zipName into destDir. You must pass it a clean destDir.\n   *\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Convenience method unzipping zipName into destDir, cleaning up \n   * destDir first.\n   * Closes the given InputStream after extracting! \n   */\n  public static void unzip(InputStream in, Path destDir) throws IOException {\n    in = new BufferedInputStream(in);\n    IOUtils.rm(destDir);\n    Files.createDirectory(destDir);\n\n    try (ZipInputStream zipInput = new ZipInputStream(in)) {\n      ZipEntry entry;\n      byte[] buffer = new byte[8192];\n      while ((entry = zipInput.getNextEntry()) != null) {\n        Path targetFile = destDir.resolve(entry.getName());\n        \n        // be on the safe side: do not rely on that directories are always extracted\n        // before their children (although this makes sense, but is it guaranteed?)\n        Files.createDirectories(targetFile.getParent());\n        if (!entry.isDirectory()) {\n          OutputStream out = Files.newOutputStream(targetFile);\n          int len;\n          while((len = zipInput.read(buffer)) >= 0) {\n            out.write(buffer, 0, len);\n          }\n          out.close();\n        }\n        zipInput.closeEntry();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a207d19eac354d649c3f0e2cce070017c78125e":["ad53237cd844da2787711b60f12768c5d6288b3b","b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["ad53237cd844da2787711b60f12768c5d6288b3b","44a0466296f4b2d9deac60e3e524628c97aa5191"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["ad53237cd844da2787711b60f12768c5d6288b3b","b470f36a9372c97283360b1304eacbde22df6c0d"],"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"72fe0b51e0cceded28af2898cb5388a9173f8a28":["509b34c7d48bc90eb4ec5e8757e0f879a19f22ee"],"ad53237cd844da2787711b60f12768c5d6288b3b":["72fe0b51e0cceded28af2898cb5388a9173f8a28"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["ad53237cd844da2787711b60f12768c5d6288b3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a207d19eac354d649c3f0e2cce070017c78125e"]},"commit2Childs":{"5a207d19eac354d649c3f0e2cce070017c78125e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["509b34c7d48bc90eb4ec5e8757e0f879a19f22ee"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"509b34c7d48bc90eb4ec5e8757e0f879a19f22ee":["72fe0b51e0cceded28af2898cb5388a9173f8a28"],"72fe0b51e0cceded28af2898cb5388a9173f8a28":["ad53237cd844da2787711b60f12768c5d6288b3b"],"ad53237cd844da2787711b60f12768c5d6288b3b":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","1e6acbaae7af722f17204ceccf0f7db5753eccf3","44a0466296f4b2d9deac60e3e524628c97aa5191"],"44a0466296f4b2d9deac60e3e524628c97aa5191":["b470f36a9372c97283360b1304eacbde22df6c0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}