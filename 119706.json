{"path":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9644a32526f2e2ae87543b00e8be543aa25f29c","date":1411548458,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      if (indexSort == null) {\n        indexSort = reader.getIndexSort();\n      } else if (indexSort.equals(reader.getIndexSort()) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + reader.getIndexSort());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0576f276762c4cd4dbc7b33fada4a5d22abf2aa3","date":1462872662,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      if (indexSort == null) {\n        indexSort = reader.getIndexSort();\n      } else if (indexSort.equals(reader.getIndexSort()) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + reader.getIndexSort());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      Sort leafIndexSort = reader.getIndexSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    this.indexSort = indexSort;\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b6f36bb733c575dd04fdfa785127ebf82b0033f","date":1497502741,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n    \n    // build Fields instance\n    for (final LeafReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      for (String field : readerFields) {\n        // only add if the reader responsible for that field name is the current:\n        if (fieldToReader.get(field) == reader) {\n          this.fields.addField(field, readerFields.terms(field));\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b213cb4b7b825687d73e7ec995c615eb0cf68305","date":1510236177,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    final String softDeletesField = completeReaderSet.stream()\n        .map(r -> r.getFieldInfos().getSoftDeletesField())\n        .filter(Objects::nonNull).findAny().orElse(null);\n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder(new FieldInfos.FieldNumbers(softDeletesField));\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    final String softDeletesField = completeReaderSet.stream()\n        .map(r -> r.getFieldInfos().getSoftDeletesField())\n        .filter(Objects::nonNull).findAny().orElse(null);\n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder(new FieldInfos.FieldNumbers(softDeletesField));\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader#ParallelLeafReader(boolean,LeafReader[],LeafReader[]).mjava","sourceNew":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    final String softDeletesField = completeReaderSet.stream()\n        .map(r -> r.getFieldInfos().getSoftDeletesField())\n        .filter(Objects::nonNull).findAny().orElse(null);\n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder(new FieldInfos.FieldNumbers(softDeletesField));\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelLeafReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelLeafReader(boolean closeSubReaders, LeafReader[] readers, LeafReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final LeafReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(LeafReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n\n    Sort indexSort = null;\n    int createdVersionMajor = -1;\n\n    // build FieldInfos and fieldToReader map:\n    for (final LeafReader reader : this.parallelReaders) {\n      LeafMetaData leafMetaData = reader.getMetaData();\n      \n      Sort leafIndexSort = leafMetaData.getSort();\n      if (indexSort == null) {\n        indexSort = leafIndexSort;\n      } else if (leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different index sorts: saw both sort=\" + indexSort + \" and \" + leafIndexSort);\n      }\n\n      if (createdVersionMajor == -1) {\n        createdVersionMajor = leafMetaData.getCreatedVersionMajor();\n      } else if (createdVersionMajor != leafMetaData.getCreatedVersionMajor()) {\n        throw new IllegalArgumentException(\"cannot combine LeafReaders that have different creation versions: saw both version=\" + createdVersionMajor + \" and \" + leafMetaData.getCreatedVersionMajor());\n      }\n\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo, fieldInfo.getDocValuesGen());\n          fieldToReader.put(fieldInfo.name, reader);\n          // only add these if the reader responsible for that field name is the current:\n          // TODO consider populating 1st leaf with vectors even if the field name has been seen on a previous leaf\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n          // TODO consider populating 1st leaf with terms even if the field name has been seen on a previous leaf\n          if (fieldInfo.getIndexOptions() != IndexOptions.NONE) {\n            termsFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    if (createdVersionMajor == -1) {\n      // empty reader\n      createdVersionMajor = Version.LATEST.major;\n    }\n\n    Version minVersion = Version.LATEST;\n    for (final LeafReader reader : this.parallelReaders) {\n      Version leafVersion = reader.getMetaData().getMinVersion();\n      if (leafVersion == null) {\n        minVersion = null;\n        break;\n      } else if (minVersion.onOrAfter(leafVersion)) {\n        minVersion = leafVersion;\n      }\n    }\n\n    fieldInfos = builder.finish();\n    this.metaData = new LeafMetaData(createdVersionMajor, minVersion, indexSort);\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (LeafReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c9644a32526f2e2ae87543b00e8be543aa25f29c":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"2b6f36bb733c575dd04fdfa785127ebf82b0033f":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"0ad30c6a479e764150a3316e57263319775f1df2":["8028ab7a24273833d53d35eb160dba5b57283cf5","3d33e731a93d4b57e662ff094f64f94a745422d4"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["31741cf1390044e38a2ec3127cf302ba841bfd75","2b6f36bb733c575dd04fdfa785127ebf82b0033f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8028ab7a24273833d53d35eb160dba5b57283cf5","d470c8182e92b264680e34081b75e70a9f2b3c89"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["8028ab7a24273833d53d35eb160dba5b57283cf5","0ad30c6a479e764150a3316e57263319775f1df2"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"b213cb4b7b825687d73e7ec995c615eb0cf68305":["28288370235ed02234a64753cdbf0c6ec096304a"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["b213cb4b7b825687d73e7ec995c615eb0cf68305","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["b213cb4b7b825687d73e7ec995c615eb0cf68305"],"0576f276762c4cd4dbc7b33fada4a5d22abf2aa3":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["8028ab7a24273833d53d35eb160dba5b57283cf5","0576f276762c4cd4dbc7b33fada4a5d22abf2aa3"],"f592209545c71895260367152601e9200399776d":["b213cb4b7b825687d73e7ec995c615eb0cf68305","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","2b6f36bb733c575dd04fdfa785127ebf82b0033f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"]},"commit2Childs":{"c9644a32526f2e2ae87543b00e8be543aa25f29c":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"2b6f36bb733c575dd04fdfa785127ebf82b0033f":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"28288370235ed02234a64753cdbf0c6ec096304a":["b213cb4b7b825687d73e7ec995c615eb0cf68305"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"31741cf1390044e38a2ec3127cf302ba841bfd75":["2b6f36bb733c575dd04fdfa785127ebf82b0033f","28288370235ed02234a64753cdbf0c6ec096304a"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"b213cb4b7b825687d73e7ec995c615eb0cf68305":["b70042a8a492f7054d480ccdd2be9796510d4327","b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["0576f276762c4cd4dbc7b33fada4a5d22abf2aa3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0576f276762c4cd4dbc7b33fada4a5d22abf2aa3":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"f592209545c71895260367152601e9200399776d":[],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}