{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a80994db3380cd78c6f65b84515e2e931b6b3da","date":1329530403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        if (req.getParams().getBool(SEEN_LEADER, false)) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8b4dc0cb506204097b6e34b962947988b60e5d0","date":1342976066,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","date":1342989037,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            for (ZkCoreNodeProps props : replicaProps) {\n              nodes.add(new StdNode(props));\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getCloudState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getCloudState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n       \n        doDefensiveChecks(shardId, phase);\n     \n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n       \n        doDefensiveChecks(shardId, phase);\n     \n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      // the leader is...\n      // TODO: if there is no leader, wait and look again\n      // TODO: we are reading the leader from zk every time - we should cache\n      // this and watch for changes?? Just pull it from ZkController cluster state probably?\n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        // TODO: if we find out we cannot talk to zk anymore, we should probably realize we are not\n        // a leader anymore - we shouldn't accept updates at all??\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89f828d954597b98a28942874636f35c719b8a5d","date":1354471211,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":null,"sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n       \n        doDefensiveChecks(shardId, phase);\n     \n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(int).mjava","sourceNew":null,"sourceOld":"  private List<Node> setupRequest(int hash) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n      // set num nodes\n      numNodes = zkController.getClusterState().getLiveNodes().size();\n      \n      String shardId = getShard(hash, collection, zkController.getClusterState()); // get the right shard based on the hash...\n\n      try {\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n        \n        String leaderNodeName = leaderProps.getCoreNodeName();\n        String coreName = req.getCore().getName();\n        String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n        isLeader = coreNodeName.equals(leaderNodeName);\n        \n        DistribPhase phase = \n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n       \n        doDefensiveChecks(shardId, phase);\n     \n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n            \n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n          \n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n        \n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89f828d954597b98a28942874636f35c719b8a5d":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"407687e67faf6e1f02a211ca078d8e3eed631027":["6013b4c7388f1627659c8f96c44abd10a294d3a6","89f828d954597b98a28942874636f35c719b8a5d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","3f767f8c99eaedb984df754fe61f21c5de260f94"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["d6f074e73200c07d54f242d3880a8da5a35ff97b","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["b8b4dc0cb506204097b6e34b962947988b60e5d0"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","3f767f8c99eaedb984df754fe61f21c5de260f94"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"b8b4dc0cb506204097b6e34b962947988b60e5d0":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89f828d954597b98a28942874636f35c719b8a5d"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["3a80994db3380cd78c6f65b84515e2e931b6b3da"]},"commit2Childs":{"89f828d954597b98a28942874636f35c719b8a5d":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["89f828d954597b98a28942874636f35c719b8a5d","407687e67faf6e1f02a211ca078d8e3eed631027","05a14b2611ead08655a2b2bdc61632eb31316e57"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","6013b4c7388f1627659c8f96c44abd10a294d3a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["3f767f8c99eaedb984df754fe61f21c5de260f94","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","3a80994db3380cd78c6f65b84515e2e931b6b3da"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"b8b4dc0cb506204097b6e34b962947988b60e5d0":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"3a80994db3380cd78c6f65b84515e2e931b6b3da":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","b8b4dc0cb506204097b6e34b962947988b60e5d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","8fd5be977c105554c6a7b68afcdbc511439723ab","05a14b2611ead08655a2b2bdc61632eb31316e57","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}