{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.SegmentEndpoint#SegmentEndpoint(GeoPoint,SidedPlane,SidedPlane,GeoPoint,GeoPoint,GeoPoint,GeoPoint,SidedPlane,SidedPlane,SidedPlane,SidedPlane).mjava","commits":[{"id":"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68","date":1433421165,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.SegmentEndpoint#SegmentEndpoint(GeoPoint,SidedPlane,SidedPlane,GeoPoint,GeoPoint,GeoPoint,GeoPoint,SidedPlane,SidedPlane,SidedPlane,SidedPlane).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.SegmentEndpoint#SegmentEndpoint(GeoPoint,SidedPlane,SidedPlane,GeoPoint,GeoPoint,GeoPoint,GeoPoint).mjava","sourceNew":"    /** Constructor for case (3).\n     * Generate an endpoint for an intersection, given four points.\n     */\n    public SegmentEndpoint(final GeoPoint point,\n      final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,\n      final GeoPoint notCand2Point, final GeoPoint notCand1Point,\n      final GeoPoint notCand3Point, final GeoPoint notCand4Point,\n      final SidedPlane candidate1, final SidedPlane candidate2, final SidedPlane candidate3, final SidedPlane candidate4) {\n      // Note: What we really need is a single plane that goes through all four points.\n      // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we\n      // need an approximation that at least creates a boundary that has no interruptions.\n      // There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge\n      // intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if\n      // the angle between segments is acute.\n      // The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from\n      // the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side\n      // PROVIDED that the other point is within the final circle we come up with.\n      this.point = point;\n      \n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      // (Constructed beforehand because we need them for degeneracy check)\n\n      final boolean cand1IsOtherWithin = candidate1!=null?candidate1.isWithin(notCand1Point):false;\n      final boolean cand2IsOtherWithin = candidate2!=null?candidate2.isWithin(notCand2Point):false;\n      final boolean cand3IsOtherWithin = candidate3!=null?candidate3.isWithin(notCand3Point):false;\n      final boolean cand4IsOtherWithin = candidate4!=null?candidate4.isWithin(notCand4Point):false;\n      \n      if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {\n        // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.\n        this.circlePlane = candidate1;  // doesn't matter which\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand1Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};\n      } else if (cand1IsOtherWithin) {\n        // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list\n        this.circlePlane = candidate1;\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand2IsOtherWithin) {\n        // Use candidate2\n        this.circlePlane = candidate2;\n        this.notablePoints = new GeoPoint[]{notCand3Point, notCand4Point, notCand1Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand3IsOtherWithin) {\n        this.circlePlane = candidate3;\n        this.notablePoints = new GeoPoint[]{notCand4Point, notCand1Point, notCand2Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else if (cand4IsOtherWithin) {\n        this.circlePlane = candidate4;\n        this.notablePoints = new GeoPoint[]{notCand1Point, notCand2Point, notCand3Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else {\n        // dunno what happened\n        throw new RuntimeException(\"Couldn't come up with a plane through three points that included the fourth\");\n      }\n    }\n\n","sourceOld":"    /** Constructor for case (3).\n     * Generate an endpoint for an intersection, given four points.\n     */\n    public SegmentEndpoint(final GeoPoint point,\n      final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,\n      final GeoPoint prevUpperGeoPoint, final GeoPoint prevLowerGeoPoint,\n      final GeoPoint nextUpperGeoPoint, final GeoPoint nextLowerGeoPoint) {\n      // Note: What we really need is a single plane that goes through all four points.\n      // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we\n      // need an approximation that at least creates a boundary that has no interruptions.\n      // There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge\n      // intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if\n      // the angle between segments is acute.\n      // The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from\n      // the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side\n      // PROVIDED that the other point is within the final circle we come up with.\n      this.point = point;\n      \n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      final SidedPlane candidate1 = SidedPlane.constructNormalizedThreePointSidedPlane(point, prevUpperGeoPoint, nextUpperGeoPoint, nextLowerGeoPoint);\n      final SidedPlane candidate2 = SidedPlane.constructNormalizedThreePointSidedPlane(point, nextUpperGeoPoint, nextLowerGeoPoint, prevLowerGeoPoint);\n      final SidedPlane candidate3 = SidedPlane.constructNormalizedThreePointSidedPlane(point, nextLowerGeoPoint, prevLowerGeoPoint, prevUpperGeoPoint);\n      final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(point, prevLowerGeoPoint, prevUpperGeoPoint, nextUpperGeoPoint);\n\n      final boolean cand1IsOtherWithin = candidate1.isWithin(prevLowerGeoPoint);\n      final boolean cand2IsOtherWithin = candidate2.isWithin(prevUpperGeoPoint);\n      final boolean cand3IsOtherWithin = candidate3.isWithin(nextUpperGeoPoint);\n      final boolean cand4IsOtherWithin = candidate4.isWithin(nextLowerGeoPoint);\n      \n      if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {\n        // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.\n        this.circlePlane = candidate1;  // doesn't matter which\n        this.notablePoints = new GeoPoint[]{prevUpperGeoPoint, nextUpperGeoPoint, prevLowerGeoPoint, nextLowerGeoPoint};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};\n      } else if (cand1IsOtherWithin) {\n        // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list\n        this.circlePlane = candidate1;\n        this.notablePoints = new GeoPoint[]{prevUpperGeoPoint, nextUpperGeoPoint, nextLowerGeoPoint};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand2IsOtherWithin) {\n        // Use candidate2\n        this.circlePlane = candidate2;\n        this.notablePoints = new GeoPoint[]{nextUpperGeoPoint, nextLowerGeoPoint, prevLowerGeoPoint};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand3IsOtherWithin) {\n        this.circlePlane = candidate3;\n        this.notablePoints = new GeoPoint[]{nextLowerGeoPoint, prevLowerGeoPoint, prevUpperGeoPoint};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else if (cand4IsOtherWithin) {\n        this.circlePlane = candidate4;\n        this.notablePoints = new GeoPoint[]{prevLowerGeoPoint, prevUpperGeoPoint, nextUpperGeoPoint};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else {\n        // dunno what happened\n        throw new RuntimeException(\"Couldn't come up with a plane through three points that included the fourth\");\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3022be5842502b7c2a57a5124199bbc30236f0a0","date":1436724252,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath.SegmentEndpoint#SegmentEndpoint(GeoPoint,SidedPlane,SidedPlane,GeoPoint,GeoPoint,GeoPoint,GeoPoint,SidedPlane,SidedPlane,SidedPlane,SidedPlane).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.SegmentEndpoint#SegmentEndpoint(GeoPoint,SidedPlane,SidedPlane,GeoPoint,GeoPoint,GeoPoint,GeoPoint,SidedPlane,SidedPlane,SidedPlane,SidedPlane).mjava","sourceNew":"    /** Constructor for case (3).\n     * Generate an endpoint for an intersection, given four points.\n     */\n    public SegmentEndpoint(final GeoPoint point,\n      final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,\n      final GeoPoint notCand2Point, final GeoPoint notCand1Point,\n      final GeoPoint notCand3Point, final GeoPoint notCand4Point,\n      final SidedPlane candidate1, final SidedPlane candidate2, final SidedPlane candidate3, final SidedPlane candidate4) {\n      // Note: What we really need is a single plane that goes through all four points.\n      // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we\n      // need an approximation that at least creates a boundary that has no interruptions.\n      // There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge\n      // intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if\n      // the angle between segments is acute.\n      // The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from\n      // the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side\n      // PROVIDED that the other point is within the final circle we come up with.\n      this.point = point;\n      \n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      // (Constructed beforehand because we need them for degeneracy check)\n\n      final boolean cand1IsOtherWithin = candidate1!=null?candidate1.isWithin(notCand1Point):false;\n      final boolean cand2IsOtherWithin = candidate2!=null?candidate2.isWithin(notCand2Point):false;\n      final boolean cand3IsOtherWithin = candidate3!=null?candidate3.isWithin(notCand3Point):false;\n      final boolean cand4IsOtherWithin = candidate4!=null?candidate4.isWithin(notCand4Point):false;\n      \n      if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {\n        // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.\n        this.circlePlane = candidate1;  // doesn't matter which\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand1Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};\n      } else if (cand1IsOtherWithin) {\n        // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list\n        this.circlePlane = candidate1;\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand2IsOtherWithin) {\n        // Use candidate2\n        this.circlePlane = candidate2;\n        this.notablePoints = new GeoPoint[]{notCand3Point, notCand4Point, notCand1Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand3IsOtherWithin) {\n        this.circlePlane = candidate3;\n        this.notablePoints = new GeoPoint[]{notCand4Point, notCand1Point, notCand2Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else if (cand4IsOtherWithin) {\n        this.circlePlane = candidate4;\n        this.notablePoints = new GeoPoint[]{notCand1Point, notCand2Point, notCand3Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else {\n        // dunno what happened\n        throw new RuntimeException(\"Couldn't come up with a plane through three points that included the fourth\");\n      }\n    }\n\n","sourceOld":"    /** Constructor for case (3).\n     * Generate an endpoint for an intersection, given four points.\n     */\n    public SegmentEndpoint(final GeoPoint point,\n      final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,\n      final GeoPoint notCand2Point, final GeoPoint notCand1Point,\n      final GeoPoint notCand3Point, final GeoPoint notCand4Point,\n      final SidedPlane candidate1, final SidedPlane candidate2, final SidedPlane candidate3, final SidedPlane candidate4) {\n      // Note: What we really need is a single plane that goes through all four points.\n      // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we\n      // need an approximation that at least creates a boundary that has no interruptions.\n      // There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge\n      // intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if\n      // the angle between segments is acute.\n      // The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from\n      // the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side\n      // PROVIDED that the other point is within the final circle we come up with.\n      this.point = point;\n      \n      // We construct four separate planes, and evaluate which one includes all interior points with least overlap\n      // (Constructed beforehand because we need them for degeneracy check)\n\n      final boolean cand1IsOtherWithin = candidate1!=null?candidate1.isWithin(notCand1Point):false;\n      final boolean cand2IsOtherWithin = candidate2!=null?candidate2.isWithin(notCand2Point):false;\n      final boolean cand3IsOtherWithin = candidate3!=null?candidate3.isWithin(notCand3Point):false;\n      final boolean cand4IsOtherWithin = candidate4!=null?candidate4.isWithin(notCand4Point):false;\n      \n      if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {\n        // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.\n        this.circlePlane = candidate1;  // doesn't matter which\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand1Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};\n      } else if (cand1IsOtherWithin) {\n        // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list\n        this.circlePlane = candidate1;\n        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand4Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand2IsOtherWithin) {\n        // Use candidate2\n        this.circlePlane = candidate2;\n        this.notablePoints = new GeoPoint[]{notCand3Point, notCand4Point, notCand1Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};\n      } else if (cand3IsOtherWithin) {\n        this.circlePlane = candidate3;\n        this.notablePoints = new GeoPoint[]{notCand4Point, notCand1Point, notCand2Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else if (cand4IsOtherWithin) {\n        this.circlePlane = candidate4;\n        this.notablePoints = new GeoPoint[]{notCand1Point, notCand2Point, notCand3Point};\n        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};\n      } else {\n        // dunno what happened\n        throw new RuntimeException(\"Couldn't come up with a plane through three points that included the fourth\");\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3022be5842502b7c2a57a5124199bbc30236f0a0":["060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3022be5842502b7c2a57a5124199bbc30236f0a0"],"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68"],"3022be5842502b7c2a57a5124199bbc30236f0a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"060a67f43d4cf2cf41e6cad01dc1a4222fcc7e68":["3022be5842502b7c2a57a5124199bbc30236f0a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}