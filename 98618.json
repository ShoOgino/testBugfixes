{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  private void intersect(IntersectState state,\n                        int nodeID,\n                        byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    //System.out.println(\"\\nR: intersect nodeID=\" + nodeID + \" cellMin=\" + BKDUtil.bytesToInt(cellMinPacked, 0) + \" cellMax=\" + BKDUtil.bytesToInt(cellMaxPacked, 0));\n\n    // Optimization: only check the visitor when the current cell does not fully contain the bbox.  E.g. if the\n    // query is a small area around London, UK, most of the high nodes in the BKD tree as we recurse will fully\n    // contain the query, so we quickly recurse down until the nodes cross the query:\n    boolean cellContainsQuery = BKDUtil.contains(bytesPerDim,\n                                                 cellMinPacked, cellMaxPacked,\n                                                 state.minPacked, state.maxPacked);\n\n    //System.out.println(\"R: cellContainsQuery=\" + cellContainsQuery);\n\n    if (cellContainsQuery == false) {\n\n      Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n      //System.out.println(\"R: relation=\" + r);\n\n      if (r == Relation.QUERY_OUTSIDE_CELL) {\n        // This cell is fully outside of the query shape: stop recursing\n        return;\n      } else if (r == Relation.CELL_INSIDE_QUERY) {\n        // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n        addAll(state, nodeID);\n        return;\n      } else {\n        // The cell crosses the shape boundary, so we fall through and do full filtering\n      }\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n\n      state.in.seek(leafBlockFPs[nodeID-leafNodeOffset]);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      // TODO: we could maybe pollute the IntersectVisitor API with a \"grow\" method if this maybe helps perf\n      // enough (it did before, esp. for the 1D case):\n      //state.docs.grow(count);\n      int docID = 0;\n      for(int i=0;i<count;i++) {\n        docID += state.in.readVInt();\n        state.scratchDocIDs[i] = docID;\n      }\n\n      // Again, this time reading values and checking with the visitor\n      for(int i=0;i<count;i++) {\n        state.in.readBytes(state.scratchPackedValue, 0, state.scratchPackedValue.length);\n        state.visitor.visit(state.scratchDocIDs[i], state.scratchPackedValue);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      if (BKDUtil.compare(bytesPerDim, state.minPacked, splitDim, splitValue, 0) <= 0) {\n        // The query bbox overlaps our left cell, so we must recurse:\n        System.arraycopy(state.maxPacked, 0, splitPackedValue, 0, packedBytesLength);\n        System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n        intersect(state,\n                  2*nodeID,\n                  cellMinPacked, splitPackedValue);\n      }\n\n      if (BKDUtil.compare(bytesPerDim, state.maxPacked, splitDim, splitValue, 0) >= 0) {\n        // The query bbox overlaps our left cell, so we must recurse:\n        System.arraycopy(state.minPacked, 0, splitPackedValue, 0, packedBytesLength);\n        System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n        intersect(state,\n                  2*nodeID+1,\n                  splitPackedValue, cellMaxPacked);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.QUERY_OUTSIDE_CELL) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                        int nodeID,\n                        byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    //System.out.println(\"\\nR: intersect nodeID=\" + nodeID + \" cellMin=\" + BKDUtil.bytesToInt(cellMinPacked, 0) + \" cellMax=\" + BKDUtil.bytesToInt(cellMaxPacked, 0));\n\n    // Optimization: only check the visitor when the current cell does not fully contain the bbox.  E.g. if the\n    // query is a small area around London, UK, most of the high nodes in the BKD tree as we recurse will fully\n    // contain the query, so we quickly recurse down until the nodes cross the query:\n    boolean cellContainsQuery = BKDUtil.contains(bytesPerDim,\n                                                 cellMinPacked, cellMaxPacked,\n                                                 state.minPacked, state.maxPacked);\n\n    //System.out.println(\"R: cellContainsQuery=\" + cellContainsQuery);\n\n    if (cellContainsQuery == false) {\n\n      Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n      //System.out.println(\"R: relation=\" + r);\n\n      if (r == Relation.QUERY_OUTSIDE_CELL) {\n        // This cell is fully outside of the query shape: stop recursing\n        return;\n      } else if (r == Relation.CELL_INSIDE_QUERY) {\n        // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n        addAll(state, nodeID);\n        return;\n      } else {\n        // The cell crosses the shape boundary, so we fall through and do full filtering\n      }\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n\n      state.in.seek(leafBlockFPs[nodeID-leafNodeOffset]);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      // TODO: we could maybe pollute the IntersectVisitor API with a \"grow\" method if this maybe helps perf\n      // enough (it did before, esp. for the 1D case):\n      //state.docs.grow(count);\n      int docID = 0;\n      for(int i=0;i<count;i++) {\n        docID += state.in.readVInt();\n        state.scratchDocIDs[i] = docID;\n      }\n\n      // Again, this time reading values and checking with the visitor\n      for(int i=0;i<count;i++) {\n        state.in.readBytes(state.scratchPackedValue, 0, state.scratchPackedValue.length);\n        state.visitor.visit(state.scratchDocIDs[i], state.scratchPackedValue);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      if (BKDUtil.compare(bytesPerDim, state.minPacked, splitDim, splitValue, 0) <= 0) {\n        // The query bbox overlaps our left cell, so we must recurse:\n        System.arraycopy(state.maxPacked, 0, splitPackedValue, 0, packedBytesLength);\n        System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n        intersect(state,\n                  2*nodeID,\n                  cellMinPacked, splitPackedValue);\n      }\n\n      if (BKDUtil.compare(bytesPerDim, state.maxPacked, splitDim, splitValue, 0) >= 0) {\n        // The query bbox overlaps our left cell, so we must recurse:\n        System.arraycopy(state.minPacked, 0, splitPackedValue, 0, packedBytesLength);\n        System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n        intersect(state,\n                  2*nodeID+1,\n                  splitPackedValue, cellMaxPacked);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"FILTER\");\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.QUERY_OUTSIDE_CELL) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9f70b31079ec002469ee49df3b8f9bd8d10df23","date":1447755747,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"FILTER\");\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"FILTER\");\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      //System.out.println(\"FILTER\");\n      // Leaf node; scan and filter all points in this block:\n      int count = readDocIDs(state.in, leafBlockFPs[nodeID-leafNodeOffset], state.scratchDocIDs);\n\n      // Again, this time reading values and checking with the visitor\n      visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitValue = new byte[bytesPerDim];\n      System.arraycopy(splitPackedValues, address+1, splitValue, 0, bytesPerDim);\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitValue, 0, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd630fded84c5695bd4e07bda0a20634517a4224","date":1476795950,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim = numDims == 1 ? 0 : splitPackedValues[address++] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef","date":1476800106,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim = numDims == 1 ? 0 : splitPackedValues[address++] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim = numDims == 1 ? 0 : splitPackedValues[address++] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * (bytesPerDim+1);\n      int splitDim = splitPackedValues[address] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address+1, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313b9c84057c3a31294cbcd794ea84c4e81646d9","date":1478080099,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n        if (version < BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D) {\n          // skip over wastefully encoded 0 splitDim:\n          assert splitPackedValues[address] == 0;\n          address++;\n        }\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim = numDims == 1 ? 0 : splitPackedValues[address++] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n        if (version < BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D) {\n          // skip over wastefully encoded 0 splitDim:\n          assert splitPackedValues[address] == 0;\n          address++;\n        }\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      // TODO: save the unused 1 byte prefix (it's always 0) in the 1d case here:\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim = numDims == 1 ? 0 : splitPackedValues[address++] & 0xff;\n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      // TODO: can we alloc & reuse this up front?\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n        if (version < BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D) {\n          // skip over wastefully encoded 0 splitDim:\n          assert splitPackedValues[address] == 0;\n          address++;\n        }\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,int,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state,\n                         int nodeID,\n                         byte[] cellMinPacked, byte[] cellMaxPacked)\n    throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + nodeID);\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, nodeID);\n      return;\n    } else {\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering\n    }\n\n    if (nodeID >= leafNodeOffset) {\n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n\n      int leafID = nodeID - leafNodeOffset;\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, leafBlockFPs[leafID], state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n\n      int address = nodeID * bytesPerIndexEntry;\n      int splitDim;\n      if (numDims == 1) {\n        splitDim = 0;\n        if (version < BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D) {\n          // skip over wastefully encoded 0 splitDim:\n          assert splitPackedValues[address] == 0;\n          address++;\n        }\n      } else {\n        splitDim = splitPackedValues[address++] & 0xff;\n      }\n      \n      assert splitDim < numDims;\n\n      // TODO: can we alloc & reuse this up front?\n\n      byte[] splitPackedValue = new byte[packedBytesLength];\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID,\n                cellMinPacked, splitPackedValue);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitPackedValues, address, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      intersect(state,\n                2*nodeID+1,\n                splitPackedValue, cellMaxPacked);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["b9f70b31079ec002469ee49df3b8f9bd8d10df23"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","313b9c84057c3a31294cbcd794ea84c4e81646d9"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["313b9c84057c3a31294cbcd794ea84c4e81646d9"],"b9f70b31079ec002469ee49df3b8f9bd8d10df23":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd630fded84c5695bd4e07bda0a20634517a4224":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"9856095f7afb5a607bf5e65077615ed91273508c":["9720b151fde2073f4e401450f4574e5f31c2d0ff","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966","dd630fded84c5695bd4e07bda0a20634517a4224"]},"commit2Childs":{"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","dd630fded84c5695bd4e07bda0a20634517a4224","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["9856095f7afb5a607bf5e65077615ed91273508c"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["b9f70b31079ec002469ee49df3b8f9bd8d10df23"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9720b151fde2073f4e401450f4574e5f31c2d0ff"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b9f70b31079ec002469ee49df3b8f9bd8d10df23":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"dd630fded84c5695bd4e07bda0a20634517a4224":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["9720b151fde2073f4e401450f4574e5f31c2d0ff","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","313b9c84057c3a31294cbcd794ea84c4e81646d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}