{"path":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      DocValuesField valuesField = null;\n      if (canUseIDV) {\n        valuesField = new DocValuesField(\"group\", new BytesRef(), valueType);\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["fa0f44f887719e97183771e977cfc4bfb485b766","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean preFlex = \"Lucene3x\".equals(w.w.getConfig().getCodec().getName());\n      boolean canUseIDV = !preFlex;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = !preFlex;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newField(\"group\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newField(\"sort1\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newField(\"sort2\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newField(\"sort3\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newField(\"content\", \"\", TextField.TYPE_UNSTORED);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["a78a90fc9701e511308346ea29f4f5e548bb39fe","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b","date":1341673943,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(\"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(\"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f45457a742a53533c348c4b990b1c579ff364467","date":1353197071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"854f97cd3613b9579fba83755c80b697e2f3993f","date":1353527621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BINARY:\n          valuesField = new StraightBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BINARY:\n          valuesField = new StraightBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      Type valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BYTES_VAR_DEREF:\n          valuesField = new DerefBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_STRAIGHT:\n          valuesField = new StraightBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        case BYTES_VAR_SORTED:\n          valuesField = new SortedBytesDocValuesField(\"group\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final int[] docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < docIdToFieldId.length; i++) {\n        int fieldId = docIdToFieldId[i];\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId[hit.doc]];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId[hit.doc]);\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId[actualGroupHeads[i]];\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","629c38c4ae4e303d0617e05fbfe508140b32f0a3","7528ec8c6e88061e2e6af98c4ae1f72a30f180b2","4e622d1d7e4496e3a8c1709c84e5be91ced69889"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97d4692d0c601ff773f0a2231967312428a904e4","date":1366026608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<BytesRef>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      boolean canUseIDV = true;\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      if (canUseIDV) {\n        switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n        }\n        doc.add(valuesField);\n      }\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          if (canUseIDV) {\n            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n          }\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n        if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {\n          canUseIDV = false;\n        } else {\n          canUseIDV = true;\n        }\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup, canUseIDV, valueType);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392","date":1377503666,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = _TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = _TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = _TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = _TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[_TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54e3893378c69acef0a7c85bd25c43aeea3249c4","date":1394442120,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","date":1394564625,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);\n          for (int i = 0; i < expectedGroupHeads.length; i++) {\n            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);\n          }\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee2e49d7d238ef272447503afe1249fa73b41646","date":1399823449,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9274621789ce990dbfef455dabdf026bb3184821","date":1400046684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","f45457a742a53533c348c4b990b1c579ff364467","4e622d1d7e4496e3a8c1709c84e5be91ced69889","97d4692d0c601ff773f0a2231967312428a904e4","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","54e3893378c69acef0a7c85bd25c43aeea3249c4","8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9","b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = vts[random().nextInt(vts.length)];\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field group = newStringField(\"group\", \"\", Field.Store.NO);\n      doc.add(group);\n      Field valuesField = null;\n      switch(valueType) {\n        case BINARY:\n          valuesField = new BinaryDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        case SORTED:\n          valuesField = new SortedDocValuesField(\"group_dv\", new BytesRef());\n          break;\n        default:\n          fail(\"unhandled type\");\n      }\n      doc.add(valuesField);\n      Field sort1 = newStringField(\"sort1\", \"\", Field.Store.NO);\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = newStringField(\"sort2\", \"\", Field.Store.NO);\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = newStringField(\"sort3\", \"\", Field.Store.NO);\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          group.setStringValue(groupDoc.group.utf8ToString());\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setStringValue(groupDoc.sort1.utf8ToString());\n        sort2.setStringValue(groupDoc.sort2.utf8ToString());\n        sort3.setStringValue(groupDoc.sort3.utf8ToString());\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      // NOTE: intentional but temporary field cache insanity!\n      final FieldCache.Ints docIdToFieldId = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(r), \"id\", false);\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      try {\n        final IndexSearcher s = newSearcher(r);\n\n        for (int contentID = 0; contentID < 3; contentID++) {\n          final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n          for (ScoreDoc hit : hits) {\n            final GroupDoc gd = groupDocs[docIdToFieldId.get(hit.doc)];\n            assertTrue(gd.score == 0.0);\n            gd.score = hit.score;\n            int docId = gd.id;\n            assertEquals(docId, docIdToFieldId.get(hit.doc));\n          }\n        }\n\n        for (GroupDoc gd : groupDocs) {\n          assertTrue(gd.score != 0.0);\n        }\n\n        for (int searchIter = 0; searchIter < 100; searchIter++) {\n\n          if (VERBOSE) {\n            System.out.println(\"TEST: searchIter=\" + searchIter);\n          }\n\n          final String searchTerm = \"real\" + random().nextInt(3);\n          boolean sortByScoreOnly = random().nextBoolean();\n          Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n          AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n          s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n          int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n          int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n          // The actual group heads contains Lucene ids. Need to change them into our id value.\n          for (int i = 0; i < actualGroupHeads.length; i++) {\n            actualGroupHeads[i] = docIdToFieldId.get(actualGroupHeads[i]);\n          }\n          // Allows us the easily iterate and assert the actual and expected results.\n          Arrays.sort(expectedGroupHeads);\n          Arrays.sort(actualGroupHeads);\n\n          if (VERBOSE) {\n            System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n            System.out.println(\"Sort within group: \" + sortWithinGroup);\n            System.out.println(\"Num group: \" + numGroups);\n            System.out.println(\"Num doc: \" + numDocs);\n            System.out.println(\"\\n=== Expected: \\n\");\n            for (int expectedDocId : expectedGroupHeads) {\n              GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n              String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                      expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n=== Actual: \\n\");\n            for (int actualDocId : actualGroupHeads) {\n              GroupDoc actualGroupDoc = groupDocs[actualDocId];\n              String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n              System.out.println(\n                  String.format(Locale.ROOT,\n                      \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                      actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                      actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                  )\n              );\n            }\n            System.out.println(\"\\n===================================================================================\");\n          }\n\n          assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n        }\n      } finally {\n        QueryUtils.purgeFieldCache(r);\n      }\n\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.shutdown();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      IntField id = new IntField(\"id\", 0, Field.Store.NO);\n      doc.add(id);\n      docNoGroup.add(id);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        id.setIntValue(groupDoc.id);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26c8f23b8bf39857b187d47ee9b09e596cc6398d","date":1453159166,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = (int) docIdToFieldId.get(hit.doc);\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n      \n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          final GroupDoc gd = groupDocs[(int) docIdToFieldId.get(hit.doc)];\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n          int docId = gd.id;\n          assertEquals(docId, docIdToFieldId.get(hit.doc));\n        }\n      }\n      \n      for (GroupDoc gd : groupDocs) {\n        assertTrue(gd.score != 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = (int) docIdToFieldId.get(hit.doc);\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = (int) docIdToFieldId.get(hit.doc);\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      final NumericDocValues docIdToFieldId = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        int fieldId = (int) docIdToFieldId.get(i);\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = (int) docIdToFieldId.get(hit.doc);\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = (int) docIdToFieldId.get(actualGroupHeads[i]);\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20e94e61fe5291647346b70437617e6b6c370408","date":1483783127,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AbstractAllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","pathOld":"lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numberOfRuns = atLeast(1);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numberOfRuns = TestUtil.nextInt(random(), 3, 6);\n    for (int iter = 0; iter < numberOfRuns; iter++) {\n      if (VERBOSE) {\n        System.out.println(String.format(Locale.ROOT, \"TEST: iter=%d total=%d\", iter, numberOfRuns));\n      }\n\n      final int numDocs = TestUtil.nextInt(random(), 100, 1000) * RANDOM_MULTIPLIER;\n      final int numGroups = TestUtil.nextInt(random(), 1, numDocs);\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: numDocs=\" + numDocs + \" numGroups=\" + numGroups);\n      }\n\n      final List<BytesRef> groups = new ArrayList<>();\n      for (int i = 0; i < numGroups; i++) {\n        String randomValue;\n        do {\n          // B/c of DV based impl we can't see the difference between an empty string and a null value.\n          // For that reason we don't generate empty string groups.\n          randomValue = TestUtil.randomRealisticUnicodeString(random());\n          //randomValue = TestUtil.randomSimpleString(random());\n        } while (\"\".equals(randomValue));\n        groups.add(new BytesRef(randomValue));\n      }\n      final String[] contentStrings = new String[TestUtil.nextInt(random(), 2, 20)];\n      if (VERBOSE) {\n        System.out.println(\"TEST: create fake content\");\n      }\n      for (int contentIDX = 0; contentIDX < contentStrings.length; contentIDX++) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"real\").append(random().nextInt(3)).append(' ');\n        final int fakeCount = random().nextInt(10);\n        for (int fakeIDX = 0; fakeIDX < fakeCount; fakeIDX++) {\n          sb.append(\"fake \");\n        }\n        contentStrings[contentIDX] = sb.toString();\n        if (VERBOSE) {\n          System.out.println(\"  content=\" + sb.toString());\n        }\n      }\n\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(new MockAnalyzer(random())));\n      DocValuesType valueType = DocValuesType.SORTED;\n\n      Document doc = new Document();\n      Document docNoGroup = new Document();\n      Field valuesField = null;\n      valuesField = new SortedDocValuesField(\"group\", new BytesRef());\n      doc.add(valuesField);\n      Field sort1 = new SortedDocValuesField(\"sort1\", new BytesRef());\n      doc.add(sort1);\n      docNoGroup.add(sort1);\n      Field sort2 = new SortedDocValuesField(\"sort2\", new BytesRef());\n      doc.add(sort2);\n      docNoGroup.add(sort2);\n      Field sort3 = new SortedDocValuesField(\"sort3\", new BytesRef());\n      doc.add(sort3);\n      docNoGroup.add(sort3);\n      Field content = newTextField(\"content\", \"\", Field.Store.NO);\n      doc.add(content);\n      docNoGroup.add(content);\n      NumericDocValuesField idDV = new NumericDocValuesField(\"id\", 0);\n      doc.add(idDV);\n      docNoGroup.add(idDV);\n      final GroupDoc[] groupDocs = new GroupDoc[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        final BytesRef groupValue;\n        if (random().nextInt(24) == 17) {\n          // So we test the \"doc doesn't have the group'd\n          // field\" case:\n          groupValue = null;\n        } else {\n          groupValue = groups.get(random().nextInt(groups.size()));\n        }\n\n        final GroupDoc groupDoc = new GroupDoc(\n            i,\n            groupValue,\n            groups.get(random().nextInt(groups.size())),\n            groups.get(random().nextInt(groups.size())),\n            new BytesRef(String.format(Locale.ROOT, \"%05d\", i)),\n            contentStrings[random().nextInt(contentStrings.length)]\n        );\n\n        if (VERBOSE) {\n          System.out.println(\"  doc content=\" + groupDoc.content + \" id=\" + i + \" group=\" + (groupDoc.group == null ? \"null\" : groupDoc.group.utf8ToString()) + \" sort1=\" + groupDoc.sort1.utf8ToString() + \" sort2=\" + groupDoc.sort2.utf8ToString() + \" sort3=\" + groupDoc.sort3.utf8ToString());\n        }\n\n        groupDocs[i] = groupDoc;\n        if (groupDoc.group != null) {\n          valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));\n        }\n        sort1.setBytesValue(groupDoc.sort1);\n        sort2.setBytesValue(groupDoc.sort2);\n        sort3.setBytesValue(groupDoc.sort3);\n        content.setStringValue(groupDoc.content);\n        idDV.setLongValue(groupDoc.id);\n        if (groupDoc.group == null) {\n          w.addDocument(docNoGroup);\n        } else {\n          w.addDocument(doc);\n        }\n      }\n\n      final DirectoryReader r = w.getReader();\n      w.close();\n\n      NumericDocValues values = MultiDocValues.getNumericValues(r, \"id\");\n      final int[] docIDToFieldId = new int[numDocs];\n      final int[] fieldIdToDocID = new int[numDocs];\n      for (int i = 0; i < numDocs; i++) {\n        assertEquals(i, values.nextDoc());\n        int fieldId = (int) values.longValue();\n        docIDToFieldId[i] = fieldId;\n        fieldIdToDocID[fieldId] = i;\n      }\n\n      final IndexSearcher s = newSearcher(r);\n\n      Set<Integer> seenIDs = new HashSet<>();\n      for (int contentID = 0; contentID < 3; contentID++) {\n        final ScoreDoc[] hits = s.search(new TermQuery(new Term(\"content\", \"real\" + contentID)), numDocs).scoreDocs;\n        for (ScoreDoc hit : hits) {\n          int idValue = docIDToFieldId[hit.doc];\n          final GroupDoc gd = groupDocs[idValue];\n          assertEquals(gd.id, idValue);\n          seenIDs.add(idValue);\n          assertTrue(gd.score == 0.0);\n          gd.score = hit.score;\n        }\n      }\n\n      // make sure all groups were seen across the hits\n      assertEquals(groupDocs.length, seenIDs.size());\n\n      // make sure scores are sane\n      for (GroupDoc gd : groupDocs) {\n        assertTrue(Float.isFinite(gd.score));\n        assertTrue(gd.score >= 0.0);\n      }\n      \n      for (int searchIter = 0; searchIter < 100; searchIter++) {\n        \n        if (VERBOSE) {\n          System.out.println(\"TEST: searchIter=\" + searchIter);\n        }\n        \n        final String searchTerm = \"real\" + random().nextInt(3);\n        boolean sortByScoreOnly = random().nextBoolean();\n        Sort sortWithinGroup = getRandomSort(sortByScoreOnly);\n        AllGroupHeadsCollector<?> allGroupHeadsCollector = createRandomCollector(\"group\", sortWithinGroup);\n        s.search(new TermQuery(new Term(\"content\", searchTerm)), allGroupHeadsCollector);\n        int[] expectedGroupHeads = createExpectedGroupHeads(searchTerm, groupDocs, sortWithinGroup, sortByScoreOnly, fieldIdToDocID);\n        int[] actualGroupHeads = allGroupHeadsCollector.retrieveGroupHeads();\n        // The actual group heads contains Lucene ids. Need to change them into our id value.\n        for (int i = 0; i < actualGroupHeads.length; i++) {\n          actualGroupHeads[i] = docIDToFieldId[actualGroupHeads[i]];\n        }\n        // Allows us the easily iterate and assert the actual and expected results.\n        Arrays.sort(expectedGroupHeads);\n        Arrays.sort(actualGroupHeads);\n        \n        if (VERBOSE) {\n          System.out.println(\"Collector: \" + allGroupHeadsCollector.getClass().getSimpleName());\n          System.out.println(\"Sort within group: \" + sortWithinGroup);\n          System.out.println(\"Num group: \" + numGroups);\n          System.out.println(\"Num doc: \" + numDocs);\n          System.out.println(\"\\n=== Expected: \\n\");\n          for (int expectedDocId : expectedGroupHeads) {\n            GroupDoc expectedGroupDoc = groupDocs[expectedDocId];\n            String expectedGroup = expectedGroupDoc.group == null ? null : expectedGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    expectedGroup, expectedGroupDoc.score, expectedGroupDoc.sort1.utf8ToString(),\n                    expectedGroupDoc.sort2.utf8ToString(), expectedGroupDoc.sort3.utf8ToString(), expectedDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n=== Actual: \\n\");\n          for (int actualDocId : actualGroupHeads) {\n            GroupDoc actualGroupDoc = groupDocs[actualDocId];\n            String actualGroup = actualGroupDoc.group == null ? null : actualGroupDoc.group.utf8ToString();\n            System.out.println(\n                String.format(Locale.ROOT,\n                    \"Group:%10s score%5f Sort1:%10s Sort2:%10s Sort3:%10s doc:%5d\",\n                    actualGroup, actualGroupDoc.score, actualGroupDoc.sort1.utf8ToString(),\n                    actualGroupDoc.sort2.utf8ToString(), actualGroupDoc.sort3.utf8ToString(), actualDocId\n                    )\n                );\n          }\n          System.out.println(\"\\n===================================================================================\");\n        }\n        \n        assertArrayEquals(expectedGroupHeads, actualGroupHeads);\n      }\n      \n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["6613659748fe4411a7dcf85266e55db1f95f7315"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9274621789ce990dbfef455dabdf026bb3184821":["ee2e49d7d238ef272447503afe1249fa73b41646"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["6613659748fe4411a7dcf85266e55db1f95f7315","54e3893378c69acef0a7c85bd25c43aeea3249c4"],"2acf500f78aa12b92e371fd89c719291986b6b90":["04f07771a2a7dd3a395700665ed839c3dae2def2","b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"f45457a742a53533c348c4b990b1c579ff364467":["2acf500f78aa12b92e371fd89c719291986b6b90"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"97d4692d0c601ff773f0a2231967312428a904e4":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["26c8f23b8bf39857b187d47ee9b09e596cc6398d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"0837ab0472feecb3a54260729d845f839e1cbd72":["854f97cd3613b9579fba83755c80b697e2f3993f"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54e3893378c69acef0a7c85bd25c43aeea3249c4"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"20e94e61fe5291647346b70437617e6b6c370408":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["97d4692d0c601ff773f0a2231967312428a904e4","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"54e3893378c69acef0a7c85bd25c43aeea3249c4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","20e94e61fe5291647346b70437617e6b6c370408"],"770342641f7b505eaa8dccdc666158bff2419109":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["26c8f23b8bf39857b187d47ee9b09e596cc6398d","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"26c8f23b8bf39857b187d47ee9b09e596cc6398d":["770342641f7b505eaa8dccdc666158bff2419109"],"46d8ada1fff8d18cb197c38c7983225162599948":["04f07771a2a7dd3a395700665ed839c3dae2def2","2acf500f78aa12b92e371fd89c719291986b6b90"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["2acf500f78aa12b92e371fd89c719291986b6b90","423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","9274621789ce990dbfef455dabdf026bb3184821"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["04f07771a2a7dd3a395700665ed839c3dae2def2","2acf500f78aa12b92e371fd89c719291986b6b90"],"ee2e49d7d238ef272447503afe1249fa73b41646":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["26c8f23b8bf39857b187d47ee9b09e596cc6398d"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["97d4692d0c601ff773f0a2231967312428a904e4"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["0837ab0472feecb3a54260729d845f839e1cbd72"],"854f97cd3613b9579fba83755c80b697e2f3993f":["f45457a742a53533c348c4b990b1c579ff364467"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71da933d30aea361ccc224d6544c451cbf49916d"],"71da933d30aea361ccc224d6544c451cbf49916d":["20e94e61fe5291647346b70437617e6b6c370408"]},"commit2Childs":{"9274621789ce990dbfef455dabdf026bb3184821":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":[],"2acf500f78aa12b92e371fd89c719291986b6b90":["f45457a742a53533c348c4b990b1c579ff364467","46d8ada1fff8d18cb197c38c7983225162599948","d4d69c535930b5cce125cff868d40f6373dc27d4","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"f45457a742a53533c348c4b990b1c579ff364467":["854f97cd3613b9579fba83755c80b697e2f3993f"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["2acf500f78aa12b92e371fd89c719291986b6b90","b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"b4c18e3a5a8908e0fa2ea7c1a3507a214b70153b":["2acf500f78aa12b92e371fd89c719291986b6b90"],"97d4692d0c601ff773f0a2231967312428a904e4":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["20e94e61fe5291647346b70437617e6b6c370408","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0837ab0472feecb3a54260729d845f839e1cbd72":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["56572ec06f1407c066d6b7399413178b33176cd8","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"20e94e61fe5291647346b70437617e6b6c370408":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","71da933d30aea361ccc224d6544c451cbf49916d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","54e3893378c69acef0a7c85bd25c43aeea3249c4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"54e3893378c69acef0a7c85bd25c43aeea3249c4":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ee2e49d7d238ef272447503afe1249fa73b41646"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"770342641f7b505eaa8dccdc666158bff2419109":["26c8f23b8bf39857b187d47ee9b09e596cc6398d"],"26c8f23b8bf39857b187d47ee9b09e596cc6398d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["97d4692d0c601ff773f0a2231967312428a904e4"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"ee2e49d7d238ef272447503afe1249fa73b41646":["9274621789ce990dbfef455dabdf026bb3184821"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"df9bf66ed405ee5c7d32b47bdb36c2e36d2c1392":["6613659748fe4411a7dcf85266e55db1f95f7315","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["770342641f7b505eaa8dccdc666158bff2419109"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"854f97cd3613b9579fba83755c80b697e2f3993f":["0837ab0472feecb3a54260729d845f839e1cbd72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"71da933d30aea361ccc224d6544c451cbf49916d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","56572ec06f1407c066d6b7399413178b33176cd8","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}