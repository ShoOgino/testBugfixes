{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","commits":[{"id":"609ba4ce51a7095e9815d4fb2666ec85714f8f54","date":1456320705,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#PointInRectQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   */\n  public static Query newBoxQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    \n    byte[][] lower = encode(minLat, minLon);\n    byte[][] upper = encode(maxLat, maxLon);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLon < minLon) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /** Matches all points &gt;= minLon, minLat (inclusive) and &lt; maxLon, maxLat (exclusive). */ \n  public PointInRectQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    this.field = field;\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    this.minLon = minLon;\n    this.maxLon = maxLon;\n    this.minLat = minLat;\n    this.maxLat = maxLat;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","date":1456321728,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInRectQuery#PointInRectQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   */\n  public static Query newBoxQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    \n    byte[][] lower = encode(minLat, minLon);\n    byte[][] upper = encode(maxLat, maxLon);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLon < minLon) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /** Matches all points &gt;= minLon, minLat (inclusive) and &lt; maxLon, maxLat (exclusive). */ \n  public PointInRectQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    this.field = field;\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    this.minLon = minLon;\n    this.maxLon = maxLon;\n    this.minLat = minLat;\n    this.maxLat = maxLat;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   */\n  public static Query newBoxQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    \n    byte[][] lower = encode(minLat, minLon);\n    byte[][] upper = encode(maxLat, maxLon);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLon < minLon) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ad0d09e969f4763b0df4230f8e3f74357872a4e4","606ea169579957651185909e7264798e99e714f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":["609ba4ce51a7095e9815d4fb2666ec85714f8f54"],"bugIntro":["606ea169579957651185909e7264798e99e714f9","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":["1800b996d8677670482a071dcb7a48b08c423ace"],"bugIntro":["606ea169579957651185909e7264798e99e714f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   */\n  public static Query newBoxQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {\n    if (GeoUtils.isValidLat(minLat) == false) {\n      throw new IllegalArgumentException(\"minLat=\" + minLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLat(maxLat) == false) {\n      throw new IllegalArgumentException(\"maxLat=\" + maxLat + \" is not a valid latitude\");\n    }\n    if (GeoUtils.isValidLon(minLon) == false) {\n      throw new IllegalArgumentException(\"minLon=\" + minLon + \" is not a valid longitude\");\n    }\n    if (GeoUtils.isValidLon(maxLon) == false) {\n      throw new IllegalArgumentException(\"maxLon=\" + maxLon + \" is not a valid longitude\");\n    }\n    \n    byte[][] lower = encode(minLat, minLon);\n    byte[][] upper = encode(maxLat, maxLon);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLon < minLon) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open (null)\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open (null)\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"606ea169579957651185909e7264798e99e714f9","date":1458504317,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encode(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[][] lower = encode(minLatitude, minLongitude);\n    byte[][] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[][] leftOpen = new byte[2][];\n      leftOpen[0] = lower[0];\n      // leave longitude open\n      leftOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen[1], 0);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[][] rightOpen = new byte[2][];\n      rightOpen[0] = upper[0];\n      // leave longitude open\n      rightOpen[1] = new byte[Integer.BYTES];\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen[1], 0);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","1800b996d8677670482a071dcb7a48b08c423ace","609ba4ce51a7095e9815d4fb2666ec85714f8f54","94ee361295fb38310ac4d53cb4773d1622423d68"],"bugIntro":["03bffb520caf6e9833c4b9a82ac67d19a1f3fc97"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad0d09e969f4763b0df4230f8e3f74357872a4e4","date":1459188769,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encode(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. cannot be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encode(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":["94ee361295fb38310ac4d53cb4773d1622423d68"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97","date":1459595815,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encode(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":["606ea169579957651185909e7264798e99e714f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb0d4a7f57423c831756f9e05c0ded0b4aa70abd","date":1460002196,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery();\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery();\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery();\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery();\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery();\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery();\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4778b794a897685e2f6c62caa1ac04983d1e69f","date":1467997674,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery();\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery();\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery();\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery();\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n      q.setDisableCoord(true);\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#newBoxQuery(String,double,double,double,double).mjava","sourceNew":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a query for matching a bounding box.\n   * <p>\n   * The box may cross over the dateline.\n   * @param field field name. must not be null.\n   * @param minLatitude latitude lower bound: must be within standard +/-90 coordinate bounds.\n   * @param maxLatitude latitude upper bound: must be within standard +/-90 coordinate bounds.\n   * @param minLongitude longitude lower bound: must be within standard +/-180 coordinate bounds.\n   * @param maxLongitude longitude upper bound: must be within standard +/-180 coordinate bounds.\n   * @return query matching points within this box\n   * @throws IllegalArgumentException if {@code field} is null, or the box has invalid coordinates.\n   */\n  public static Query newBoxQuery(String field, double minLatitude, double maxLatitude, double minLongitude, double maxLongitude) {\n    // exact double values of lat=90.0D and lon=180.0D must be treated special as they are not represented in the encoding\n    // and should not drag in extra bogus junk! TODO: should encodeCeil just throw ArithmeticException to be less trappy here?\n    if (minLatitude == 90.0) {\n      // range cannot match as 90.0 can never exist\n      return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLatitude=90.0\");\n    }\n    if (minLongitude == 180.0) {\n      if (maxLongitude == 180.0) {\n        // range cannot match as 180.0 can never exist\n        return new MatchNoDocsQuery(\"LatLonPoint.newBoxQuery with minLongitude=maxLongitude=180.0\");\n      } else if (maxLongitude < minLongitude) {\n        // encodeCeil() with dateline wrapping!\n        minLongitude = -180.0;\n      }\n    }\n    byte[] lower = encodeCeil(minLatitude, minLongitude);\n    byte[] upper = encode(maxLatitude, maxLongitude);\n    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:\n    if (maxLongitude < minLongitude) {\n      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:\n      BooleanQuery.Builder q = new BooleanQuery.Builder();\n\n      // E.g.: maxLon = -179, minLon = 179\n      byte[] leftOpen = lower.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, leftOpen, Integer.BYTES);\n      Query left = newBoxInternal(field, leftOpen, upper);\n      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));\n\n      byte[] rightOpen = upper.clone();\n      // leave longitude open\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, rightOpen, Integer.BYTES);\n      Query right = newBoxInternal(field, lower, rightOpen);\n      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));\n      return new ConstantScoreQuery(q.build());\n    } else {\n      return newBoxInternal(field, lower, upper);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f4778b794a897685e2f6c62caa1ac04983d1e69f":["c8a0e442f7b61f811680273b25da95994a724466"],"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"606ea169579957651185909e7264798e99e714f9":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"c422e924212367b334b4938f1fd3e44438e88c40":["94ee361295fb38310ac4d53cb4773d1622423d68","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["94ee361295fb38310ac4d53cb4773d1622423d68"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["fb0d4a7f57423c831756f9e05c0ded0b4aa70abd","f4778b794a897685e2f6c62caa1ac04983d1e69f"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"609ba4ce51a7095e9815d4fb2666ec85714f8f54":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["609ba4ce51a7095e9815d4fb2666ec85714f8f54"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["606ea169579957651185909e7264798e99e714f9"],"c8a0e442f7b61f811680273b25da95994a724466":["fb0d4a7f57423c831756f9e05c0ded0b4aa70abd"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["609ba4ce51a7095e9815d4fb2666ec85714f8f54","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"fb0d4a7f57423c831756f9e05c0ded0b4aa70abd":["03bffb520caf6e9833c4b9a82ac67d19a1f3fc97"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","609ba4ce51a7095e9815d4fb2666ec85714f8f54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["c422e924212367b334b4938f1fd3e44438e88c40"]},"commit2Childs":{"f4778b794a897685e2f6c62caa1ac04983d1e69f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","88b0212386fe531136816706dc37dc49b9dbf7dc"],"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97":["fb0d4a7f57423c831756f9e05c0ded0b4aa70abd"],"606ea169579957651185909e7264798e99e714f9":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"c422e924212367b334b4938f1fd3e44438e88c40":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"609ba4ce51a7095e9815d4fb2666ec85714f8f54":["94ee361295fb38310ac4d53cb4773d1622423d68","cf1a614098b46c9c22afebd7b898ae4d1d2fc273","1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["609ba4ce51a7095e9815d4fb2666ec85714f8f54","1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["03bffb520caf6e9833c4b9a82ac67d19a1f3fc97"],"c8a0e442f7b61f811680273b25da95994a724466":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["606ea169579957651185909e7264798e99e714f9"],"fb0d4a7f57423c831756f9e05c0ded0b4aa70abd":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":[],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}