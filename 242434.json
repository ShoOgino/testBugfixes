{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","commits":[{"id":"dd8a9ad1acc754f713e220250044c2bf06a22a0b","date":1518740056,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"/dev/null","sourceNew":"  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","date":1533256859,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  // commented 4-Sep-2018  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  // commented 4-Sep-2018  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  // commented 4-Sep-2018  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  // commented 4-Sep-2018  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testAsyncIdRaceCondition() throws Exception {\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new SolrNamedThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new DefaultSolrThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new SolrNamedThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              if (log.isInfoEnabled()) {\n                log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              }\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              if (log.isInfoEnabled()) {\n                log.info(e.getMessage());\n              }\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new SolrNamedThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              log.info(e.getMessage());\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncIdRaceCondition().mjava","sourceNew":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new SolrNamedThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              if (log.isInfoEnabled()) {\n                log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              }\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              if (log.isInfoEnabled()) {\n                log.info(\"Exception during collection reloading, we were waiting for one: \", e);\n              }\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","sourceOld":"  public void testAsyncIdRaceCondition() throws Exception {\n\n    SolrClient[] clients = new SolrClient[cluster.getJettySolrRunners().size()];\n    int j = 0;\n    for (JettySolrRunner r:cluster.getJettySolrRunners()) {\n      clients[j++] = new HttpSolrClient.Builder(r.getBaseUrl().toString()).build();\n    }\n    RequestStatusState state = CollectionAdminRequest.createCollection(\"testAsyncIdRaceCondition\",\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(cluster.getSolrClient(), MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n    \n    int numThreads = 10;\n    final AtomicInteger numSuccess = new AtomicInteger(0);\n    final AtomicInteger numFailure = new AtomicInteger(0);\n    final CountDownLatch latch = new CountDownLatch(numThreads);\n    \n    ExecutorService es = ExecutorUtil.newMDCAwareFixedThreadPool(numThreads, new SolrNamedThreadFactory(\"testAsyncIdRaceCondition\"));\n    try {\n      for (int i = 0; i < numThreads; i++) {\n        es.submit(new Runnable() {\n          \n          @Override\n          public void run() {\n            CollectionAdminRequest.Reload reloadCollectionRequest = CollectionAdminRequest.reloadCollection(\"testAsyncIdRaceCondition\");\n            latch.countDown();\n            try {\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new RuntimeException();\n            }\n            \n            try {\n              if (log.isInfoEnabled()) {\n                log.info(\"{} - Reloading Collection.\", Thread.currentThread().getName());\n              }\n              reloadCollectionRequest.processAsync(\"repeatedId\", clients[random().nextInt(clients.length)]);\n              numSuccess.incrementAndGet();\n            } catch (SolrServerException e) {\n              if (log.isInfoEnabled()) {\n                log.info(e.getMessage());\n              }\n              assertEquals(\"Task with the same requestid already exists.\", e.getMessage());\n              numFailure.incrementAndGet();\n            } catch (IOException e) {\n              throw new RuntimeException();\n            }\n          }\n        });\n      }\n      es.shutdown();\n      assertTrue(es.awaitTermination(10, TimeUnit.SECONDS));\n      assertEquals(1, numSuccess.get());\n      assertEquals(numThreads - 1, numFailure.get());\n    } finally {\n      for (int i = 0; i < clients.length; i++) {\n        clients[i].close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["dd8a9ad1acc754f713e220250044c2bf06a22a0b"],"dd8a9ad1acc754f713e220250044c2bf06a22a0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"dd8a9ad1acc754f713e220250044c2bf06a22a0b":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd8a9ad1acc754f713e220250044c2bf06a22a0b"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}