{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","commits":[{"id":"edf5b262a72d10530eb2f01dc8f19060355b213e","date":1557765866,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParams());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5028c6838e2e49cb9da1cf70269851c049f107a","date":1584984100,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","sourceOld":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParams());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","sourceOld":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<Replica>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<Replica> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader()) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            Replica ri = new Replica(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader()) {\n              ri.getProperties().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.get(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.get(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.get(Variable.Type.CORE_IDX.tagName);\n                ri.getProperties().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","sourceOld":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<ReplicaInfo>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<ReplicaInfo> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            ReplicaInfo ri = new ReplicaInfo(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader) {\n              ri.getVariables().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.getVariable(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.getVariable(Variable.Type.CORE_IDX.tagName);\n                ri.getVariables().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SnapshotNodeStateProvider#SnapshotNodeStateProvider(SolrCloudManager,AutoScalingConfig).mjava","sourceNew":null,"sourceOld":"  /**\n   * Populate this instance from another instance of {@link SolrCloudManager}.\n   * @param other another instance\n   * @param config optional {@link AutoScalingConfig}, which will be used to determine what node and\n   *               replica tags to retrieve. If this is null then the other instance's config will be used.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public SnapshotNodeStateProvider(SolrCloudManager other, AutoScalingConfig config) throws Exception {\n    if (config == null) {\n      config = other.getDistribStateManager().getAutoScalingConfig();\n    }\n    Set<String> nodeTags = new HashSet<>(SimUtils.COMMON_NODE_TAGS);\n    nodeTags.addAll(config.getPolicy().getParamNames());\n    Set<String> replicaTags = new HashSet<>(SimUtils.COMMON_REPLICA_TAGS);\n    replicaTags.addAll(config.getPolicy().getPerReplicaAttributes());\n    for (String node : other.getClusterStateProvider().getLiveNodes()) {\n      nodeValues.put(node, new LinkedHashMap<>(other.getNodeStateProvider().getNodeValues(node, nodeTags)));\n      Map<String, Map<String, List<Replica>>> infos = other.getNodeStateProvider().getReplicaInfo(node, replicaTags);\n      infos.forEach((collection, shards) -> {\n        shards.forEach((shard, replicas) -> {\n          replicas.forEach(r -> {\n            List<Replica> myReplicas = replicaInfos\n                .computeIfAbsent(node, n -> new LinkedHashMap<>())\n                .computeIfAbsent(collection, c -> new LinkedHashMap<>())\n                .computeIfAbsent(shard, s -> new ArrayList<>());\n            Map<String, Object> rMap = new LinkedHashMap<>();\n            r.toMap(rMap);\n            if (r.isLeader()) { // ReplicaInfo.toMap doesn't write this!!!\n              ((Map<String, Object>)rMap.values().iterator().next()).put(\"leader\", \"true\");\n            }\n            Replica ri = new Replica(rMap);\n            // put in \"leader\" again if present\n            if (r.isLeader()) {\n              ri.getProperties().put(\"leader\", \"true\");\n            }\n            // externally produced snapshots may not include the right units\n            if (ri.get(Variable.Type.CORE_IDX.metricsAttribute) == null) {\n              if (ri.get(Variable.Type.CORE_IDX.tagName) != null) {\n                Number indexSizeGB = (Number) ri.get(Variable.Type.CORE_IDX.tagName);\n                ri.getProperties().put(Variable.Type.CORE_IDX.metricsAttribute, indexSizeGB.doubleValue() * GB);\n              } else {\n                throw new RuntimeException(\"Missing size information for replica: \" + ri);\n              }\n            }\n            myReplicas.add(ri);\n          });\n        });\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["e5028c6838e2e49cb9da1cf70269851c049f107a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5028c6838e2e49cb9da1cf70269851c049f107a":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["e5028c6838e2e49cb9da1cf70269851c049f107a"],"e5028c6838e2e49cb9da1cf70269851c049f107a":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}