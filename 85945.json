{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","commits":[{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#simpleNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      if (fieldInfos.get(field).omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues simpleNormValues(String field) {\n      if (fieldInfos.get(field).omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      FieldInfo fieldInfo = fieldInfos.get(field);\n      if (fieldInfo == null || fieldInfo.omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      if (fieldInfos.get(field).omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      FieldInfo fieldInfo = fieldInfos.get(field);\n      if (fieldInfo == null || fieldInfo.omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dddb2c2ed096135b31cff8907f24ca2f5db46562","date":1413882711,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      if (norms == null)\n        return calculateFieldNormValue(field);\n      return norms.get(field);\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      FieldInfo fieldInfo = fieldInfos.get(field);\n      if (fieldInfo == null || fieldInfo.omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      if (norms == null)\n        return calculateFieldNormValue(field);\n      return norms.get(field);\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      FieldInfo fieldInfo = fieldInfos.get(field);\n      if (fieldInfo == null || fieldInfo.omitsNorms())\n        return null;\n      NumericDocValues norms = cachedNormValues;\n      Similarity sim = getSimilarity();\n      if (!field.equals(cachedFieldName) || sim != cachedSimilarity) { // not cached?\n        Info info = getInfo(field);\n        int numTokens = info != null ? info.numTokens : 0;\n        int numOverlapTokens = info != null ? info.numOverlapTokens : 0;\n        float boost = info != null ? info.getBoost() : 1.0f; \n        FieldInvertState invertState = new FieldInvertState(field, 0, numTokens, numOverlapTokens, 0, boost);\n        long value = sim.computeNorm(invertState);\n        norms = new MemoryIndexNormDocValues(value);\n        // cache it for future reuse\n        cachedNormValues = norms;\n        cachedFieldName = field;\n        cachedSimilarity = sim;\n        if (DEBUG) System.err.println(\"MemoryIndexReader.norms: \" + field + \":\" + value + \":\" + numTokens);\n      }\n      return norms;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f657d9837900f4519ca1cbd5e98d86d4bba4dab","date":1417790596,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      Info info = fields.get(field);\n      if (info == null) {\n        return null;\n      }\n      return info.getNormDocValues();\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      if (norms == null)\n        return calculateFieldNormValue(field);\n      return norms.get(field);\n    }\n\n","bugFix":null,"bugIntro":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b68d01c34172936f1aa2a8b9abf0e1bc68415f","date":1486637198,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.MemoryIndexReader#getNormValues(String).mjava","sourceNew":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      Info info = fields.get(field);\n      if (info == null || info.fieldInfo.omitsNorms()) {\n        return null;\n      }\n      return info.getNormDocValues();\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValues getNormValues(String field) {\n      Info info = fields.get(field);\n      if (info == null) {\n        return null;\n      }\n      return info.getNormDocValues();\n    }\n\n","bugFix":["0f657d9837900f4519ca1cbd5e98d86d4bba4dab"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["d4d69c535930b5cce125cff868d40f6373dc27d4","dddb2c2ed096135b31cff8907f24ca2f5db46562"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b2d5244a676b83c2d551c3746e8181588ba619e1"],"dddb2c2ed096135b31cff8907f24ca2f5db46562":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"89b68d01c34172936f1aa2a8b9abf0e1bc68415f":["0f657d9837900f4519ca1cbd5e98d86d4bba4dab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f657d9837900f4519ca1cbd5e98d86d4bba4dab":["dddb2c2ed096135b31cff8907f24ca2f5db46562"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","dddb2c2ed096135b31cff8907f24ca2f5db46562"],"dddb2c2ed096135b31cff8907f24ca2f5db46562":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","0f657d9837900f4519ca1cbd5e98d86d4bba4dab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","d4d69c535930b5cce125cff868d40f6373dc27d4","b2d5244a676b83c2d551c3746e8181588ba619e1"],"89b68d01c34172936f1aa2a8b9abf0e1bc68415f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0f657d9837900f4519ca1cbd5e98d86d4bba4dab":["89b68d01c34172936f1aa2a8b9abf0e1bc68415f"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}