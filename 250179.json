{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","commits":[{"id":"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a","date":1524514741,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8254aa20264eb7a88d556bbe0346667937ed9c2a","date":1538494545,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        NamedList<Object> status = (NamedList<Object>)m.get(\"status\");\n        if (\"completed\".equals(status.get(\"state\"))) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0921a3414432a896e242b56e81736020946fe960","date":1548182831,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2682a1cd25864ccdc1b44bf047bd08700f28ba06","date":1548321910,"type":3,"author":"Tommaso Teofili","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3',\" +\n        \"'event' : 'searchRate',\" +\n        \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n        \"'enabled' : false,\" +\n        \"'collections' : '\" + COLL1 + \"',\" +\n        \"'aboveRate' : 1.0,\" +\n        \"'belowRate' : 0.1,\" +\n        // set limits to node rates\n        \"'aboveNodeRate' : 1.0,\" +\n        \"'belowNodeRate' : 0.1,\" +\n        // allow deleting all spare replicas\n        \"'minReplicas' : 1,\" +\n        // allow requesting all deletions in one event\n        \"'maxOps' : 10,\" +\n        // delete underutilised nodes\n        \"'belowNodeOp' : 'DELETENODE',\" +\n        \"'actions' : [\" +\n        \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n        \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n        \"]\" +\n        \"}}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'started',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['STARTED'],\" +\n        \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'srt',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['FAILED','SUCCEEDED'],\" +\n        \"'afterAction': ['compute', 'execute'],\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'finished',\" +\n        \"'trigger' : 'search_rate_trigger3',\" +\n        \"'stage' : ['SUCCEEDED'],\" +\n        \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    // enable the trigger\n    String resumeTriggerCommand = \"{\" +\n        \"'resume-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, resumeTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n\n    boolean await = started.await(20, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not fire at all\", await);\n    await = finished.await(90, TimeUnit.SECONDS);\n    assertTrue(\"The trigger did not finish processing\", await);\n\n    // suspend the trigger\n    String suspendTriggerCommand = \"{\" +\n        \"'suspend-trigger' : {\" +\n        \"'name' : 'search_rate_trigger3'\" +\n        \"}\" +\n        \"}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, suspendTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    timeSource.sleep(5000);\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE\n    assertEquals(ops.toString(), 8, ops.size());\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    @SuppressWarnings({\"unchecked\"})\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    @SuppressWarnings({\"unchecked\"})\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerIntegrationTest#testDeleteNode().mjava","sourceNew":null,"sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-13163\") \n  public void testDeleteNode() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    String COLL1 = \"deleteNode_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 1, 2);\n\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 2));\n\n    // add a couple of spare replicas above RF. Use different types to verify that only\n    // searchable replicas are considered\n    // these additional replicas will be placed on other nodes in the cluster\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.NRT));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.TLOG));\n    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, \"shard1\", Replica.Type.PULL));\n\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 5));\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3',\" +\n       \"'event' : 'searchRate',\" +\n       \"'waitFor' : '\" + waitForSeconds + \"s',\" +\n       \"'enabled' : false,\" +\n       \"'collections' : '\" + COLL1 + \"',\" +\n       \"'aboveRate' : 1.0,\" +\n       \"'aboveNodeRate' : 1.0,\" +\n       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero\n       // even when no external requests were made .. but it's hard to predict exactly\n       // what it will be.  use an insanely high rate so all shards/nodes are suspect\n       // and produce an Op regardless of how much internal traffic is produced...\n       \"'belowRate' : 1.0,\" +\n       \"'belowNodeRate' : 1.0,\" +\n       // ...our Ops should be to delete underutilised nodes...\n       \"'belowNodeOp' : 'DELETENODE',\" +\n       // ...allow deleting all spare replicas...\n       \"'minReplicas' : 1,\" +\n       // ...and allow requesting all deletions in one event.\n       \"'maxOps' : 10,\" +\n       \"'actions' : [\" +\n       \"{'name':'compute','class':'\" + ComputePlanAction.class.getName() + \"'},\" +\n       \"{'name':'execute','class':'\" + ExecutePlanAction.class.getName() + \"'}\" +\n       \"]\" +\n       \"}}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'started',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['STARTED'],\" +\n       \"'class' : '\" + StartedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'srt',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['FAILED','SUCCEEDED'],\" +\n       \"'afterAction': ['compute', 'execute'],\" +\n       \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    listenerEventLatch = new CountDownLatch(3);\n\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager, \n       \"{\" +\n       \"'set-listener' : \" +\n       \"{\" +\n       \"'name' : 'finished',\" +\n       \"'trigger' : 'search_rate_trigger3',\" +\n       \"'stage' : ['SUCCEEDED'],\" +\n       \"'class' : '\" + FinishedProcessingListener.class.getName() + \"'\" +\n       \"}\" +\n       \"}\");\n    \n    // Explicitly Do Nothing Here\n    \n    // enable the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'resume-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    assertTrue(\"The trigger did not start in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"The trigger did not finish in a reasonable amount of time\",\n               started.await(60, TimeUnit.SECONDS));\n    \n    assertTrue(\"the listener should have recorded all events w/in a reasonable amount of time\",\n               listenerEventLatch.await(60, TimeUnit.SECONDS));\n    \n    // suspend the trigger\n    CloudTestUtils.assertAutoScalingRequest\n      (cloudManager,\n       \"{\" +\n       \"'suspend-trigger' : {\" +\n       \"'name' : 'search_rate_trigger3'\" +\n       \"}\" +\n       \"}\");\n\n    List<CapturedEvent> events = listenerEvents.get(\"srt\");\n    assertEquals(events.toString(), 3, events.size());\n\n    CapturedEvent ev = events.get(0);\n    assertEquals(ev.toString(), \"compute\", ev.actionName);\n    @SuppressWarnings({\"unchecked\"})\n    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);\n    assertNotNull(\"there should be some requestedOps: \" + ev.toString(), ops);\n    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)\n    assertEquals(ops.toString(), 4 + 4, ops.size());\n    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE\n    // Which is problemtatic for 2 reasons:\n    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'\n    //     - definitely a bug that needs fixed\n    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'\n    //     - something that needs more rigerous testing\n    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?\n    //\n    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:\n    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked\n    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate\n\n\n\n    AtomicInteger replicas = new AtomicInteger();\n    AtomicInteger nodes = new AtomicInteger();\n    ops.forEach(op -> {\n      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {\n        replicas.incrementAndGet();\n      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {\n        nodes.incrementAndGet();\n      } else {\n        fail(\"unexpected op: \" + op);\n      }\n    });\n    assertEquals(ops.toString(), 4, replicas.get());\n    assertEquals(ops.toString(), 4, nodes.get());\n    // check status\n    ev = events.get(1);\n    assertEquals(ev.toString(), \"execute\", ev.actionName);\n    @SuppressWarnings({\"unchecked\"})\n    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get(\"properties.responses\");\n    assertNotNull(ev.toString(), responses);\n    assertEquals(responses.toString(), 8, responses.size());\n    replicas.set(0);\n    nodes.set(0);\n    responses.forEach(m -> {\n      if (m.get(\"success\") != null) {\n        replicas.incrementAndGet();\n      } else if (m.get(\"status\") != null) {\n        Object status = m.get(\"status\");\n        String state;\n        if (status instanceof Map) {\n          state = (String)((Map)status).get(\"state\");\n        } else if (status instanceof NamedList) {\n          state = (String)((NamedList)status).get(\"state\");\n        } else {\n          throw new IllegalArgumentException(\"unsupported status format: \" + status.getClass().getName() + \", \" + status);\n        }\n        if (\"completed\".equals(state)) {\n          nodes.incrementAndGet();\n        } else {\n          fail(\"unexpected DELETENODE status: \" + m);\n        }\n      } else {\n        fail(\"unexpected status: \" + m);\n      }\n    });\n\n    assertEquals(responses.toString(), 4, replicas.get());\n    assertEquals(responses.toString(), 4, nodes.get());\n\n    // we are left with one searchable replica\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,\n        CloudUtil.clusterShape(1, 1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["43ad790248d7f7daee5d9cced548c546f37c7218"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"3f504512a03d978990cbff30db0522b354e846db":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0921a3414432a896e242b56e81736020946fe960":["89948af0461fead48f44ba8fb7866f107ce83f22"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["0921a3414432a896e242b56e81736020946fe960"],"89948af0461fead48f44ba8fb7866f107ce83f22":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"43ad790248d7f7daee5d9cced548c546f37c7218":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"2682a1cd25864ccdc1b44bf047bd08700f28ba06":["89948af0461fead48f44ba8fb7866f107ce83f22","0921a3414432a896e242b56e81736020946fe960"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["43ad790248d7f7daee5d9cced548c546f37c7218"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["89948af0461fead48f44ba8fb7866f107ce83f22"],"0921a3414432a896e242b56e81736020946fe960":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"43ad790248d7f7daee5d9cced548c546f37c7218":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"89948af0461fead48f44ba8fb7866f107ce83f22":["0921a3414432a896e242b56e81736020946fe960","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2682a1cd25864ccdc1b44bf047bd08700f28ba06":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","2682a1cd25864ccdc1b44bf047bd08700f28ba06"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}