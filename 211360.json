{"path":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","commits":[{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0cf25ac9828f9d484e626a18635422d10f8c9549","0cf25ac9828f9d484e626a18635422d10f8c9549","1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    \n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter\", t);\n          }\n        }\n        \n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","date":1345037674,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["66c64e8cfded6a585100e6430238faaf416f3fea","1381b91b03f7409d8d548c7070dbc615931a0f50"],"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","1adea4accc297f58fd9d8de3c820fd576eb0d396","ab20a04a303d3d2a5078076f4633e0482d643cc0","ab20a04a303d3d2a5078076f4633e0482d643cc0","ab20a04a303d3d2a5078076f4633e0482d643cc0","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70fa1c0f4d75735ff2e1485e059d9bc5efa50598","date":1345296911,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"616c1830142ff5c1ddedec1ed898733b73c8e23b","date":1345368925,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n      \n      try {\n        if (indexWriter != null) {\n          try {\n            log.info(\"Closing old IndexWriter... core=\" + coreName);\n            indexWriter.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error closing old IndexWriter. core=\" + coreName, t);\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\",\n            false, true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11fa6b3c54740236744aa64f1a29954b1cf172a5","date":1363907001,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a60d4b4f93f7cb72968d89fac4f93e544d2cfec8","date":1364006412,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    if (closed) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    if (closed) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["a60d4b4f93f7cb72968d89fac4f93e544d2cfec8","a3a59df963d88be504b80055918c76d3cc066054"],"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab20a04a303d3d2a5078076f4633e0482d643cc0","date":1398201811,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.shutdown();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.shutdown();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.shutdown();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","date":1439091488,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n\n      try {\n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {\n          }\n          if (closed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n          }\n        }\n\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1adea4accc297f58fd9d8de3c820fd576eb0d396","date":1441292844,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    lock(iwLock.writeLock());\n    try {\n      changeWriter(core, rollback, true);\n    } finally {\n      iwLock.writeLock().unlock();\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      if (closed) {\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Already closed\");\n      }\n      \n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until it's out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n\n      try {\n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {\n          }\n          if (closed) {\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n          }\n        }\n\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Exception e) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, e);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["54f9a16329716fa08b653c53f1c3dfc6b284d2cc","11fa6b3c54740236744aa64f1a29954b1cf172a5","76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b","66c64e8cfded6a585100e6430238faaf416f3fea","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","d0ef034a4f10871667ae75181537775ddcf8ade4","058801f8673d53a5abac8088204860ec29a40f0d","1381b91b03f7409d8d548c7070dbc615931a0f50","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66c64e8cfded6a585100e6430238faaf416f3fea":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","ab20a04a303d3d2a5078076f4633e0482d643cc0"],"616c1830142ff5c1ddedec1ed898733b73c8e23b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","66c64e8cfded6a585100e6430238faaf416f3fea"],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","66c64e8cfded6a585100e6430238faaf416f3fea"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["66c64e8cfded6a585100e6430238faaf416f3fea"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"058801f8673d53a5abac8088204860ec29a40f0d":["a60d4b4f93f7cb72968d89fac4f93e544d2cfec8"],"a60d4b4f93f7cb72968d89fac4f93e544d2cfec8":["11fa6b3c54740236744aa64f1a29954b1cf172a5"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"11fa6b3c54740236744aa64f1a29954b1cf172a5":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1381b91b03f7409d8d548c7070dbc615931a0f50"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["ab20a04a303d3d2a5078076f4633e0482d643cc0"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1381b91b03f7409d8d548c7070dbc615931a0f50"],"f2126b84bd093fa3d921582a109a0ee578c28126":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["058801f8673d53a5abac8088204860ec29a40f0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1adea4accc297f58fd9d8de3c820fd576eb0d396"]},"commit2Childs":{"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"616c1830142ff5c1ddedec1ed898733b73c8e23b":[],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["70fa1c0f4d75735ff2e1485e059d9bc5efa50598"],"ab20a04a303d3d2a5078076f4633e0482d643cc0":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","d0ef034a4f10871667ae75181537775ddcf8ade4"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["66c64e8cfded6a585100e6430238faaf416f3fea","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["616c1830142ff5c1ddedec1ed898733b73c8e23b"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["11fa6b3c54740236744aa64f1a29954b1cf172a5","f2126b84bd093fa3d921582a109a0ee578c28126"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["616c1830142ff5c1ddedec1ed898733b73c8e23b","d9405f486872f1e416304dfe389741f4ee2f8a4d","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","f2126b84bd093fa3d921582a109a0ee578c28126"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b"],"058801f8673d53a5abac8088204860ec29a40f0d":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a60d4b4f93f7cb72968d89fac4f93e544d2cfec8":["058801f8673d53a5abac8088204860ec29a40f0d"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1381b91b03f7409d8d548c7070dbc615931a0f50","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"11fa6b3c54740236744aa64f1a29954b1cf172a5":["a60d4b4f93f7cb72968d89fac4f93e544d2cfec8"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","ab20a04a303d3d2a5078076f4633e0482d643cc0"],"76fe9c497e8a6dfe48a1c3d048a6778db23b5a0b":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}