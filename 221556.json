{"path":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","commits":[{"id":"da3894312f2635a8faf0bd4f81e047cb3805e557","date":1375952794,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"new_implicit_coll_\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 4;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", coll.getName());\n    params.set(\"shard\", \"z\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,coll.getName(),5);\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdd2d639986db5a5a6f3703a8b4136a6473a5f81","date":1376372957,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"/dev/null","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e187a371a1d09379bb452c2c13a7b9221525dff8","date":1379517004,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":["be42559d954536c25355bd8887875bc3eb8b15a1","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1816753738ff1f27f11b38030e83c0ded050b7a4","date":1380106089,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9eafdca347a58310b9b997a3154436991e98999b","date":1380716528,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d31e5ade44c0d23378d22781e2f2c293afdb25d","date":1386771146,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    // test shards.info with _route_ param\n    QueryResponse resp = collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\").setParam(ShardParams.SHARDS_INFO, true));\n    NamedList<?> sinfo = (NamedList<?>) resp.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"missing shard info\", sinfo);\n    for (Map.Entry<String,?> entry : sinfo) {\n      NamedList<?> info = (NamedList<?>) entry.getValue();\n      assertTrue(\"Expected to find numFound in the up shard info\",info.get(\"numFound\") != null);\n      assertTrue(\"Expected to find shardAddress in the up shard info\",info.get(\"shardAddress\") != null);\n    }\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    // test shards.info with _route_ param\n    QueryResponse resp = collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\").setParam(ShardParams.SHARDS_INFO, true));\n    NamedList<?> sinfo = (NamedList<?>) resp.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"missing shard info\", sinfo);\n    for (Map.Entry<String,?> entry : sinfo) {\n      NamedList<?> info = (NamedList<?>) entry.getValue();\n      assertTrue(\"Expected to find numFound in the up shard info\",info.get(\"numFound\") != null);\n      assertTrue(\"Expected to find shardAddress in the up shard info\",info.get(\"shardAddress\") != null);\n    }\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c831baf8c7240249f554d3a104f97265b797535d","date":1390632895,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    // test shards.info with _route_ param\n    QueryResponse resp = collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\").setParam(ShardParams.SHARDS_INFO, true));\n    NamedList<?> sinfo = (NamedList<?>) resp.getResponse().get(ShardParams.SHARDS_INFO);\n    assertNotNull(\"missing shard info\", sinfo);\n    for (Map.Entry<String,?> entry : sinfo) {\n      NamedList<?> info = (NamedList<?>) entry.getValue();\n      assertTrue(\"Expected to find numFound in the up shard info\",info.get(\"numFound\") != null);\n      assertTrue(\"Expected to find shardAddress in the up shard info\",info.get(\"shardAddress\") != null);\n    }\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c7856260bc28f285ae7bfefa99b28db4dca6daf","date":1395253500,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n    \n    collectionClient.shutdown();\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n    collectionClient.shutdown();\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    collectionClient.shutdown();\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrClient client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    \n    collectionClient.shutdown();\n    collectionClient = new HttpSolrClient(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n    collectionClient.shutdown();\n    collectionClient = new HttpSolrClient(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    collectionClient.shutdown();\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), collectionName);\n    \n    collectionClient.shutdown();\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n    collectionClient.shutdown();\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    collectionClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    try {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n      server.request(request);\n      server.shutdown();\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n  \n  \n      CloudSolrClient client = null;\n      try {\n        client = createCloudClient(null);\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    } finally {\n      collectionClient.shutdown();\n    }\n    collectionClient = new HttpSolrClient(url);\n    try {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    } finally {\n      collectionClient.shutdown();\n    }\n\n\n      collectionClient = new HttpSolrClient(url);\n      try {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    } finally {\n      collectionClient.shutdown();\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrClient client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = ZkNodeProps.makeMap(\n          \"router.name\", ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          \"router.field\", shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    \n    collectionClient.shutdown();\n    collectionClient = new HttpSolrClient(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n    collectionClient.shutdown();\n    collectionClient = new HttpSolrClient(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    collectionClient.shutdown();\n  }\n\n","bugFix":["1eeda7e62e149f90eee8895af874c74efa7d4852","bafca15d8e408346a67f4282ad1143b88023893b","cdd2d639986db5a5a6f3703a8b4136a6473a5f81","e187a371a1d09379bb452c2c13a7b9221525dff8","4c7856260bc28f285ae7bfefa99b28db4dca6daf","da3894312f2635a8faf0bd4f81e047cb3805e557","6613659748fe4411a7dcf85266e55db1f95f7315"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n      collectionClient.shutdown();\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n    try {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)));\n      server.request(request);\n      server.shutdown();\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n  \n  \n      CloudSolrClient client = null;\n      try {\n        client = createCloudClient(null);\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    } finally {\n      collectionClient.shutdown();\n    }\n    collectionClient = new HttpSolrClient(url);\n    try {\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    } finally {\n      collectionClient.shutdown();\n    }\n\n\n      collectionClient = new HttpSolrClient(url);\n      try {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    } finally {\n      collectionClient.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be42559d954536c25355bd8887875bc3eb8b15a1","date":1427742461,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":["e187a371a1d09379bb452c2c13a7b9221525dff8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(ZkStateReader.ACTIVE.equals(x.getStr(ZkStateReader.STATE_PROP))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(ZkStateReader.ACTIVE.equals(x.getStr(ZkStateReader.STATE_PROP))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if(ZkStateReader.ACTIVE.equals(x.getStr(ZkStateReader.STATE_PROP))) activeReplicaCount++;\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = ZkNodeProps.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4efd3fffdd7acd625bb88e455c8097e17f75735","date":1477647201,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59dce44d6a0b58c171de1d47ad8c0a75831f94fd","date":1477668573,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<>();\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrClient client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.close();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collection);\n\n      try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n        // poll for a second - it can take a moment before we are ready to serve\n        waitForNon403or404or503(collectionClient);\n      }\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", ((Map)coll.get(DOC_ROUTER)).get(\"name\") );\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    List<String> collectionNameList = new ArrayList<>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n\n    String shard_fld = \"shard_s\";\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n  \n      collectionClient.deleteByQuery(\"*:*\");\n      collectionClient.commit(true,true);\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  \n      UpdateRequest up = new UpdateRequest();\n      up.setParam(_ROUTE_, \"c\");\n      up.setParam(\"commit\",\"true\");\n  \n      up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\"));\n      up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\"));\n      up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\"));\n  \n      collectionClient.request(up);\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"a\")).getResults().getNumFound());\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"c\")).getResults().getNumFound());\n  \n      //Testing CREATESHARD\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(\"action\", CollectionAction.CREATESHARD.toString());\n      params.set(\"collection\", collectionName);\n      params.set(\"shard\", \"x\");\n      SolrRequest request = new QueryRequest(params);\n      request.setPath(\"/admin/collections\");\n      try (SolrClient server = createNewSolrClient(\"\", getBaseUrl((HttpSolrClient) clients.get(0)))) {\n        server.request(request);\n      }\n      waitForCollection(zkStateReader,collectionName,4);\n      //wait for all the replicas to become active\n      int attempts = 0;\n      while(true){\n        if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n        attempts++;\n        int activeReplicaCount = 0;\n        for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n          if (x.getState() == Replica.State.ACTIVE) {\n            activeReplicaCount++;\n          }\n        }\n        Thread.sleep(500);\n        if(activeReplicaCount >= replicationFactor) break;\n      }\n      log.info(zkStateReader.getClusterState().toString());\n  \n      collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n      collectionClient.commit();\n      assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n  \n  \n      int numShards = 4;\n      replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrClient()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n      try (CloudSolrClient client = createCloudClient(null)) {\n        Map<String, Object> props = Utils.makeMap(\n            \"router.name\", ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP, \"a,b,c,d\",\n            \"router.field\", shard_fld);\n  \n        collectionName = COLL_PREFIX + \"withShardField\";\n        createCollection(collectionInfos, collectionName,props,client);\n      }\n  \n      List<Integer> list = collectionInfos.get(collectionName);\n      checkForCollection(collectionName, list, null);\n  \n  \n      url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), collectionName);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n         // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n      // lets try and use the solrj client to index a couple documents\n  \n      collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n          \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n          \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n  \n      collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n          \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n  \n      collectionClient.commit();\n  \n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n      assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"b\")).getResults().getNumFound());\n      //TODO debug the following case\n      assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","sourceOld":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","sourceOld":"  @Test\n  public void testCustomCollectionsAPI() throws Exception {\n\n    final String collection = \"implicitcoll\";\n    int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 2;\n    int numShards = 3;\n    int maxShardsPerNode = (((numShards + 1) * replicationFactor) / NODE_COUNT) + 1;\n\n    CollectionAdminRequest.createCollectionWithImplicitRouter(collection, \"conf\", \"a,b,c\", replicationFactor)\n        .setMaxShardsPerNode(maxShardsPerNode)\n        .process(cluster.getSolrClient());\n\n    DocCollection coll = getCollectionState(collection);\n    assertEquals(\"implicit\", ((Map) coll.get(DOC_ROUTER)).get(\"name\"));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n    assertNull(\"A shard of a Collection configured with implicit router must have null range\",\n        coll.getSlice(\"a\").getRange());\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .withRoute(\"a\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"b\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n\n    cluster.getSolrClient().deleteByQuery(collection, \"*:*\");\n    cluster.getSolrClient().commit(collection, true, true);\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    new UpdateRequest()\n        .add(\"id\", \"9\")\n        .add(\"id\", \"10\")\n        .add(\"id\", \"11\")\n        .withRoute(\"c\")\n        .commit(cluster.getSolrClient(), collection);\n\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"a\")).getResults().getNumFound());\n    assertEquals(3, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    CollectionAdminRequest.createShard(collection, \"x\")\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected shard 'x' to be active\", collection, (n, c) -> {\n      if (c.getSlice(\"x\") == null)\n        return false;\n      for (Replica r : c.getSlice(\"x\")) {\n        if (r.getState() != Replica.State.ACTIVE)\n          return false;\n      }\n      return true;\n    });\n\n    new UpdateRequest()\n        .add(\"id\", \"66\", _ROUTE_, \"x\")\n        .commit(cluster.getSolrClient(), collection);\n    // TODO - the local state is cached and causes the request to fail with 'unknown shard'\n    // assertEquals(1, cluster.getSolrClient().query(collection, new SolrQuery(\"*:*\").setParam(_ROUTE_, \"x\")).getResults().getNumFound());\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a4efd3fffdd7acd625bb88e455c8097e17f75735":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a4efd3fffdd7acd625bb88e455c8097e17f75735","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"be42559d954536c25355bd8887875bc3eb8b15a1":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["be42559d954536c25355bd8887875bc3eb8b15a1"],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["9eafdca347a58310b9b997a3154436991e98999b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"bafca15d8e408346a67f4282ad1143b88023893b":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"0c924d4069ef5a5bc479a493befe0121aada6896":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["cc3b13b430571c2e169f98fe38e1e7666f88522d","be42559d954536c25355bd8887875bc3eb8b15a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["bafca15d8e408346a67f4282ad1143b88023893b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"1816753738ff1f27f11b38030e83c0ded050b7a4":["e187a371a1d09379bb452c2c13a7b9221525dff8"],"59dce44d6a0b58c171de1d47ad8c0a75831f94fd":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","a4efd3fffdd7acd625bb88e455c8097e17f75735"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","da3894312f2635a8faf0bd4f81e047cb3805e557"],"da3894312f2635a8faf0bd4f81e047cb3805e557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6613659748fe4411a7dcf85266e55db1f95f7315":["c831baf8c7240249f554d3a104f97265b797535d"],"9eafdca347a58310b9b997a3154436991e98999b":["1816753738ff1f27f11b38030e83c0ded050b7a4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cdd2d639986db5a5a6f3703a8b4136a6473a5f81"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a4efd3fffdd7acd625bb88e455c8097e17f75735"],"c831baf8c7240249f554d3a104f97265b797535d":["5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e187a371a1d09379bb452c2c13a7b9221525dff8":["cdd2d639986db5a5a6f3703a8b4136a6473a5f81"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["b693a83132c9e45afcd564fd65a25b60ed80388b","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["9eafdca347a58310b9b997a3154436991e98999b","5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"cdd2d639986db5a5a6f3703a8b4136a6473a5f81":["da3894312f2635a8faf0bd4f81e047cb3805e557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"a4efd3fffdd7acd625bb88e455c8097e17f75735":["b94236357aaa22b76c10629851fe4e376e0cea82","59dce44d6a0b58c171de1d47ad8c0a75831f94fd","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"be42559d954536c25355bd8887875bc3eb8b15a1":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","a219f1dcad1700e84807666bdbd2b573e8de7021"],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["c831baf8c7240249f554d3a104f97265b797535d","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bafca15d8e408346a67f4282ad1143b88023893b":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["0c924d4069ef5a5bc479a493befe0121aada6896"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","da3894312f2635a8faf0bd4f81e047cb3805e557"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["be42559d954536c25355bd8887875bc3eb8b15a1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"1816753738ff1f27f11b38030e83c0ded050b7a4":["9eafdca347a58310b9b997a3154436991e98999b"],"59dce44d6a0b58c171de1d47ad8c0a75831f94fd":[],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"da3894312f2635a8faf0bd4f81e047cb3805e557":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cdd2d639986db5a5a6f3703a8b4136a6473a5f81"],"9eafdca347a58310b9b997a3154436991e98999b":["5d31e5ade44c0d23378d22781e2f2c293afdb25d","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"c831baf8c7240249f554d3a104f97265b797535d":["6613659748fe4411a7dcf85266e55db1f95f7315"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["bafca15d8e408346a67f4282ad1143b88023893b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["a4efd3fffdd7acd625bb88e455c8097e17f75735","59dce44d6a0b58c171de1d47ad8c0a75831f94fd"],"e187a371a1d09379bb452c2c13a7b9221525dff8":["1816753738ff1f27f11b38030e83c0ded050b7a4"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"cdd2d639986db5a5a6f3703a8b4136a6473a5f81":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e187a371a1d09379bb452c2c13a7b9221525dff8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0c924d4069ef5a5bc479a493befe0121aada6896","59dce44d6a0b58c171de1d47ad8c0a75831f94fd","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}