{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","commits":[{"id":"e7b27dde701ae80df8bea8eb554d31e4e8bc6126","date":1354814363,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  @Repeat(iterations = 20)\n  public void testIntersects() throws IOException {\n    //non-geospatial makes this test a little easier\n    this.ctx = new SpatialContext(false, null, new RectangleImpl(0, 256, -128, 128, null));\n    //A fairly shallow grid, and default 2.5% distErrPct\n    this.grid = new QuadPrefixTree(ctx, randomIntBetween(1, 8));\n    this.strategy = new RecursivePrefixTreeStrategy(grid, getClass().getSimpleName());\n    //((PrefixTreeStrategy) strategy).setDistErrPct(0);//fully precise to grid\n\n    deleteAll();\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Rectangle> indexedGriddedShapes = new LinkedHashMap<String, Rectangle>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 1; i <= numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexShape = randomRectangle();\n      Rectangle gridShape = gridSnapp(indexShape);\n      indexedShapes.put(id, indexShape);\n      indexedGriddedShapes.put(id, gridShape);\n      adoc(id, indexShape);\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(10);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      Rectangle queryShape = randomRectangle();\n      Rectangle queryGridShape = gridSnapp(queryShape);\n\n      //Generate truth via brute force\n      final SpatialOperation operation = SpatialOperation.Intersects;\n      Set<String> expectedIds = new TreeSet<String>();\n      Set<String> optionalIds = new TreeSet<String>();\n      for (String id : indexedShapes.keySet()) {\n        Shape indexShape = indexedShapes.get(id);\n        Rectangle indexGridShape = indexedGriddedShapes.get(id);\n        if (operation.evaluate(indexShape, queryShape))\n          expectedIds.add(id);\n        else if (operation.evaluate(indexGridShape, queryGridShape))\n          optionalIds.add(id);\n      }\n\n      //Search and verify results\n      Query query = strategy.makeQuery(new SpatialArgs(operation, queryShape));\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new TreeSet<String>(expectedIds);\n      String msg = queryShape.toString()+\" Expect: \"+expectedIds+\" Opt: \"+optionalIds;\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        Object removed = remainingExpectedIds.remove(id);\n        if (removed == null) {\n          assertTrue(\"Shouldn't match \" + id + \" in \"+msg, optionalIds.contains(id));\n        }\n      }\n      assertTrue(\"Didn't match \" + remainingExpectedIds + \" in \" + msg, remainingExpectedIds.isEmpty());\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  @Repeat(iterations = 20)\n  public void testIntersects() throws IOException {\n    //non-geospatial makes this test a little easier\n    this.ctx = new SpatialContext(false, null, new RectangleImpl(0, 256, -128, 128, null));\n    //A fairly shallow grid, and default 2.5% distErrPct\n    this.grid = new QuadPrefixTree(ctx, randomIntBetween(1, 8));\n    this.strategy = new RecursivePrefixTreeStrategy(grid, getClass().getSimpleName());\n    //((PrefixTreeStrategy) strategy).setDistErrPct(0);//fully precise to grid\n\n    deleteAll();\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Rectangle> indexedGriddedShapes = new LinkedHashMap<String, Rectangle>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 1; i <= numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexShape = randomRectangle();\n      Rectangle gridShape = gridSnapp(indexShape);\n      indexedShapes.put(id, indexShape);\n      indexedGriddedShapes.put(id, gridShape);\n      adoc(id, indexShape);\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(10);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      Rectangle queryShape = randomRectangle();\n      Rectangle queryGridShape = gridSnapp(queryShape);\n\n      //Generate truth via brute force\n      final SpatialOperation operation = SpatialOperation.Intersects;\n      Set<String> expectedIds = new TreeSet<String>();\n      Set<String> optionalIds = new TreeSet<String>();\n      for (String id : indexedShapes.keySet()) {\n        Shape indexShape = indexedShapes.get(id);\n        Rectangle indexGridShape = indexedGriddedShapes.get(id);\n        if (operation.evaluate(indexShape, queryShape))\n          expectedIds.add(id);\n        else if (operation.evaluate(indexGridShape, queryGridShape))\n          optionalIds.add(id);\n      }\n\n      //Search and verify results\n      Query query = strategy.makeQuery(new SpatialArgs(operation, queryShape));\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new TreeSet<String>(expectedIds);\n      String msg = queryShape.toString()+\" Expect: \"+expectedIds+\" Opt: \"+optionalIds;\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        Object removed = remainingExpectedIds.remove(id);\n        if (removed == null) {\n          assertTrue(\"Shouldn't match \" + id + \" in \"+msg, optionalIds.contains(id));\n        }\n      }\n      assertTrue(\"Didn't match \" + remainingExpectedIds + \" in \" + msg, remainingExpectedIds.isEmpty());\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b","date":1364392557,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","sourceNew":"  @Test\n  @Repeat(iterations = 10)\n  public void testIntersects() throws IOException {\n    mySetup();\n    doTest(SpatialOperation.Intersects);\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = 20)\n  public void testIntersects() throws IOException {\n    //non-geospatial makes this test a little easier\n    this.ctx = new SpatialContext(false, null, new RectangleImpl(0, 256, -128, 128, null));\n    //A fairly shallow grid, and default 2.5% distErrPct\n    this.grid = new QuadPrefixTree(ctx, randomIntBetween(1, 8));\n    this.strategy = new RecursivePrefixTreeStrategy(grid, getClass().getSimpleName());\n    //((PrefixTreeStrategy) strategy).setDistErrPct(0);//fully precise to grid\n\n    deleteAll();\n\n    Map<String, Shape> indexedShapes = new LinkedHashMap<String, Shape>();\n    Map<String, Rectangle> indexedGriddedShapes = new LinkedHashMap<String, Rectangle>();\n    final int numIndexedShapes = randomIntBetween(1, 6);\n    for (int i = 1; i <= numIndexedShapes; i++) {\n      String id = \"\" + i;\n      Shape indexShape = randomRectangle();\n      Rectangle gridShape = gridSnapp(indexShape);\n      indexedShapes.put(id, indexShape);\n      indexedGriddedShapes.put(id, gridShape);\n      adoc(id, indexShape);\n    }\n\n    commit();\n\n    final int numQueryShapes = atLeast(10);\n    for (int i = 0; i < numQueryShapes; i++) {\n      int scanLevel = randomInt(grid.getMaxLevels());\n      ((RecursivePrefixTreeStrategy) strategy).setPrefixGridScanLevel(scanLevel);\n      Rectangle queryShape = randomRectangle();\n      Rectangle queryGridShape = gridSnapp(queryShape);\n\n      //Generate truth via brute force\n      final SpatialOperation operation = SpatialOperation.Intersects;\n      Set<String> expectedIds = new TreeSet<String>();\n      Set<String> optionalIds = new TreeSet<String>();\n      for (String id : indexedShapes.keySet()) {\n        Shape indexShape = indexedShapes.get(id);\n        Rectangle indexGridShape = indexedGriddedShapes.get(id);\n        if (operation.evaluate(indexShape, queryShape))\n          expectedIds.add(id);\n        else if (operation.evaluate(indexGridShape, queryGridShape))\n          optionalIds.add(id);\n      }\n\n      //Search and verify results\n      Query query = strategy.makeQuery(new SpatialArgs(operation, queryShape));\n      SearchResults got = executeQuery(query, 100);\n      Set<String> remainingExpectedIds = new TreeSet<String>(expectedIds);\n      String msg = queryShape.toString()+\" Expect: \"+expectedIds+\" Opt: \"+optionalIds;\n      for (SearchResult result : got.results) {\n        String id = result.getId();\n        Object removed = remainingExpectedIds.remove(id);\n        if (removed == null) {\n          assertTrue(\"Shouldn't match \" + id + \" in \"+msg, optionalIds.contains(id));\n        }\n      }\n      assertTrue(\"Didn't match \" + remainingExpectedIds + \" in \" + msg, remainingExpectedIds.isEmpty());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["3702440de9629167be64098f307cea70809df488","377464b9f674227f6d755dce0dd14a01ad955b5e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3702440de9629167be64098f307cea70809df488","date":1365439741,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","sourceNew":"  @Test\n  @Repeat(iterations = 10)\n  public void testIntersects() throws IOException {\n    mySetup(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = 10)\n  public void testIntersects() throws IOException {\n    mySetup();\n    doTest(SpatialOperation.Intersects);\n  }\n\n","bugFix":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"377464b9f674227f6d755dce0dd14a01ad955b5e","date":1369772619,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","sourceNew":"  @Test\n  @Repeat(iterations = ITERATIONS)\n  public void testIntersects() throws IOException {\n    mySetup(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = 10)\n  public void testIntersects() throws IOException {\n    mySetup(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","bugFix":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f54c29b684839e16d0a7ffd41ee8a1e93e905184","date":1395120410,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","sourceNew":"  @Test\n  @Repeat(iterations = ITERATIONS)\n  public void testIntersects() throws IOException {\n    setupGrid(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = ITERATIONS)\n  public void testIntersects() throws IOException {\n    mySetup(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0521546db127e358ced1772a9d696dbdd255b203","date":1403202289,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest#testIntersects().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/prefix/SpatialOpRecursivePrefixTreeTest#testIntersects().mjava","sourceNew":"  @Test\n  @Repeat(iterations = ITERATIONS)\n  public void testIntersects() throws IOException {\n    setupGrid(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","sourceOld":"  @Test\n  @Repeat(iterations = ITERATIONS)\n  public void testIntersects() throws IOException {\n    setupGrid(-1);\n    doTest(SpatialOperation.Intersects);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b27dde701ae80df8bea8eb554d31e4e8bc6126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["377464b9f674227f6d755dce0dd14a01ad955b5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7b27dde701ae80df8bea8eb554d31e4e8bc6126"],"3702440de9629167be64098f307cea70809df488":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"0521546db127e358ced1772a9d696dbdd255b203":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"377464b9f674227f6d755dce0dd14a01ad955b5e":["3702440de9629167be64098f307cea70809df488"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0521546db127e358ced1772a9d696dbdd255b203"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["e7b27dde701ae80df8bea8eb554d31e4e8bc6126"]},"commit2Childs":{"e7b27dde701ae80df8bea8eb554d31e4e8bc6126":["407687e67faf6e1f02a211ca078d8e3eed631027","5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"f54c29b684839e16d0a7ffd41ee8a1e93e905184":["0521546db127e358ced1772a9d696dbdd255b203"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e7b27dde701ae80df8bea8eb554d31e4e8bc6126","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"3702440de9629167be64098f307cea70809df488":["377464b9f674227f6d755dce0dd14a01ad955b5e"],"377464b9f674227f6d755dce0dd14a01ad955b5e":["f54c29b684839e16d0a7ffd41ee8a1e93e905184"],"0521546db127e358ced1772a9d696dbdd255b203":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["3702440de9629167be64098f307cea70809df488"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}