{"path":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","commits":[{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","pathOld":"/dev/null","sourceNew":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, false);\n    FakeScorer scorer = new FakeScorer();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new FakeScorer();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","pathOld":"/dev/null","sourceNew":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, false);\n    FakeScorer scorer = new FakeScorer();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new FakeScorer();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","sourceNew":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);\n    FakeScorer scorer = new FakeScorer();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new FakeScorer();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, false);\n    FakeScorer scorer = new FakeScorer();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new FakeScorer();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","date":1536316907,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","sourceNew":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);\n    ScoreAndDoc scorer = new ScoreAndDoc();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new ScoreAndDoc();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);\n    FakeScorer scorer = new FakeScorer();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new FakeScorer();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60a97329527e682292497dd2f6fae1c519840bae","date":1587668642,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector#testSetMinCompetitiveScore().mjava","sourceNew":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 2);\n    ScoreAndDoc scorer = new ScoreAndDoc();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertNull(scorer.minCompetitiveScore);\n    \n    scorer.doc = 2;\n    scorer.score = 3;\n    leafCollector.collect(2);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 3;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(3);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 4;\n    scorer.score = 4;\n    leafCollector.collect(4);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new ScoreAndDoc();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 4;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(4f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSetMinCompetitiveScore() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig().setMergePolicy(NoMergePolicy.INSTANCE));\n    Document doc = new Document();\n    w.addDocuments(Arrays.asList(doc, doc, doc, doc));\n    w.flush();\n    w.addDocuments(Arrays.asList(doc, doc));\n    w.flush();\n    IndexReader reader = DirectoryReader.open(w);\n    assertEquals(2, reader.leaves().size());\n    w.close();\n\n    TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);\n    ScoreAndDoc scorer = new ScoreAndDoc();\n\n    LeafCollector leafCollector = collector.getLeafCollector(reader.leaves().get(0));\n    leafCollector.setScorer(scorer);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertNull(scorer.minCompetitiveScore);\n\n    scorer.doc = 1;\n    scorer.score = 2;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(1f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 2;\n    scorer.score = 0.5f;\n    // Make sure we do not call setMinCompetitiveScore for non-competitive hits\n    scorer.minCompetitiveScore = Float.NaN;\n    leafCollector.collect(2);\n    assertTrue(Float.isNaN(scorer.minCompetitiveScore));\n\n    scorer.doc = 3;\n    scorer.score = 4;\n    leafCollector.collect(3);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    // Make sure the min score is set on scorers on new segments\n    scorer = new ScoreAndDoc();\n    leafCollector = collector.getLeafCollector(reader.leaves().get(1));\n    leafCollector.setScorer(scorer);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 0;\n    scorer.score = 1;\n    leafCollector.collect(0);\n    assertEquals(Math.nextUp(2f), scorer.minCompetitiveScore, 0f);\n\n    scorer.doc = 1;\n    scorer.score = 3;\n    leafCollector.collect(1);\n    assertEquals(Math.nextUp(3f), scorer.minCompetitiveScore, 0f);\n\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60a97329527e682292497dd2f6fae1c519840bae":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60a97329527e682292497dd2f6fae1c519840bae"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"417142ff08fda9cf0b72d5133e63097a166c6458":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc47cb7b4346802411bb432f501ed0673d7119e"]},"commit2Childs":{"60a97329527e682292497dd2f6fae1c519840bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["60a97329527e682292497dd2f6fae1c519840bae"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["fe3c6364bed04a73ad0884b05401d80ce96027a9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}