{"path":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","commits":[{"id":"828f199c76d70a5ea0ddc4d9605063f1d323a28d","date":1308738340,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"c26f00b574427b55127e869b935845554afde1fa":["828f199c76d70a5ea0ddc4d9605063f1d323a28d","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"2553b00f699380c64959ccb27991289aae87be2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","828f199c76d70a5ea0ddc4d9605063f1d323a28d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2553b00f699380c64959ccb27991289aae87be2e","828f199c76d70a5ea0ddc4d9605063f1d323a28d","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"828f199c76d70a5ea0ddc4d9605063f1d323a28d":["c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}