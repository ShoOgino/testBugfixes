{"path":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ed65f3455364344c6d2ff76ea5421aac754eae7","date":1353261762,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd != null && docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        if (docToOrd != null) {\n          perSegComp = new AnyDocToOrdComparator(docToOrd, termsIndex, docBase);\n        } else {\n          perSegComp = new AnyOrdComparator(termsIndex, docBase);\n        }\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29f7cc7c185412da66c1d0089d9e75da01329a00","date":1353364851,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      FieldComparator<BytesRef> perSegComp = new AnyOrdComparator(termsIndex, docBase);\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd != null && docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        if (docToOrd != null) {\n          perSegComp = new AnyDocToOrdComparator(docToOrd, termsIndex, docBase);\n        } else {\n          perSegComp = new AnyOrdComparator(termsIndex, docBase);\n        }\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      FieldComparator<BytesRef> perSegComp = new AnyOrdComparator(termsIndex, docBase);\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      FieldComparator<BytesRef> perSegComp = null;\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        if (arr instanceof byte[]) {\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n        // Don't specialize the long[] case since it's not\n        // possible, ie, worse case is MAX_INT-1 docs with\n        // every one having a unique value.\n      }\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);\n      }\n\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","3c71d502dea2f9d6ed3d8783f510ea3254435de9","9eed5547b2f58afdc475cc06312622f5bcf220c2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      FieldComparator<BytesRef> perSegComp = new AnyOrdComparator(termsIndex, docBase);\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81530aec3dade54d134a5bbf27fb31a590def317","date":1389812586,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n      //System.out.println(\"  setNextReader topOrd=\" + topOrd + \" topSameReader=\" + topSameReader);\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n      //System.out.println(\"  setNextReader topOrd=\" + topOrd + \" topSameReader=\" + topSameReader);\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      FieldComparator<BytesRef> perSegComp = new AnyOrdComparator(termsIndex, docBase);\n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc45495cddab770758da8a7fe79f01747b83c9ee","date":1392859277,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      termsIndex = getSortedDocValues(context, field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n      //System.out.println(\"  setNextReader topOrd=\" + topOrd + \" topSameReader=\" + topSameReader);\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      docBase = context.docBase;\n      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n      //System.out.println(\"  setNextReader topOrd=\" + topOrd + \" topSameReader=\" + topSameReader);\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"    @Override\n    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {\n      termsIndex = getSortedDocValues(context, field);\n      currentReaderGen++;\n\n      if (topValue != null) {\n        // Recompute topOrd/SameReader\n        int ord = termsIndex.lookupTerm(topValue);\n        if (ord >= 0) {\n          topSameReader = true;\n          topOrd = ord;\n        } else {\n          topSameReader = false;\n          topOrd = -ord-2;\n        }\n      } else {\n        topOrd = missingOrd;\n        topSameReader = true;\n      }\n      //System.out.println(\"  setNextReader topOrd=\" + topOrd + \" topSameReader=\" + topSameReader);\n\n      if (bottomSlot != -1) {\n        // Recompute bottomOrd/SameReader\n        setBottom(bottomSlot);\n      }\n\n      return this;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"81530aec3dade54d134a5bbf27fb31a590def317":["7615b855702e008d91a95a2578bf05d27372f599"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"29f7cc7c185412da66c1d0089d9e75da01329a00":["1ed65f3455364344c6d2ff76ea5421aac754eae7"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["d4d69c535930b5cce125cff868d40f6373dc27d4","81530aec3dade54d134a5bbf27fb31a590def317"],"bc45495cddab770758da8a7fe79f01747b83c9ee":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["bc45495cddab770758da8a7fe79f01747b83c9ee"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","29f7cc7c185412da66c1d0089d9e75da01329a00"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7615b855702e008d91a95a2578bf05d27372f599":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"]},"commit2Childs":{"81530aec3dade54d134a5bbf27fb31a590def317":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"29f7cc7c185412da66c1d0089d9e75da01329a00":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["bc45495cddab770758da8a7fe79f01747b83c9ee"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1ed65f3455364344c6d2ff76ea5421aac754eae7","d4d69c535930b5cce125cff868d40f6373dc27d4"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["29f7cc7c185412da66c1d0089d9e75da01329a00"],"bc45495cddab770758da8a7fe79f01747b83c9ee":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7615b855702e008d91a95a2578bf05d27372f599":["81530aec3dade54d134a5bbf27fb31a590def317"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}