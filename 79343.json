{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","commits":[{"id":"3b89f9365dec76fdc0fc53acb3664f3502497a07","date":1379201945,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,ComputedType).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)hex);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(hex);\n        } else {\n          methodVisitor.push((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)octal);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(octal);\n        } else {\n          methodVisitor.push((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.push(decimal);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, ComputedType expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), ComputedType.DOUBLE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.visitVarInsn(ALOAD, 2);\n        methodVisitor.push(index);\n        methodVisitor.visitInsn(AALOAD);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)hex);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(hex);\n        } else {\n          methodVisitor.visitLdcInsn((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == ComputedType.INT) {\n          methodVisitor.visitLdcInsn((int)octal);\n        } else if (expected == ComputedType.LONG) {\n          methodVisitor.visitLdcInsn(octal);\n        } else {\n          methodVisitor.visitLdcInsn((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.visitLdcInsn(decimal);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DNEG);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DADD);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DSUB);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DDIV);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DREM);\n        \n        typeCompile(expected, ComputedType.DOUBLE);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHL);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitInsn(LUSHR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LAND);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        recursiveCompile(current.getChild(1), ComputedType.LONG);\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), ComputedType.LONG);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        \n        typeCompile(expected, ComputedType.LONG);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.DOUBLE);\n        recursiveCompile(current.getChild(1), ComputedType.DOUBLE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), ComputedType.INT);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11e61935289a00a608fea62ca846bc38402d913b","date":1379202343,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.loadArg(0);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)hex);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(hex);\n        } else {\n          methodVisitor.push((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)octal);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(octal);\n        } else {\n          methodVisitor.push((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.push(decimal);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.visitVarInsn(ILOAD, 1);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)hex);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(hex);\n        } else {\n          methodVisitor.push((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)octal);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(octal);\n        } else {\n          methodVisitor.push((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.push(decimal);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06b29443688b24c8ad26729a4a05578e0c12a3bf","date":1379203716,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.loadArg(0);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        methodVisitor.push(Double.parseDouble(text));\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.loadArg(0);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        long hex = Long.parseLong(text.substring(2), 16);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)hex);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(hex);\n        } else {\n          methodVisitor.push((double)hex);\n        }\n        break;\n      case JavascriptParser.OCTAL:\n        long octal = Long.parseLong(text.substring(1), 8);\n        \n        if (expected == Type.INT_TYPE) {\n          methodVisitor.push((int)octal);\n        } else if (expected == Type.LONG_TYPE) {\n          methodVisitor.push(octal);\n        } else {\n          methodVisitor.push((double)octal);\n        }\n        break;\n      case JavascriptParser.DECIMAL:\n        double decimal = Double.parseDouble(text);\n        methodVisitor.push(decimal);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        truthCompile(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        truthCompile(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        truthCompile(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        truthCompile(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"210086cb958f3201adecda171f8de0b71d51e15b","date":1379203888,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DADD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DSUB);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DMUL);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DDIV);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DREM);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHL);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LUSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LAND);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.visitLdcInsn(new Long(-1));\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFEQ, labelEqTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelEqReturn);\n        gen.visitLabel(labelEqTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFNE, labelNeqTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelNeqReturn);\n        gen.visitLabel(labelNeqTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPG);\n        \n        gen.visitJumpInsn(IFLT, labelLtTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelLtReturn);\n        gen.visitLabel(labelLtTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFGT, labelGtTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelGtReturn);\n        gen.visitLabel(labelGtTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPG);\n        \n        gen.visitJumpInsn(IFLE, labelLteTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelLteReturn);\n        gen.visitLabel(labelLteTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFGE, labelGteTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelGteReturn);\n        gen.visitLabel(labelGteTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.visitJumpInsn(GOTO, andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.visitJumpInsn(GOTO, condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        methodVisitor.loadArg(1);\n        methodVisitor.push(index);\n        methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);\n        methodVisitor.loadArg(0);\n        methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        methodVisitor.push(Double.parseDouble(text));\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DNEG);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DADD);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DSUB);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(Opcodes.DMUL);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DDIV);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DREM);\n        methodVisitor.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHL);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitInsn(LUSHR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LAND);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        methodVisitor.visitLdcInsn(new Long(-1));\n        methodVisitor.visitInsn(LXOR);\n        methodVisitor.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFEQ, labelEqTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelEqReturn);\n        methodVisitor.visitLabel(labelEqTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFNE, labelNeqTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNeqReturn);\n        methodVisitor.visitLabel(labelNeqTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLT, labelLtTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLtReturn);\n        methodVisitor.visitLabel(labelLtTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGT, labelGtTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGtReturn);\n        methodVisitor.visitLabel(labelGtTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPG);\n        \n        methodVisitor.visitJumpInsn(IFLE, labelLteTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelLteReturn);\n        methodVisitor.visitLabel(labelLteTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        methodVisitor.visitInsn(DCMPL);\n        \n        methodVisitor.visitJumpInsn(IFGE, labelGteTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelGteReturn);\n        methodVisitor.visitLabel(labelGteTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, labelNotReturn);\n        methodVisitor.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        methodVisitor.visitJumpInsn(GOTO, andEnd);\n        methodVisitor.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        methodVisitor.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        methodVisitor.visitJumpInsn(GOTO, orEnd);\n        methodVisitor.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        methodVisitor.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        methodVisitor.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        methodVisitor.visitJumpInsn(GOTO, condEnd);\n        methodVisitor.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        methodVisitor.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8051827cb52e78e83af70a999a17b97bf0cf00a2","date":1379206124,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DADD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DSUB);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DMUL);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DDIV);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DREM);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHL);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LUSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LAND);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        compileCompare(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        compileCompare(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        compileCompare(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        compileCompare(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        compileCompare(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        compileCompare(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DADD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DSUB);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DMUL);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DDIV);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DREM);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHL);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LUSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LAND);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.visitLdcInsn(new Long(-1));\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        Label labelEqTrue = new Label();\n        Label labelEqReturn = new Label();\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFEQ, labelEqTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelEqReturn);\n        gen.visitLabel(labelEqTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelEqReturn);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        Label labelNeqTrue = new Label();\n        Label labelNeqReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFNE, labelNeqTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelNeqReturn);\n        gen.visitLabel(labelNeqTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNeqReturn);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        Label labelLtTrue = new Label();\n        Label labelLtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPG);\n        \n        gen.visitJumpInsn(IFLT, labelLtTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelLtReturn);\n        gen.visitLabel(labelLtTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelLtReturn);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        Label labelGtTrue = new Label();\n        Label labelGtReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFGT, labelGtTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelGtReturn);\n        gen.visitLabel(labelGtTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelGtReturn);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        Label labelLteTrue = new Label();\n        Label labelLteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPG);\n        \n        gen.visitJumpInsn(IFLE, labelLteTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelLteReturn);\n        gen.visitLabel(labelLteTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelLteReturn);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        Label labelGteTrue = new Label();\n        Label labelGteReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DCMPL);\n        \n        gen.visitJumpInsn(IFGE, labelGteTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelGteReturn);\n        gen.visitLabel(labelGteTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelGteReturn);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.visitJumpInsn(GOTO, andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.visitJumpInsn(GOTO, orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.visitJumpInsn(GOTO, condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a160962dae3bcb62faf6b0daf05a14242939f2b","date":1379207968,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DADD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DSUB);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DMUL);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DDIV);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        recursiveCompile(current.getChild(1), Type.DOUBLE_TYPE);\n        gen.visitInsn(DREM);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHL);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitInsn(LUSHR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LAND);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        recursiveCompile(current.getChild(1), Type.LONG_TYPE);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);            \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        compileCompare(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        compileCompare(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        compileCompare(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        compileCompare(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        compileCompare(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        compileCompare(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0aa1146400d5a0c1c485e05b3bf808d94edc4d8","date":1379241550,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f0e44787cffbb978aa2182761e3f9b184545a1e","date":1379265303,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"/dev/null","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d639dc27b5b3eae561ef321b06f3cad9280c529","date":1383945027,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.NAMESPACE_ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["5b6aa541ae5bb3c0260e1c263d6897a7925fa00c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b6aa541ae5bb3c0260e1c263d6897a7925fa00c","date":1404947938,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.VARIABLE:\n        int index;\n\n        // normalize quotes\n        text = normalizeQuotes(text);\n\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.NAMESPACE_ID:\n        int index;\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":["8d639dc27b5b3eae561ef321b06f3cad9280c529"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8344f9e8b303df6f90068c5dc0bcfaccc0f74a","date":1429899342,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null && (arguments > 0 || !call.contains(\".\"))) {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + call + \").\");\n        } else if (method != null) {\n          int arity = method.getParameterTypes().length;\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for function call (\" +\n                call + \"), but found (\" + arguments + \").\");\n          }\n\n          for (int argument = 1; argument <= arguments; ++argument) {\n            recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n          }\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, expected);\n          break;\n        } else {\n          text = call + \"()\";\n          // intentionally fall through to the variable case to allow this non-static\n          // method to be forwarded to the bindings for processing\n        }\n      case JavascriptParser.VARIABLE:\n        int index;\n\n        text = normalizeQuotes(text);\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null) {\n          throw new IllegalArgumentException(\"Unrecognized method call (\" + call + \").\");\n        }\n        \n        int arity = method.getParameterTypes().length;\n        if (arguments != arity) {\n          throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for method call (\" +\n              call + \"), but found (\" + arguments + \").\");\n        }\n        \n        for (int argument = 1; argument <= arguments; ++argument) {\n          recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n        }\n        \n        gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n          org.objectweb.asm.commons.Method.getMethod(method));\n        \n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.VARIABLE:\n        int index;\n\n        // normalize quotes\n        text = normalizeQuotes(text);\n\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d23d4828afa583ebf35b4a541763af6206133458","date":1438931440,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#recursiveCompile(Tree,Type).mjava","sourceNew":null,"sourceOld":"  private void recursiveCompile(Tree current, Type expected) {\n    int type = current.getType();\n    String text = current.getText();\n    \n    switch (type) {\n      case JavascriptParser.AT_CALL:\n        Tree identifier = current.getChild(0);\n        String call = identifier.getText();\n        int arguments = current.getChildCount() - 1;\n        \n        Method method = functions.get(call);\n        if (method == null && (arguments > 0 || !call.contains(\".\"))) {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + call + \").\");\n        } else if (method != null) {\n          int arity = method.getParameterTypes().length;\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\"Expected (\" + arity + \") arguments for function call (\" +\n                call + \"), but found (\" + arguments + \").\");\n          }\n\n          for (int argument = 1; argument <= arguments; ++argument) {\n            recursiveCompile(current.getChild(argument), Type.DOUBLE_TYPE);\n          }\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, expected);\n          break;\n        } else {\n          text = call + \"()\";\n          // intentionally fall through to the variable case to allow this non-static\n          // method to be forwarded to the bindings for processing\n        }\n      case JavascriptParser.VARIABLE:\n        int index;\n\n        text = normalizeQuotes(text);\n        \n        if (externalsMap.containsKey(text)) {\n          index = externalsMap.get(text);\n        } else {\n          index = externalsMap.size();\n          externalsMap.put(text, index);\n        }\n        \n        gen.loadArg(1);\n        gen.push(index);\n        gen.arrayLoad(FUNCTION_VALUES_TYPE);\n        gen.loadArg(0);\n        gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.HEX:\n        pushLong(expected, Long.parseLong(text.substring(2), 16));\n        break;\n      case JavascriptParser.OCTAL:\n        pushLong(expected, Long.parseLong(text.substring(1), 8));\n        break;\n      case JavascriptParser.DECIMAL:\n        gen.push(Double.parseDouble(text));\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_NEGATE:\n        recursiveCompile(current.getChild(0), Type.DOUBLE_TYPE);\n        gen.visitInsn(Opcodes.DNEG);\n        gen.cast(Type.DOUBLE_TYPE, expected);\n        break;\n      case JavascriptParser.AT_ADD:\n        pushArith(Opcodes.DADD, current, expected);\n        break;\n      case JavascriptParser.AT_SUBTRACT:\n        pushArith(Opcodes.DSUB, current, expected);\n        break;\n      case JavascriptParser.AT_MULTIPLY:\n        pushArith(Opcodes.DMUL, current, expected);\n        break;\n      case JavascriptParser.AT_DIVIDE:\n        pushArith(Opcodes.DDIV, current, expected);\n        break;\n      case JavascriptParser.AT_MODULO:\n        pushArith(Opcodes.DREM, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHL:\n        pushShift(Opcodes.LSHL, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHR:\n        pushShift(Opcodes.LSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_SHU:\n        pushShift(Opcodes.LUSHR, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_AND:\n        pushBitwise(Opcodes.LAND, current, expected);\n        break;\n      case JavascriptParser.AT_BIT_OR:\n        pushBitwise(Opcodes.LOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_XOR:\n        pushBitwise(Opcodes.LXOR, current, expected);           \n        break;\n      case JavascriptParser.AT_BIT_NOT:\n        recursiveCompile(current.getChild(0), Type.LONG_TYPE);\n        gen.push(-1L);\n        gen.visitInsn(Opcodes.LXOR);\n        gen.cast(Type.LONG_TYPE, expected);\n        break;\n      case JavascriptParser.AT_COMP_EQ:\n        pushCond(GeneratorAdapter.EQ, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_NEQ:\n        pushCond(GeneratorAdapter.NE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LT:\n        pushCond(GeneratorAdapter.LT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GT:\n        pushCond(GeneratorAdapter.GT, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_LTE:\n        pushCond(GeneratorAdapter.LE, current, expected);\n        break;\n      case JavascriptParser.AT_COMP_GTE:\n        pushCond(GeneratorAdapter.GE, current, expected);\n        break;\n      case JavascriptParser.AT_BOOL_NOT:\n        Label labelNotTrue = new Label();\n        Label labelNotReturn = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n        pushBoolean(expected, false);\n        gen.goTo(labelNotReturn);\n        gen.visitLabel(labelNotTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(labelNotReturn);\n        break;\n      case JavascriptParser.AT_BOOL_AND:\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        pushBoolean(expected, true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(expected, false);\n        gen.visitLabel(andEnd);\n        break;\n      case JavascriptParser.AT_BOOL_OR:\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        recursiveCompile(current.getChild(1), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        pushBoolean(expected, false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(expected, true);\n        gen.visitLabel(orEnd);\n        break;\n      case JavascriptParser.AT_COND_QUE:\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n        \n        recursiveCompile(current.getChild(0), Type.INT_TYPE);\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        recursiveCompile(current.getChild(1), expected);\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        recursiveCompile(current.getChild(2), expected);\n        gen.visitLabel(condEnd);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown operation specified: (\" + current.getText() + \").\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d23d4828afa583ebf35b4a541763af6206133458":["bc8344f9e8b303df6f90068c5dc0bcfaccc0f74a"],"f0aa1146400d5a0c1c485e05b3bf808d94edc4d8":["7a160962dae3bcb62faf6b0daf05a14242939f2b"],"8d639dc27b5b3eae561ef321b06f3cad9280c529":["5f0e44787cffbb978aa2182761e3f9b184545a1e"],"8051827cb52e78e83af70a999a17b97bf0cf00a2":["210086cb958f3201adecda171f8de0b71d51e15b"],"3b89f9365dec76fdc0fc53acb3664f3502497a07":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7a160962dae3bcb62faf6b0daf05a14242939f2b":["8051827cb52e78e83af70a999a17b97bf0cf00a2"],"11e61935289a00a608fea62ca846bc38402d913b":["3b89f9365dec76fdc0fc53acb3664f3502497a07"],"06b29443688b24c8ad26729a4a05578e0c12a3bf":["11e61935289a00a608fea62ca846bc38402d913b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"210086cb958f3201adecda171f8de0b71d51e15b":["06b29443688b24c8ad26729a4a05578e0c12a3bf"],"5b6aa541ae5bb3c0260e1c263d6897a7925fa00c":["8d639dc27b5b3eae561ef321b06f3cad9280c529"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d23d4828afa583ebf35b4a541763af6206133458"],"bc8344f9e8b303df6f90068c5dc0bcfaccc0f74a":["5b6aa541ae5bb3c0260e1c263d6897a7925fa00c"],"5f0e44787cffbb978aa2182761e3f9b184545a1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0aa1146400d5a0c1c485e05b3bf808d94edc4d8"]},"commit2Childs":{"d23d4828afa583ebf35b4a541763af6206133458":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0aa1146400d5a0c1c485e05b3bf808d94edc4d8":["5f0e44787cffbb978aa2182761e3f9b184545a1e"],"8d639dc27b5b3eae561ef321b06f3cad9280c529":["5b6aa541ae5bb3c0260e1c263d6897a7925fa00c"],"8051827cb52e78e83af70a999a17b97bf0cf00a2":["7a160962dae3bcb62faf6b0daf05a14242939f2b"],"3b89f9365dec76fdc0fc53acb3664f3502497a07":["11e61935289a00a608fea62ca846bc38402d913b"],"7a160962dae3bcb62faf6b0daf05a14242939f2b":["f0aa1146400d5a0c1c485e05b3bf808d94edc4d8"],"11e61935289a00a608fea62ca846bc38402d913b":["06b29443688b24c8ad26729a4a05578e0c12a3bf"],"06b29443688b24c8ad26729a4a05578e0c12a3bf":["210086cb958f3201adecda171f8de0b71d51e15b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b89f9365dec76fdc0fc53acb3664f3502497a07","5f0e44787cffbb978aa2182761e3f9b184545a1e"],"210086cb958f3201adecda171f8de0b71d51e15b":["8051827cb52e78e83af70a999a17b97bf0cf00a2"],"5b6aa541ae5bb3c0260e1c263d6897a7925fa00c":["bc8344f9e8b303df6f90068c5dc0bcfaccc0f74a"],"bc8344f9e8b303df6f90068c5dc0bcfaccc0f74a":["d23d4828afa583ebf35b4a541763af6206133458"],"5f0e44787cffbb978aa2182761e3f9b184545a1e":["8d639dc27b5b3eae561ef321b06f3cad9280c529"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}