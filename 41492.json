{"path":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) return;\n    Set<State> initialset = new HashSet<State>();\n    initialset.add(a.initial);\n    determinize(a, initialset);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJ_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Complexity: exponential in number of states.\n   */\n  public static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) return;\n    Set<State> initialset = new HashSet<State>();\n    initialset.add(a.initial);\n    determinize(a, initialset);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4769bdea5a853f1841c485bc1fd9d79cb7022fc","date":1292168168,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              newStatesArray = ArrayUtil.grow(newStatesArray);\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJ_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4fc28d227571aea72029cf9096fcf7d3865a6b40","date":1292211129,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              newStatesArray = ArrayUtil.grow(newStatesArray);\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJ_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJ_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(Automaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  static void determinize(Automaton a) {\n    if (a.deterministic || a.isSingleton()) {\n      return;\n    }\n\n    final State[] allStates = a.getNumberedStates();\n\n    // subset construction\n    final boolean initAccept = a.initial.accept;\n    final int initNumber = a.initial.number;\n    a.initial = new State();\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(initNumber, a.initial);\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<SortedIntSet.FrozenIntSet>();\n    Map<SortedIntSet.FrozenIntSet,State> newstate = new HashMap<SortedIntSet.FrozenIntSet,State>();\n\n    worklist.add(initialset);\n\n    a.initial.accept = initAccept;\n    newstate.put(initialset, a.initial);\n\n    int newStateUpto = 0;\n    State[] newStatesArray = new State[5];\n    newStatesArray[newStateUpto] = a.initial;\n    a.initial.number = newStateUpto;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final State s0 = allStates[s.values[i]];\n        for(int j=0;j<s0.numTransitions;j++) {\n          points.add(s0.transitionsArray[j]);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final State r = s.state;\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          State q = newstate.get(statesSet);\n          if (q == null) {\n            q = new State();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            worklist.add(p);\n            if (newStateUpto == newStatesArray.length) {\n              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);\n              newStatesArray = newArray;\n            }\n            newStatesArray[newStateUpto] = q;\n            q.number = newStateUpto;\n            newStateUpto++;\n            q.accept = accCount > 0;\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == q.accept: \"accCount=\" + accCount + \" vs existing accept=\" + q.accept + \" states=\" + statesSet;\n          }\n\n          r.addTransition(new Transition(lastPoint, point-1, q));\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        Transition[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.decr(num);\n          accCount -= t.to.accept ? 1:0;\n        }\n        points.points[i].ends.count = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.count;\n        for(int j=0;j<limit;j++) {\n          final Transition t = transitions[j];\n          final Integer num = t.to.number;\n          statesSet.incr(num);\n          accCount += t.to.accept ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.count = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n    a.deterministic = true;\n    a.setNumberedStates(newStatesArray, newStateUpto);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4fc28d227571aea72029cf9096fcf7d3865a6b40"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","4fc28d227571aea72029cf9096fcf7d3865a6b40"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","4fc28d227571aea72029cf9096fcf7d3865a6b40"],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4fc28d227571aea72029cf9096fcf7d3865a6b40":["d4769bdea5a853f1841c485bc1fd9d79cb7022fc"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d4769bdea5a853f1841c485bc1fd9d79cb7022fc":["4fc28d227571aea72029cf9096fcf7d3865a6b40"],"4fc28d227571aea72029cf9096fcf7d3865a6b40":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}