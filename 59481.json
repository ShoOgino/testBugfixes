{"path":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","commits":[{"id":"50e7972fe4865715af8951d4ba15555e3426fc5d","date":1115024647,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 3*PTR; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8f14489323057ef6de92ba5ea2d0cfe6e34755f","date":1120167605,"type":3,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"\t/**\r\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\r\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\r\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\r\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\r\n\t */\r\n\tpublic int getMemorySize() {\r\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\r\n\t\tint HEADER = 12; // object header of any java object\r\n\t\tint PTR = 4; // pointer on 32 bit VMs\r\n\t\tint ARR = HEADER + 4;\r\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\r\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\r\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\r\n\t\t\r\n\t\tint size = 0;\r\n\t\tsize += HEADER + 3*PTR; // memory index\r\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\r\n\t\tif (sortedTemplates != null) size += ARR + PTR * sortedTemplates.length;\r\n\t\t\r\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\r\n\t\tIterator iter = fields.entrySet().iterator();\r\n\t\twhile (iter.hasNext()) { // for each Field Info\r\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\r\n\t\t\tInfo info = (Info) entry.getValue();\r\n\t\t\tsize += HEADER + 4 + PTR + PTR; // Info instance vars\r\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\r\n\t\t\t\r\n\t\t\tint len = info.terms.size();\r\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\r\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\r\n\t\t\twhile (--len >= 0) { // for each term\r\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\r\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\r\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\r\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\r\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn size;\r\n\t}\t\r\n\n","sourceOld":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 3*PTR; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35dd40ede4dd66fa47506858c4a073d295c5a76e","date":1133587328,"type":4,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"/dev/null","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":null,"sourceOld":"\t/**\r\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\r\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\r\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\r\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\r\n\t */\r\n\tpublic int getMemorySize() {\r\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\r\n\t\tint HEADER = 12; // object header of any java object\r\n\t\tint PTR = 4; // pointer on 32 bit VMs\r\n\t\tint ARR = HEADER + 4;\r\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\r\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\r\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\r\n\t\t\r\n\t\tint size = 0;\r\n\t\tsize += HEADER + 3*PTR; // memory index\r\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\r\n\t\tif (sortedTemplates != null) size += ARR + PTR * sortedTemplates.length;\r\n\t\t\r\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\r\n\t\tIterator iter = fields.entrySet().iterator();\r\n\t\twhile (iter.hasNext()) { // for each Field Info\r\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\r\n\t\t\tInfo info = (Info) entry.getValue();\r\n\t\t\tsize += HEADER + 4 + PTR + PTR; // Info instance vars\r\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\r\n\t\t\t\r\n\t\t\tint len = info.terms.size();\r\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\r\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\r\n\t\t\twhile (--len >= 0) { // for each term\r\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\r\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\r\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\r\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\r\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn size;\r\n\t}\t\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a93e1e4a21be8ebb98e53e6933412a363931faa1","date":1133587471,"type":0,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 2*PTR + 4; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b08308242cb802f3a154e260d3881c2ed523c52b","date":1133766662,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t * \n\t * @return the main memory consumption\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 2*PTR + 4; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","sourceOld":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 2*PTR + 4; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f68e24227d5556d33ee6d586fd9010cd9ff8bec","date":1150091176,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 12; // object header of any java object\n    int PTR = 4; // pointer on 32 bit VMs\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"\t/**\n\t * Returns a reasonable approximation of the main memory [bytes] consumed by\n\t * this instance. Useful for smart memory sensititve caches/pools. Assumes\n\t * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n\t * simplicity, assumes no VM word boundary alignment of instance vars.\n\t * \n\t * @return the main memory consumption\n\t */\n\tpublic int getMemorySize() {\n\t\t// for example usage in a smart cache see nux.xom.pool.Pool\n\t\tint HEADER = 12; // object header of any java object\n\t\tint PTR = 4; // pointer on 32 bit VMs\n\t\tint ARR = HEADER + 4;\n\t\tint STR = HEADER + 3*4 + PTR + ARR; // string\n\t\tint INTARRLIST = HEADER + 4 + PTR + ARR;\n\t\tint HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n\t\t\n\t\tint size = 0;\n\t\tsize += HEADER + 2*PTR + 4; // memory index\n\t\tif (sortedFields != null) size += ARR + PTR * sortedFields.length;\n\t\t\n\t\tsize += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\tIterator iter = fields.entrySet().iterator();\n\t\twhile (iter.hasNext()) { // for each Field Info\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\t\t\t\n\t\t\tInfo info = (Info) entry.getValue();\n\t\t\tsize += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n\t\t\tif (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n\t\t\t\n\t\t\tint len = info.terms.size();\n\t\t\tsize += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n\t\t\tIterator iter2 = info.terms.entrySet().iterator();\n\t\t\twhile (--len >= 0) { // for each term\n\t\t\t\tMap.Entry e = (Map.Entry) iter2.next();\n\t\t\t\tsize += STR - ARR; // assumes substring() memory overlay\n//\t\t\t\tsize += STR + 2 * ((String) e.getKey()).length();\n\t\t\t\tArrayIntList positions = (ArrayIntList) e.getValue();\n\t\t\t\tsize += INTARRLIST + 4*positions.size();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\t\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a2dfe27dcd813920f9df8dbd28079c6e6b9e93e","date":1159427430,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 12; // object header of any java object\n    int PTR = 4; // pointer on 32 bit VMs\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 12; // object header of any java object\n    int PTR = 4; // pointer on 32 bit VMs\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aa914b6879b18e9931378cc77b7911fc32ef0f1","date":1163700836,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 2*PTR; // object header of any java object\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 12; // object header of any java object\n    int PTR = 4; // pointer on 32 bit VMs\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3152c5a8024c769c20b6eeec4fcb04097d750874","date":1163744279,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    int HEADER = 2*PTR; // object header of any java object\n    int ARR = HEADER + 4;\n    int STR = HEADER + 3*4 + PTR + ARR; // string\n    int INTARRLIST = HEADER + 4 + PTR + ARR;\n    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;\n    \n    int size = 0;\n    size += HEADER + 2*PTR + 4; // memory index\n    if (sortedFields != null) size += ARR + PTR * sortedFields.length;\n    \n    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += HEADER + 4 + 4 + PTR + PTR + PTR; // Info instance vars\n      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;\n      \n      int len = info.terms.size();\n      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += STR - ARR; // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += INTARRLIST + 4*positions.size();\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"145c78dcf66ec62de7b0152032895ff7095c21f3","date":1164176882,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititve caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For\n   * simplicity, assumes no VM word boundary alignment of instance vars.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool\n    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f11899016a0460a7ea2e4b008d002e1e75c7d867","date":1256772085,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    Iterator iter = fields.entrySet().iterator();\n    while (iter.hasNext()) { // for each Field Info\n      Map.Entry entry = (Map.Entry) iter.next();      \n      Info info = (Info) entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry e = (Map.Entry) iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = (ArrayIntList) e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"35dd40ede4dd66fa47506858c4a073d295c5a76e":["c8f14489323057ef6de92ba5ea2d0cfe6e34755f"],"b08308242cb802f3a154e260d3881c2ed523c52b":["a93e1e4a21be8ebb98e53e6933412a363931faa1"],"c8f14489323057ef6de92ba5ea2d0cfe6e34755f":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"145c78dcf66ec62de7b0152032895ff7095c21f3":["3152c5a8024c769c20b6eeec4fcb04097d750874"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["b08308242cb802f3a154e260d3881c2ed523c52b"],"3152c5a8024c769c20b6eeec4fcb04097d750874":["1aa914b6879b18e9931378cc77b7911fc32ef0f1"],"a93e1e4a21be8ebb98e53e6933412a363931faa1":["35dd40ede4dd66fa47506858c4a073d295c5a76e"],"1aa914b6879b18e9931378cc77b7911fc32ef0f1":["3a2dfe27dcd813920f9df8dbd28079c6e6b9e93e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50e7972fe4865715af8951d4ba15555e3426fc5d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a2dfe27dcd813920f9df8dbd28079c6e6b9e93e":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["145c78dcf66ec62de7b0152032895ff7095c21f3"]},"commit2Childs":{"35dd40ede4dd66fa47506858c4a073d295c5a76e":["a93e1e4a21be8ebb98e53e6933412a363931faa1"],"b08308242cb802f3a154e260d3881c2ed523c52b":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"c8f14489323057ef6de92ba5ea2d0cfe6e34755f":["35dd40ede4dd66fa47506858c4a073d295c5a76e"],"145c78dcf66ec62de7b0152032895ff7095c21f3":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["3a2dfe27dcd813920f9df8dbd28079c6e6b9e93e"],"3152c5a8024c769c20b6eeec4fcb04097d750874":["145c78dcf66ec62de7b0152032895ff7095c21f3"],"a93e1e4a21be8ebb98e53e6933412a363931faa1":["b08308242cb802f3a154e260d3881c2ed523c52b"],"1aa914b6879b18e9931378cc77b7911fc32ef0f1":["3152c5a8024c769c20b6eeec4fcb04097d750874"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"50e7972fe4865715af8951d4ba15555e3426fc5d":["c8f14489323057ef6de92ba5ea2d0cfe6e34755f"],"3a2dfe27dcd813920f9df8dbd28079c6e6b9e93e":["1aa914b6879b18e9931378cc77b7911fc32ef0f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["9454a6510e2db155fb01faa5c049b06ece95fab9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}