{"path":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","commits":[{"id":"859b2291aebaa8cffe0ab3f919fc27e980c23999","date":1534305849,"type":0,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","pathOld":"/dev/null","sourceNew":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11d6383c8f942fbf6f463c167383e952d927aca0","date":1534307117,"type":0,"author":"Erick Erickson","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","pathOld":"/dev/null","sourceNew":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c843fa9bddf5f2c12667fc941acd33da03c62a3","date":1535566664,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","sourceNew":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","sourceOld":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-from-extract-contrib\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"695a2ea9bbdf1f04153f1f6f0fa8595f3694b58f","date":1561505163,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/ParsingFieldUpdateProcessorsTest#testISO8601().mjava","sourceNew":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertThat(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\"), IS_DATE);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertThat(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\"), IS_DATE);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","sourceOld":"  // tests that mimic the tests that were in TestExtractionDateUtil\n  public void testISO8601() throws IOException {\n    // dates with atypical years\n    // This test tries to mimic TestExtractionDateUtil#testISO8601\n\n    String[] dateStrings = {\n        \"0001-01-01T01:01:01Z\", \"+12021-12-01T03:03:03Z\",\n        \"0000-04-04T04:04:04Z\", \"-0005-05-05T05:05:05Z\",\n        \"-2021-12-01T04:04:04Z\", \"-12021-12-01T02:02:02Z\"\n    };\n\n    int id = 1;\n\n    // ensure strings are parsed\n    for(String notInFormatDateString: dateStrings) {\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", notInFormatDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + notInFormatDateString + \" was not parsed as a date\", d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(notInFormatDateString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      assertU(commit());\n      assertQ(req(\"id:\" + id), \"//date[@name='date_dt'][.='\" + notInFormatDateString + \"']\");\n      ++id;\n    }\n\n    // odd values are date strings, even values are expected strings\n    String[] lenientDateStrings = {\n        \"10995-12-31T23:59:59.990Z\", \"+10995-12-31T23:59:59.990Z\",\n        \"995-1-2T3:4:5Z\", \"0995-01-02T03:04:05Z\",\n        \"2021-01-01t03:04:05\", \"2021-01-01T03:04:05Z\",\n        \"2021-12-01 04:04:04\", \"2021-12-01T04:04:04Z\"\n    };\n\n    // ensure sure strings that should be parsed using lenient resolver are properly parsed\n    for(int i = 0; i < lenientDateStrings.length; ++i) {\n      String lenientDateString = lenientDateStrings[i];\n      String expectedString = lenientDateStrings[++i];\n      IndexSchema schema = h.getCore().getLatestSchema();\n      assertNotNull(schema.getFieldOrNull(\"date_dt\")); // should match \"*_dt\" dynamic field\n      SolrInputDocument d = processAdd(\"parse-date-patterns-default-config\", doc(f(\"id\", id), f(\"date_dt\", lenientDateString)));\n      assertNotNull(d);\n      assertTrue(\"Date string: \" + lenientDateString + \" was not parsed as a date\",\n          d.getFieldValue(\"date_dt\") instanceof Date);\n      assertEquals(expectedString, ((Date) d.getField(\"date_dt\").getFirstValue()).toInstant().toString());\n      ++id;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"859b2291aebaa8cffe0ab3f919fc27e980c23999":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"695a2ea9bbdf1f04153f1f6f0fa8595f3694b58f":["2c843fa9bddf5f2c12667fc941acd33da03c62a3"],"11d6383c8f942fbf6f463c167383e952d927aca0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","859b2291aebaa8cffe0ab3f919fc27e980c23999"],"2c843fa9bddf5f2c12667fc941acd33da03c62a3":["11d6383c8f942fbf6f463c167383e952d927aca0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["695a2ea9bbdf1f04153f1f6f0fa8595f3694b58f"]},"commit2Childs":{"859b2291aebaa8cffe0ab3f919fc27e980c23999":["11d6383c8f942fbf6f463c167383e952d927aca0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["859b2291aebaa8cffe0ab3f919fc27e980c23999","11d6383c8f942fbf6f463c167383e952d927aca0"],"695a2ea9bbdf1f04153f1f6f0fa8595f3694b58f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"11d6383c8f942fbf6f463c167383e952d927aca0":["2c843fa9bddf5f2c12667fc941acd33da03c62a3"],"2c843fa9bddf5f2c12667fc941acd33da03c62a3":["695a2ea9bbdf1f04153f1f6f0fa8595f3694b58f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}