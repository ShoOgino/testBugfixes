{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"/dev/null","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // nocommit this is hacky:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(50);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits;\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits;\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      System.out.println(\"NOW FLUSH\");\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // nocommit this is hacky:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(50);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits;\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort);\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), 1).totalHits;\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      System.out.println(\"NOW FLUSH\");\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort);\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort);\n          newNRTPoint(version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"/dev/null","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"body\", \"the\")));\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new MatchAllDocsQuery());\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"body\", \"the\")));\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new MatchAllDocsQuery());\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimpleReplicaNode#handleOneConnection(ServerSocket,AtomicBoolean,InputStream,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"body\", \"the\")));\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new MatchAllDocsQuery());\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","sourceOld":"  /** Handles incoming request to the naive TCP server wrapping this node */\n  void handleOneConnection(ServerSocket ss, AtomicBoolean stop, InputStream is, Socket socket, DataInput in, DataOutput out, BufferedOutputStream bos) throws IOException, InterruptedException {\n    //message(\"one connection: \" + socket);\n    outer:\n    while (true) {\n      byte cmd;\n      while (true) {\n        if (is.available() > 0) {\n          break;\n        }\n        if (stop.get()) {\n          return;\n        }\n        Thread.sleep(10);\n      }\n\n      try {\n        cmd = in.readByte();\n      } catch (EOFException eofe) {\n        break;\n      }\n\n      switch(cmd) {\n      case CMD_NEW_NRT_POINT:\n        {\n          long version = in.readVLong();\n          long newPrimaryGen = in.readVLong();\n          Thread.currentThread().setName(\"recv-\" + version);\n          curPrimaryTCPPort = in.readInt();\n          message(\"newNRTPoint primaryTCPPort=\" + curPrimaryTCPPort + \" version=\" + version + \" newPrimaryGen=\" + newPrimaryGen);\n          newNRTPoint(newPrimaryGen, version);\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_GET_SEARCHING_VERSION:\n        // This is called when primary has crashed and we need to elect a new primary from all the still running replicas:\n\n        // Tricky: if a sync is just finishing up, i.e. managed to finish copying all files just before we crashed primary, and is now\n        // in the process of opening a new reader, we need to wait for it, to be sure we really pick the most current replica:\n        if (isCopying()) {\n          message(\"top: getSearchingVersion: now wait for finish sync\");\n          // TODO: use immediate concurrency instead of polling:\n          while (isCopying() && stop.get() == false) {\n            Thread.sleep(10);\n            message(\"top: curNRTCopy=\" + curNRTCopy);\n          }\n          message(\"top: getSearchingVersion: done wait for finish sync\");\n        }\n        if (stop.get() == false) {\n          out.writeVLong(getCurrentSearchingVersion());\n        } else {\n          message(\"top: getSearchingVersion: stop waiting for finish sync: stop is set\");\n        }\n        break;\n\n      case SimplePrimaryNode.CMD_SEARCH:\n        {\n          Thread.currentThread().setName(\"search\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new TermQuery(new Term(\"body\", \"the\")), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_SEARCH_ALL:\n        {\n          Thread.currentThread().setName(\"search all\");\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.search(new MatchAllDocsQuery(), 1).totalHits;\n            //node.message(\"version=\" + version + \" searcher=\" + searcher);\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_MARKER_SEARCH:\n        {\n          Thread.currentThread().setName(\"msearch\");\n          int expectedAtLeastCount = in.readVInt();\n          IndexSearcher searcher = mgr.acquire();\n          try {\n            long version = ((DirectoryReader) searcher.getIndexReader()).getVersion();\n            int hitCount = searcher.count(new TermQuery(new Term(\"marker\", \"marker\")));\n            if (hitCount < expectedAtLeastCount) {\n              message(\"marker search: expectedAtLeastCount=\" + expectedAtLeastCount + \" but hitCount=\" + hitCount);\n              TopDocs hits = searcher.search(new TermQuery(new Term(\"marker\", \"marker\")), expectedAtLeastCount);\n              List<Integer> seen = new ArrayList<>();\n              for(ScoreDoc hit : hits.scoreDocs) {\n                Document doc = searcher.doc(hit.doc);\n                seen.add(Integer.parseInt(doc.get(\"docid\").substring(1)));\n              }\n              Collections.sort(seen);\n              message(\"saw markers:\");\n              for(int marker : seen) {\n                message(\"saw m\" + marker);\n              }\n            }\n\n            out.writeVLong(version);\n            out.writeVInt(hitCount);\n            bos.flush();\n          } finally {\n            mgr.release(searcher);\n          }\n        }\n        continue outer;\n\n      case SimplePrimaryNode.CMD_COMMIT:\n        Thread.currentThread().setName(\"commit\");\n        commit();\n        out.writeByte((byte) 1);\n        break;\n\n      case SimplePrimaryNode.CMD_CLOSE:\n        Thread.currentThread().setName(\"close\");\n        ss.close();\n        out.writeByte((byte) 1);\n        break outer;\n\n      case CMD_PRE_COPY_MERGE:\n        Thread.currentThread().setName(\"merge copy\");\n\n        long newPrimaryGen = in.readVLong();\n        curPrimaryTCPPort = in.readVInt();\n        Map<String,FileMetaData> files = SimpleServer.readFilesMetaData(in);\n        message(\"done reading files to copy files=\" + files.keySet());\n        AtomicBoolean finished = new AtomicBoolean();\n        CopyJob job = launchPreCopyMerge(finished, newPrimaryGen, files);\n        message(\"done launching copy job files=\" + files.keySet());\n\n        // Silly keep alive mechanism, else if e.g. we (replica node) crash, the primary\n        // won't notice for a very long time:\n        boolean success = false;\n        try {\n          int count = 0;\n          while (true) {\n            if (finished.get() || stop.get()) {\n              break;\n            }\n            Thread.sleep(10);\n            count++;\n            if (count == 100) {\n              // Once per second or so, we send a keep alive\n              message(\"send merge pre copy keep alive... files=\" + files.keySet());\n\n              // To be evil, we sometimes fail to keep-alive, e.g. simulating a long GC pausing us:\n              if (random.nextBoolean()) {\n                out.writeByte((byte) 0);\n                count = 0;\n              }\n            }\n          }\n\n          out.writeByte((byte) 1);\n          bos.flush();\n          success = true;\n        } finally {\n          message(\"done merge copy files=\" + files.keySet() + \" success=\" + success);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"unrecognized cmd=\" + cmd);\n      }\n      bos.flush();\n\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","13ea66b549e25413e4e3057bf3492ab828899110"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","13ea66b549e25413e4e3057bf3492ab828899110"],"13ea66b549e25413e4e3057bf3492ab828899110":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["68496c2200e559fb7802f7575427b7a482659afb","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["68496c2200e559fb7802f7575427b7a482659afb","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","68496c2200e559fb7802f7575427b7a482659afb"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1b0febf62c2d9baeee7db38998d9197700ccbab9","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}