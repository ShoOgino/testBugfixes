{"path":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","commits":[{"id":"df16fc2e9b615e0138edac46655ae628f5d098ad","date":1320876869,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>(searchers.values());\n    Collections.sort(trackers);\n    final long newestSec = trackers.isEmpty() ? 0L : trackers.get(0).recordTimeSec;\n    for (SearcherTracker tracker: trackers) {\n      final int ageSec = (int) (newestSec - tracker.recordTimeSec);\n      assert ageSec >= 0;\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>(searchers.values());\n    Collections.sort(trackers);\n    final long newestSec = trackers.isEmpty() ? 0L : trackers.get(0).recordTimeSec;\n    for (SearcherTracker tracker: trackers) {\n      final int ageSec = (int) (newestSec - tracker.recordTimeSec);\n      assert ageSec >= 0;\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d2d8c50f9002c3e6570311ef5d8c693639a1074","date":1320946072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    final long newestSec = trackers.isEmpty() ? 0L : trackers.get(0).recordTimeSec;\n    for (SearcherTracker tracker: trackers) {\n      final int ageSec = (int) (newestSec - tracker.recordTimeSec);\n      assert ageSec >= 0;\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>(searchers.values());\n    Collections.sort(trackers);\n    final long newestSec = trackers.isEmpty() ? 0L : trackers.get(0).recordTimeSec;\n    for (SearcherTracker tracker: trackers) {\n      final int ageSec = (int) (newestSec - tracker.recordTimeSec);\n      assert ageSec >= 0;\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"226aae72c0326f4299c16280195bade4530de537","date":1324221898,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    final long newestSec = trackers.isEmpty() ? 0L : trackers.get(0).recordTimeSec;\n    for (SearcherTracker tracker: trackers) {\n      final int ageSec = (int) (newestSec - tracker.recordTimeSec);\n      assert ageSec >= 0;\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/SearcherLifetimeManager#prune(Pruner).mjava","sourceNew":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","sourceOld":"  /** Calls provided {@link Pruner} to prune entries.  The\n   *  entries are passed to the Pruner in sorted (newest to\n   *  oldest IndexSearcher) order.\n   * \n   *  <p><b>NOTE</b>: you must peridiocally call this, ideally\n   *  from the same background thread that opens new\n   *  searchers. */\n  public synchronized void prune(Pruner pruner) throws IOException {\n    // Cannot just pass searchers.values() to ArrayList ctor\n    // (not thread-safe since the values can change while\n    // ArrayList is init'ing itself); must instead iterate\n    // ourselves:\n    final List<SearcherTracker> trackers = new ArrayList<SearcherTracker>();\n    for(SearcherTracker tracker : searchers.values()) {\n      trackers.add(tracker);\n    }\n    Collections.sort(trackers);\n    double lastRecordTimeSec = 0.0;\n    final double now = System.nanoTime()/NANOS_PER_SEC;\n    for (SearcherTracker tracker: trackers) {\n      final double ageSec;\n      if (lastRecordTimeSec == 0.0) {\n        ageSec = 0.0;\n      } else {\n        ageSec = now - lastRecordTimeSec;\n      }\n      // First tracker is always age 0.0 sec, since it's\n      // still \"live\"; second tracker's age (= seconds since\n      // it was \"live\") is now minus first tracker's\n      // recordTime, etc:\n      if (pruner.doPrune(ageSec, tracker.searcher)) {\n        //System.out.println(\"PRUNE version=\" + tracker.version + \" age=\" + ageSec + \" ms=\" + System.currentTimeMillis());\n        searchers.remove(tracker.version);\n        tracker.close();\n      }\n      lastRecordTimeSec = tracker.recordTimeSec;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df16fc2e9b615e0138edac46655ae628f5d098ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["226aae72c0326f4299c16280195bade4530de537"],"226aae72c0326f4299c16280195bade4530de537":["1d2d8c50f9002c3e6570311ef5d8c693639a1074"],"1d2d8c50f9002c3e6570311ef5d8c693639a1074":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"df16fc2e9b615e0138edac46655ae628f5d098ad":["1d2d8c50f9002c3e6570311ef5d8c693639a1074"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"226aae72c0326f4299c16280195bade4530de537":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"1d2d8c50f9002c3e6570311ef5d8c693639a1074":["226aae72c0326f4299c16280195bade4530de537"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}