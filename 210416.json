{"path":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","commits":[{"id":"8bb94551de83b33535d086e8d4222fa6d0c4cfc0","date":1357181547,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","sourceNew":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(String field, Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        DocsAndPositionsEnum de2 = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de2 == null) {\n          continue;\n        } else {\n          de = postings[i] = de2;\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","sourceOld":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        DocsAndPositionsEnum de2 = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de2 == null) {\n          continue;\n        } else {\n          de = postings[i] = de2;\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd906cf99495baaa13945b26300a973c89ce3222","date":1357185632,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","sourceNew":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(String field, Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        de = postings[i] = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de == null) {\n          // no positions available\n          throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","sourceOld":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(String field, Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        DocsAndPositionsEnum de2 = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de2 == null) {\n          continue;\n        } else {\n          de = postings[i] = de2;\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b3d16cba9355e2e97962eb1c441bbd0b6735c15","date":1357426290,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/sandbox/postingshighlight/PostingsHighlighter#highlightDoc(String,Term[],int,BreakIterator,int,TermsEnum,DocsAndPositionsEnum[],int).mjava","sourceNew":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(String field, Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        de = postings[i] = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de == null) {\n          // no positions available\n          throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","sourceOld":"  // algorithm: treat sentence snippets as miniature documents\n  // we can intersect these with the postings lists via BreakIterator.preceding(offset),s\n  // score each sentence as norm(sentenceStartOffset) * sum(weight * tf(freq))\n  private Passage[] highlightDoc(String field, Term terms[], int contentLength, BreakIterator bi, int doc, \n      TermsEnum termsEnum, DocsAndPositionsEnum[] postings, int n) throws IOException {\n    PriorityQueue<OffsetsEnum> pq = new PriorityQueue<OffsetsEnum>();\n    float weights[] = new float[terms.length];\n    // initialize postings\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum de = postings[i];\n      int pDoc;\n      if (de == EMPTY) {\n        continue;\n      } else if (de == null) {\n        postings[i] = EMPTY; // initially\n        if (!termsEnum.seekExact(terms[i].bytes(), true)) {\n          continue; // term not found\n        }\n        de = postings[i] = termsEnum.docsAndPositions(null, null, DocsAndPositionsEnum.FLAG_OFFSETS);\n        if (de == null) {\n          // no positions available\n          throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n        }\n        pDoc = de.advance(doc);\n      } else {\n        pDoc = de.docID();\n        if (pDoc < doc) {\n          pDoc = de.advance(doc);\n        }\n      }\n\n      if (doc == pDoc) {\n        weights[i] = scorer.weight(contentLength, de.freq());\n        de.nextPosition();\n        pq.add(new OffsetsEnum(de, i));\n      }\n    }\n    \n    pq.add(new OffsetsEnum(EMPTY, Integer.MAX_VALUE)); // a sentinel for termination\n    \n    PriorityQueue<Passage> passageQueue = new PriorityQueue<Passage>(n, new Comparator<Passage>() {\n      @Override\n      public int compare(Passage left, Passage right) {\n        if (right.score == left.score) {\n          return right.startOffset - left.endOffset;\n        } else {\n          return right.score > left.score ? 1 : -1;\n        }\n      }\n    });\n    Passage current = new Passage();\n    \n    OffsetsEnum off;\n    while ((off = pq.poll()) != null) {\n      final DocsAndPositionsEnum dp = off.dp;\n      int start = dp.startOffset();\n      if (start == -1) {\n        throw new IllegalArgumentException(\"field '\" + field + \"' was indexed without offsets, cannot highlight\");\n      }\n      int end = dp.endOffset();\n      if (start > current.endOffset) {\n        if (current.startOffset >= 0) {\n          // finalize current\n          current.score *= scorer.norm(current.startOffset);\n          // new sentence: first add 'current' to queue \n          if (passageQueue.size() == n && current.score < passageQueue.peek().score) {\n            current.reset(); // can't compete, just reset it\n          } else {\n            passageQueue.offer(current);\n            if (passageQueue.size() > n) {\n              current = passageQueue.poll();\n              current.reset();\n            } else {\n              current = new Passage();\n            }\n          }\n        }\n        // if we exceed limit, we are done\n        if (start >= contentLength) {\n          Passage passages[] = new Passage[passageQueue.size()];\n          passageQueue.toArray(passages);\n          // sort in ascending order\n          Arrays.sort(passages, new Comparator<Passage>() {\n            @Override\n            public int compare(Passage left, Passage right) {\n              return left.startOffset - right.startOffset;\n            }\n          });\n          return passages;\n        }\n        // advance breakiterator\n        assert BreakIterator.DONE < 0;\n        current.startOffset = Math.max(bi.preceding(start+1), 0);\n        current.endOffset = Math.min(bi.next(), contentLength);\n      }\n      int tf = 0;\n      while (true) {\n        tf++;\n        current.addMatch(start, end, terms[off.id]);\n        if (off.pos == dp.freq()) {\n          break; // removed from pq\n        } else {\n          off.pos++;\n          dp.nextPosition();\n          start = dp.startOffset();\n          end = dp.endOffset();\n        }\n        if (start >= current.endOffset) {\n          pq.offer(off);\n          break;\n        }\n      }\n      current.score += weights[off.id] * scorer.tf(tf, current.endOffset - current.startOffset);\n    }\n    return new Passage[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4b3d16cba9355e2e97962eb1c441bbd0b6735c15":["dd906cf99495baaa13945b26300a973c89ce3222"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8bb94551de83b33535d086e8d4222fa6d0c4cfc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dd906cf99495baaa13945b26300a973c89ce3222":["8bb94551de83b33535d086e8d4222fa6d0c4cfc0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4b3d16cba9355e2e97962eb1c441bbd0b6735c15"]},"commit2Childs":{"4b3d16cba9355e2e97962eb1c441bbd0b6735c15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8bb94551de83b33535d086e8d4222fa6d0c4cfc0"],"8bb94551de83b33535d086e8d4222fa6d0c4cfc0":["dd906cf99495baaa13945b26300a973c89ce3222"],"dd906cf99495baaa13945b26300a973c89ce3222":["4b3d16cba9355e2e97962eb1c441bbd0b6735c15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}