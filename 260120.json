{"path":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestIndexFetchOnLeaderRestart().mjava","commits":[{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":1,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestIndexFetchOnLeaderRestart().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestIndexFetchOnMasterRestart().mjava","sourceNew":"  /**\n   * We assert that if leader is down for more than poll interval,\n   * the follower doesn't re-fetch the whole index from leader again if\n   * the index hasn't changed. See SOLR-9036\n   */\n  @Test\n  public void doTestIndexFetchOnLeaderRestart() throws Exception  {\n    useFactory(null);\n    try {\n      clearIndexWithReplication();\n      // change solrconfig having 'replicateAfter startup' option on leader\n      leader.copyConfigFile(CONF_DIR + \"solrconfig-leader2.xml\",\n          \"solrconfig.xml\");\n\n      leaderJetty.stop();\n      leaderJetty.start();\n\n      // close and re-create leader client because its connection pool has stale connections\n      leaderClient.close();\n      leaderClient = createNewSolrClient(leaderJetty.getLocalPort());\n\n      nDocs--;\n      for (int i = 0; i < nDocs; i++)\n        index(leaderClient, \"id\", i, \"name\", \"name = \" + i);\n\n      leaderClient.commit();\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList leaderQueryRsp = rQuery(nDocs, \"*:*\", leaderClient);\n      SolrDocumentList leaderQueryResult = (SolrDocumentList) leaderQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(leaderQueryRsp));\n\n      //get docs from follower and check if number is equal to leader\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      SolrDocumentList followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n      //compare results\n      String cmp = BaseDistributedSearchTestCase.compare(leaderQueryResult, followerQueryResult, 0, null);\n      assertEquals(null, cmp);\n\n      String timesReplicatedString = getFollowerDetails(\"timesIndexReplicated\");\n      String timesFailed;\n      Integer previousTimesFailed = null;\n      if (timesReplicatedString == null) {\n        timesFailed = \"0\";\n      } else {\n        int timesReplicated = Integer.parseInt(timesReplicatedString);\n        timesFailed = getFollowerDetails(\"timesFailed\");\n        if (null == timesFailed) {\n          timesFailed = \"0\";\n        }\n\n        previousTimesFailed = Integer.parseInt(timesFailed);\n        // Sometimes replication will fail because leader's core is still loading; make sure there was one success\n        assertEquals(1, timesReplicated - previousTimesFailed);\n\n      }\n\n      leaderJetty.stop();\n\n      final TimeOut waitForLeaderToShutdown = new TimeOut(300, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      waitForLeaderToShutdown.waitFor\n        (\"Gave up after waiting an obscene amount of time for leader to shut down\",\n         () -> leaderJetty.isStopped() );\n        \n      for(int retries=0; ;retries++) { \n\n        Thread.yield(); // might not be necessary at all\n        // poll interval on follower is 1 second, so we just sleep for a few seconds\n        Thread.sleep(2000);\n        \n        NamedList<Object> followerDetails=null;\n        try {\n          followerDetails = getFollowerDetails();\n          int failed = Integer.parseInt(getStringOrNull(followerDetails,\"timesFailed\"));\n          if (previousTimesFailed != null) {\n            assertTrue(failed > previousTimesFailed);\n          }\n          assertEquals(1, Integer.parseInt(getStringOrNull(followerDetails,\"timesIndexReplicated\")) - failed);\n          break;\n        } catch (NumberFormatException | AssertionError notYet) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{}th attempt failure on {} details are {}\", retries + 1, notYet, followerDetails); // logOk\n          }\n          if (retries>9) {\n            log.error(\"giving up: \", notYet);\n            throw notYet;\n          } \n        }\n      }\n      \n      leaderJetty.start();\n\n      // poll interval on follower is 1 second, so we just sleep for a few seconds\n      Thread.sleep(2000);\n      //get docs from follower and assert that they are still the same as before\n      followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n    } finally {\n      resetFactory();\n    }\n  }\n\n","sourceOld":"  /**\n   * We assert that if master is down for more than poll interval,\n   * the slave doesn't re-fetch the whole index from master again if\n   * the index hasn't changed. See SOLR-9036\n   */\n  @Test\n  public void doTestIndexFetchOnMasterRestart() throws Exception  {\n    useFactory(null);\n    try {\n      clearIndexWithReplication();\n      // change solrconfig having 'replicateAfter startup' option on master\n      master.copyConfigFile(CONF_DIR + \"solrconfig-master2.xml\",\n          \"solrconfig.xml\");\n\n      masterJetty.stop();\n      masterJetty.start();\n\n      // close and re-create master client because its connection pool has stale connections\n      masterClient.close();\n      masterClient = createNewSolrClient(masterJetty.getLocalPort());\n\n      nDocs--;\n      for (int i = 0; i < nDocs; i++)\n        index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n      masterClient.commit();\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList masterQueryRsp = rQuery(nDocs, \"*:*\", masterClient);\n      SolrDocumentList masterQueryResult = (SolrDocumentList) masterQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(masterQueryRsp));\n\n      //get docs from slave and check if number is equal to master\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList slaveQueryRsp = rQuery(nDocs, \"*:*\", slaveClient);\n      SolrDocumentList slaveQueryResult = (SolrDocumentList) slaveQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(slaveQueryRsp));\n\n      //compare results\n      String cmp = BaseDistributedSearchTestCase.compare(masterQueryResult, slaveQueryResult, 0, null);\n      assertEquals(null, cmp);\n\n      String timesReplicatedString = getSlaveDetails(\"timesIndexReplicated\");\n      String timesFailed;\n      Integer previousTimesFailed = null;\n      if (timesReplicatedString == null) {\n        timesFailed = \"0\";\n      } else {\n        int timesReplicated = Integer.parseInt(timesReplicatedString);\n        timesFailed = getSlaveDetails(\"timesFailed\");\n        if (null == timesFailed) {\n          timesFailed = \"0\";\n        }\n\n        previousTimesFailed = Integer.parseInt(timesFailed);\n        // Sometimes replication will fail because master's core is still loading; make sure there was one success\n        assertEquals(1, timesReplicated - previousTimesFailed);\n\n      }\n\n      masterJetty.stop();\n\n      final TimeOut waitForLeaderToShutdown = new TimeOut(300, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      waitForLeaderToShutdown.waitFor\n        (\"Gave up after waiting an obscene amount of time for leader to shut down\",\n         () -> masterJetty.isStopped() );\n        \n      for(int retries=0; ;retries++) { \n\n        Thread.yield(); // might not be necessary at all\n        // poll interval on slave is 1 second, so we just sleep for a few seconds\n        Thread.sleep(2000);\n        \n        NamedList<Object> slaveDetails=null;\n        try {\n          slaveDetails = getSlaveDetails();\n          int failed = Integer.parseInt(getStringOrNull(slaveDetails,\"timesFailed\"));\n          if (previousTimesFailed != null) {\n            assertTrue(failed > previousTimesFailed);\n          }\n          assertEquals(1, Integer.parseInt(getStringOrNull(slaveDetails,\"timesIndexReplicated\")) - failed);\n          break;\n        } catch (NumberFormatException | AssertionError notYet) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{}th attempt failure on {} details are {}\", retries + 1, notYet, slaveDetails); // logOk\n          }\n          if (retries>9) {\n            log.error(\"giving up: \", notYet);\n            throw notYet;\n          } \n        }\n      }\n      \n      masterJetty.start();\n\n      // poll interval on slave is 1 second, so we just sleep for a few seconds\n      Thread.sleep(2000);\n      //get docs from slave and assert that they are still the same as before\n      slaveQueryRsp = rQuery(nDocs, \"*:*\", slaveClient);\n      slaveQueryResult = (SolrDocumentList) slaveQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(slaveQueryRsp));\n\n    } finally {\n      resetFactory();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestIndexFetchOnLeaderRestart().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestIndexFetchOnLeaderRestart().mjava","sourceNew":"  /**\n   * We assert that if leader is down for more than poll interval,\n   * the follower doesn't re-fetch the whole index from leader again if\n   * the index hasn't changed. See SOLR-9036\n   */\n  @Test\n  public void doTestIndexFetchOnLeaderRestart() throws Exception  {\n    useFactory(null);\n    try {\n      clearIndexWithReplication();\n      // change solrconfig having 'replicateAfter startup' option on leader\n      leader.copyConfigFile(CONF_DIR + \"solrconfig-leader2.xml\",\n          \"solrconfig.xml\");\n\n      leaderJetty.stop();\n      leaderJetty.start();\n\n      // close and re-create leader client because its connection pool has stale connections\n      leaderClient.close();\n      leaderClient = createNewSolrClient(leaderJetty.getLocalPort());\n\n      nDocs--;\n      for (int i = 0; i < nDocs; i++)\n        index(leaderClient, \"id\", i, \"name\", \"name = \" + i);\n\n      leaderClient.commit();\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList leaderQueryRsp = rQuery(nDocs, \"*:*\", leaderClient);\n      SolrDocumentList leaderQueryResult = (SolrDocumentList) leaderQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(leaderQueryRsp));\n\n      //get docs from follower and check if number is equal to leader\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      SolrDocumentList followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n      //compare results\n      String cmp = BaseDistributedSearchTestCase.compare(leaderQueryResult, followerQueryResult, 0, null);\n      assertEquals(null, cmp);\n\n      String timesReplicatedString = getFollowerDetails(\"timesIndexReplicated\");\n      String timesFailed;\n      Integer previousTimesFailed = null;\n      if (timesReplicatedString == null) {\n        timesFailed = \"0\";\n      } else {\n        int timesReplicated = Integer.parseInt(timesReplicatedString);\n        timesFailed = getFollowerDetails(\"timesFailed\");\n        if (null == timesFailed) {\n          timesFailed = \"0\";\n        }\n\n        previousTimesFailed = Integer.parseInt(timesFailed);\n        // Sometimes replication will fail because leader's core is still loading; make sure there was one success\n        assertEquals(1, timesReplicated - previousTimesFailed);\n\n      }\n\n      leaderJetty.stop();\n\n      final TimeOut waitForLeaderToShutdown = new TimeOut(300, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      waitForLeaderToShutdown.waitFor\n        (\"Gave up after waiting an obscene amount of time for leader to shut down\",\n         () -> leaderJetty.isStopped() );\n        \n      for(int retries=0; ;retries++) { \n\n        Thread.yield(); // might not be necessary at all\n        // poll interval on follower is 1 second, so we just sleep for a few seconds\n        Thread.sleep(2000);\n        \n        NamedList<Object> followerDetails=null;\n        try {\n          followerDetails = getFollowerDetails();\n          int failed = Integer.parseInt(getStringOrNull(followerDetails,\"timesFailed\"));\n          if (previousTimesFailed != null) {\n            assertTrue(failed > previousTimesFailed);\n          }\n          assertEquals(1, Integer.parseInt(getStringOrNull(followerDetails,\"timesIndexReplicated\")) - failed);\n          break;\n        } catch (NumberFormatException | AssertionError notYet) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{}th attempt failure on {} details are {}\", retries + 1, notYet, followerDetails); // nowarn\n          }\n          if (retries>9) {\n            log.error(\"giving up: \", notYet);\n            throw notYet;\n          } \n        }\n      }\n      \n      leaderJetty.start();\n\n      // poll interval on follower is 1 second, so we just sleep for a few seconds\n      Thread.sleep(2000);\n      //get docs from follower and assert that they are still the same as before\n      followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n    } finally {\n      resetFactory();\n    }\n  }\n\n","sourceOld":"  /**\n   * We assert that if leader is down for more than poll interval,\n   * the follower doesn't re-fetch the whole index from leader again if\n   * the index hasn't changed. See SOLR-9036\n   */\n  @Test\n  public void doTestIndexFetchOnLeaderRestart() throws Exception  {\n    useFactory(null);\n    try {\n      clearIndexWithReplication();\n      // change solrconfig having 'replicateAfter startup' option on leader\n      leader.copyConfigFile(CONF_DIR + \"solrconfig-leader2.xml\",\n          \"solrconfig.xml\");\n\n      leaderJetty.stop();\n      leaderJetty.start();\n\n      // close and re-create leader client because its connection pool has stale connections\n      leaderClient.close();\n      leaderClient = createNewSolrClient(leaderJetty.getLocalPort());\n\n      nDocs--;\n      for (int i = 0; i < nDocs; i++)\n        index(leaderClient, \"id\", i, \"name\", \"name = \" + i);\n\n      leaderClient.commit();\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList leaderQueryRsp = rQuery(nDocs, \"*:*\", leaderClient);\n      SolrDocumentList leaderQueryResult = (SolrDocumentList) leaderQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(leaderQueryRsp));\n\n      //get docs from follower and check if number is equal to leader\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      SolrDocumentList followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n      //compare results\n      String cmp = BaseDistributedSearchTestCase.compare(leaderQueryResult, followerQueryResult, 0, null);\n      assertEquals(null, cmp);\n\n      String timesReplicatedString = getFollowerDetails(\"timesIndexReplicated\");\n      String timesFailed;\n      Integer previousTimesFailed = null;\n      if (timesReplicatedString == null) {\n        timesFailed = \"0\";\n      } else {\n        int timesReplicated = Integer.parseInt(timesReplicatedString);\n        timesFailed = getFollowerDetails(\"timesFailed\");\n        if (null == timesFailed) {\n          timesFailed = \"0\";\n        }\n\n        previousTimesFailed = Integer.parseInt(timesFailed);\n        // Sometimes replication will fail because leader's core is still loading; make sure there was one success\n        assertEquals(1, timesReplicated - previousTimesFailed);\n\n      }\n\n      leaderJetty.stop();\n\n      final TimeOut waitForLeaderToShutdown = new TimeOut(300, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      waitForLeaderToShutdown.waitFor\n        (\"Gave up after waiting an obscene amount of time for leader to shut down\",\n         () -> leaderJetty.isStopped() );\n        \n      for(int retries=0; ;retries++) { \n\n        Thread.yield(); // might not be necessary at all\n        // poll interval on follower is 1 second, so we just sleep for a few seconds\n        Thread.sleep(2000);\n        \n        NamedList<Object> followerDetails=null;\n        try {\n          followerDetails = getFollowerDetails();\n          int failed = Integer.parseInt(getStringOrNull(followerDetails,\"timesFailed\"));\n          if (previousTimesFailed != null) {\n            assertTrue(failed > previousTimesFailed);\n          }\n          assertEquals(1, Integer.parseInt(getStringOrNull(followerDetails,\"timesIndexReplicated\")) - failed);\n          break;\n        } catch (NumberFormatException | AssertionError notYet) {\n          if (log.isInfoEnabled()) {\n            log.info(\"{}th attempt failure on {} details are {}\", retries + 1, notYet, followerDetails); // logOk\n          }\n          if (retries>9) {\n            log.error(\"giving up: \", notYet);\n            throw notYet;\n          } \n        }\n      }\n      \n      leaderJetty.start();\n\n      // poll interval on follower is 1 second, so we just sleep for a few seconds\n      Thread.sleep(2000);\n      //get docs from follower and assert that they are still the same as before\n      followerQueryRsp = rQuery(nDocs, \"*:*\", followerClient);\n      followerQueryResult = (SolrDocumentList) followerQueryRsp.get(\"response\");\n      assertEquals(nDocs, numFound(followerQueryRsp));\n\n    } finally {\n      resetFactory();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b2d19164145b2a65acf62a657c75f4a249b649c0":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"]},"commit2Childs":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}