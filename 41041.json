{"path":"lucene/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedDeletesMerges(SegmentInfos).mjava","commits":[{"id":"34ce7c842452c79b12c45a8feb64e4597c7110e8","date":1321637224,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedDeletesMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TieredMergePolicy#findMergesToExpungeDeletes(SegmentInfos).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedDeletesMerges(SegmentInfos infos)\n      throws CorruptIndexException, IOException {\n    if (verbose()) {\n      message(\"findForcedDeletesMerges infos=\" + writer.get().segString(infos) + \" forceMergeDeletesPctAllowed=\" + forceMergeDeletesPctAllowed);\n    }\n    final List<SegmentInfo> eligible = new ArrayList<SegmentInfo>();\n    final Collection<SegmentInfo> merging = writer.get().getMergingSegments();\n    for(SegmentInfo info : infos) {\n      double pctDeletes = 100.*((double) writer.get().numDeletedDocs(info))/info.docCount;\n      if (pctDeletes > forceMergeDeletesPctAllowed && !merging.contains(info)) {\n        eligible.add(info);\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    Collections.sort(eligible, segmentByteSizeDescending);\n\n    if (verbose()) {\n      message(\"eligible=\" + eligible);\n    }\n\n    int start = 0;\n    MergeSpecification spec = null;\n\n    while(start < eligible.size()) {\n      // Don't enforce max merged size here: app is explicitly\n      // calling forceMergeDeletes, and knows this may take a\n      // long time / produce big segments (like forceMerge):\n      final int end = Math.min(start + maxMergeAtOnceExplicit, eligible.size());\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n\n      final OneMerge merge = new OneMerge(eligible.subList(start, end));\n      if (verbose()) {\n        message(\"add merge=\" + writer.get().segString(merge.segments));\n      }\n      spec.add(merge);\n      start = end;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findMergesToExpungeDeletes(SegmentInfos infos)\n      throws CorruptIndexException, IOException {\n    if (verbose()) {\n      message(\"findMergesToExpungeDeletes infos=\" + writer.get().segString(infos) + \" expungeDeletesPctAllowed=\" + expungeDeletesPctAllowed);\n    }\n    final List<SegmentInfo> eligible = new ArrayList<SegmentInfo>();\n    final Collection<SegmentInfo> merging = writer.get().getMergingSegments();\n    for(SegmentInfo info : infos) {\n      double pctDeletes = 100.*((double) writer.get().numDeletedDocs(info))/info.docCount;\n      if (pctDeletes > expungeDeletesPctAllowed && !merging.contains(info)) {\n        eligible.add(info);\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    Collections.sort(eligible, segmentByteSizeDescending);\n\n    if (verbose()) {\n      message(\"eligible=\" + eligible);\n    }\n\n    int start = 0;\n    MergeSpecification spec = null;\n\n    while(start < eligible.size()) {\n      // Don't enforce max merged size here: app is explicitly\n      // calling expungeDeletes, and knows this may take a\n      // long time / produce big segments (like forceMerge):\n      final int end = Math.min(start + maxMergeAtOnceExplicit, eligible.size());\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n\n      final OneMerge merge = new OneMerge(eligible.subList(start, end));\n      if (verbose()) {\n        message(\"add merge=\" + writer.get().segString(merge.segments));\n      }\n      spec.add(merge);\n      start = end;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedDeletesMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedDeletesMerges(SegmentInfos).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedDeletesMerges(SegmentInfos infos)\n      throws CorruptIndexException, IOException {\n    if (verbose()) {\n      message(\"findForcedDeletesMerges infos=\" + writer.get().segString(infos) + \" forceMergeDeletesPctAllowed=\" + forceMergeDeletesPctAllowed);\n    }\n    final List<SegmentInfo> eligible = new ArrayList<SegmentInfo>();\n    final Collection<SegmentInfo> merging = writer.get().getMergingSegments();\n    for(SegmentInfo info : infos) {\n      double pctDeletes = 100.*((double) writer.get().numDeletedDocs(info))/info.docCount;\n      if (pctDeletes > forceMergeDeletesPctAllowed && !merging.contains(info)) {\n        eligible.add(info);\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    Collections.sort(eligible, segmentByteSizeDescending);\n\n    if (verbose()) {\n      message(\"eligible=\" + eligible);\n    }\n\n    int start = 0;\n    MergeSpecification spec = null;\n\n    while(start < eligible.size()) {\n      // Don't enforce max merged size here: app is explicitly\n      // calling forceMergeDeletes, and knows this may take a\n      // long time / produce big segments (like forceMerge):\n      final int end = Math.min(start + maxMergeAtOnceExplicit, eligible.size());\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n\n      final OneMerge merge = new OneMerge(eligible.subList(start, end));\n      if (verbose()) {\n        message(\"add merge=\" + writer.get().segString(merge.segments));\n      }\n      spec.add(merge);\n      start = end;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedDeletesMerges(SegmentInfos infos)\n      throws CorruptIndexException, IOException {\n    if (verbose()) {\n      message(\"findForcedDeletesMerges infos=\" + writer.get().segString(infos) + \" forceMergeDeletesPctAllowed=\" + forceMergeDeletesPctAllowed);\n    }\n    final List<SegmentInfo> eligible = new ArrayList<SegmentInfo>();\n    final Collection<SegmentInfo> merging = writer.get().getMergingSegments();\n    for(SegmentInfo info : infos) {\n      double pctDeletes = 100.*((double) writer.get().numDeletedDocs(info))/info.docCount;\n      if (pctDeletes > forceMergeDeletesPctAllowed && !merging.contains(info)) {\n        eligible.add(info);\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    Collections.sort(eligible, segmentByteSizeDescending);\n\n    if (verbose()) {\n      message(\"eligible=\" + eligible);\n    }\n\n    int start = 0;\n    MergeSpecification spec = null;\n\n    while(start < eligible.size()) {\n      // Don't enforce max merged size here: app is explicitly\n      // calling forceMergeDeletes, and knows this may take a\n      // long time / produce big segments (like forceMerge):\n      final int end = Math.min(start + maxMergeAtOnceExplicit, eligible.size());\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n\n      final OneMerge merge = new OneMerge(eligible.subList(start, end));\n      if (verbose()) {\n        message(\"add merge=\" + writer.get().segString(merge.segments));\n      }\n      spec.add(merge);\n      start = end;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["34ce7c842452c79b12c45a8feb64e4597c7110e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"34ce7c842452c79b12c45a8feb64e4597c7110e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["34ce7c842452c79b12c45a8feb64e4597c7110e8"],"34ce7c842452c79b12c45a8feb64e4597c7110e8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}