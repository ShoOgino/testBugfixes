{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","commits":[{"id":"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9","date":1457128438,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","pathOld":"/dev/null","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"922ddd897402a6df25c766ea8300443be5e82b3d","date":1457157606,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","pathOld":"/dev/null","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec60431d008a694828dacb4bc3cda775b6c44a9f","date":1458570843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":["b4c23ea9b61b3e6ad2f2b3684e33f528711744d9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5","date":1458616189,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ca8abb1a4010d2a9e71b0162d3600e898a8a4f56"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["922ddd897402a6df25c766ea8300443be5e82b3d"],"922ddd897402a6df25c766ea8300443be5e82b3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b4c23ea9b61b3e6ad2f2b3684e33f528711744d9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ed05bb51ea0663dafe0ae9b600553ef0e851f0e5"]},"commit2Childs":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["ed05bb51ea0663dafe0ae9b600553ef0e851f0e5"],"922ddd897402a6df25c766ea8300443be5e82b3d":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["922ddd897402a6df25c766ea8300443be5e82b3d","b4c23ea9b61b3e6ad2f2b3684e33f528711744d9"],"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9":["922ddd897402a6df25c766ea8300443be5e82b3d"],"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}