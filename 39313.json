{"path":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","commits":[{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b46138b9b857dbdd1bbcc418aa1a6e18a62420","date":1389006583,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    // Compute min & max over all ranges:\n    double minIncl = Double.POSITIVE_INFINITY;\n    double maxIncl = Double.NEGATIVE_INFINITY;\n    for(DoubleRange range : ranges) {\n      minIncl = Math.min(minIncl, range.minIncl);\n      maxIncl = Math.max(maxIncl, range.maxIncl);\n    }\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0732a1e488deedeceef7f601e066085e7ac655a","date":1391629546,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      final int length = hits.bits.length();\n      int doc = 0;\n      totCount += hits.totalHits;\n      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n        doc++;\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      Bits bits;\n      if (fastMatchFilter != null) {\n        DocIdSet dis = fastMatchFilter.getDocIdSet(hits.context, null);\n        if (dis == null) {\n          // No documents match\n          continue;\n        }\n        bits = dis.bits();\n        if (bits == null) {\n          throw new IllegalArgumentException(\"fastMatchFilter does not implement DocIdSet.bits\");\n        }\n      } else {\n        bits = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (bits != null && bits.get(doc) == false) {\n          doc++;\n          continue;\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"099c774ddd27f4ad437ca5df14d153bab0a3affe","date":1424527689,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchFilter != null) {\n        DocIdSet dis = fastMatchFilter.getDocIdSet(hits.context, null);\n        if (dis == null) {\n          // No documents match\n          continue;\n        }\n        fastMatchDocs = dis.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      Bits bits;\n      if (fastMatchFilter != null) {\n        DocIdSet dis = fastMatchFilter.getDocIdSet(hits.context, null);\n        if (dis == null) {\n          // No documents match\n          continue;\n        }\n        bits = dis.bits();\n        if (bits == null) {\n          throw new IllegalArgumentException(\"fastMatchFilter does not implement DocIdSet.bits\");\n        }\n      } else {\n        bits = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n      \n      int doc;\n      while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n        if (bits != null && bits.get(doc) == false) {\n          doc++;\n          continue;\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd6be878365e339c75cc43ad7d5df95ab4ea21e5","date":1435762101,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        fastMatchDocs = fastMatchWeight.scorer(hits.context);\n        if (fastMatchDocs == null) {\n          continue;\n        }\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchFilter != null) {\n        DocIdSet dis = fastMatchFilter.getDocIdSet(hits.context, null);\n        if (dis == null) {\n          // No documents match\n          continue;\n        }\n        fastMatchDocs = dis.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        fastMatchDocs = fastMatchWeight.scorer(hits.context);\n        if (fastMatchDocs == null) {\n          continue;\n        }\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     NumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.min), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109"],"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.min), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.min), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109","1800b996d8677670482a071dcb7a48b08c423ace"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     LegacyNumericUtils.doubleToSortableLong(range.minIncl), true,\n                                     LegacyNumericUtils.doubleToSortableLong(range.maxIncl), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(LegacyNumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cf250cb8fdff62f4b753866d44e5bf59bfd1616","date":1483789944,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(DoubleValuesSource,List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRangeFacetCounts#count(ValueSource,List[MatchingDocs]).mjava","sourceNew":"  private void count(DoubleValuesSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      DoubleValues fv = valueSource.getValues(hits.context, null);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.advanceExact(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleValue()));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","sourceOld":"  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {\n\n    DoubleRange[] ranges = (DoubleRange[]) this.ranges;\n\n    LongRange[] longRanges = new LongRange[ranges.length];\n    for(int i=0;i<ranges.length;i++) {\n      DoubleRange range = ranges[i];\n      longRanges[i] =  new LongRange(range.label,\n                                     NumericUtils.doubleToSortableLong(range.min), true,\n                                     NumericUtils.doubleToSortableLong(range.max), true);\n    }\n\n    LongRangeCounter counter = new LongRangeCounter(longRanges);\n\n    int missingCount = 0;\n    for (MatchingDocs hits : matchingDocs) {\n      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);\n      \n      totCount += hits.totalHits;\n      final DocIdSetIterator fastMatchDocs;\n      if (fastMatchQuery != null) {\n        final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(hits.context);\n        final IndexSearcher searcher = new IndexSearcher(topLevelContext);\n        searcher.setQueryCache(null);\n        final Weight fastMatchWeight = searcher.createNormalizedWeight(fastMatchQuery, false);\n        Scorer s = fastMatchWeight.scorer(hits.context);\n        if (s == null) {\n          continue;\n        }\n        fastMatchDocs = s.iterator();\n      } else {\n        fastMatchDocs = null;\n      }\n\n      DocIdSetIterator docs = hits.bits.iterator();\n\n      for (int doc = docs.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; ) {\n        if (fastMatchDocs != null) {\n          int fastMatchDoc = fastMatchDocs.docID();\n          if (fastMatchDoc < doc) {\n            fastMatchDoc = fastMatchDocs.advance(doc);\n          }\n\n          if (doc != fastMatchDoc) {\n            doc = docs.advance(fastMatchDoc);\n            continue;\n          }\n        }\n        // Skip missing docs:\n        if (fv.exists(doc)) {\n          counter.add(NumericUtils.doubleToSortableLong(fv.doubleVal(doc)));\n        } else {\n          missingCount++;\n        }\n\n        doc = docs.nextDoc();\n      }\n    }\n\n    missingCount += counter.fillCounts(counts);\n    totCount -= missingCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"099c774ddd27f4ad437ca5df14d153bab0a3affe":["40640359164f629dd440a47df2e145d084ce9645"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"40640359164f629dd440a47df2e145d084ce9645":["a0732a1e488deedeceef7f601e066085e7ac655a"],"770342641f7b505eaa8dccdc666158bff2419109":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["099c774ddd27f4ad437ca5df14d153bab0a3affe"],"c422e924212367b334b4938f1fd3e44438e88c40":["770342641f7b505eaa8dccdc666158bff2419109","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["770342641f7b505eaa8dccdc666158bff2419109"],"a0732a1e488deedeceef7f601e066085e7ac655a":["55b46138b9b857dbdd1bbcc418aa1a6e18a62420"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"55b46138b9b857dbdd1bbcc418aa1a6e18a62420":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["c422e924212367b334b4938f1fd3e44438e88c40"]},"commit2Childs":{"099c774ddd27f4ad437ca5df14d153bab0a3affe":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"9cf250cb8fdff62f4b753866d44e5bf59bfd1616":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"40640359164f629dd440a47df2e145d084ce9645":["099c774ddd27f4ad437ca5df14d153bab0a3affe"],"770342641f7b505eaa8dccdc666158bff2419109":["c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"c422e924212367b334b4938f1fd3e44438e88c40":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"a0732a1e488deedeceef7f601e066085e7ac655a":["40640359164f629dd440a47df2e145d084ce9645"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4edc984f0f4ac77c37e48ace2932f780f888453c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["55b46138b9b857dbdd1bbcc418aa1a6e18a62420"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","9cf250cb8fdff62f4b753866d44e5bf59bfd1616"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["770342641f7b505eaa8dccdc666158bff2419109"],"55b46138b9b857dbdd1bbcc418aa1a6e18a62420":["a0732a1e488deedeceef7f601e066085e7ac655a"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}