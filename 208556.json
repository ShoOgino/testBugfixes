{"path":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","commits":[{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,String]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS\n              | SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String, String> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS\n              | SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30fc21bc72828e962cb0797aabe8a1b75f3ed399","date":1377031026,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS\n              | SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS\n              | SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS\n              | SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a76608e7f735dce831f49f9b0c6bc13f10adc5a6","date":1427421698,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12f7f335611574989edc8f87d25d91e89aa385b6","date":1489690739,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY | LARGE_FIELD;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b4eb0a25318cc756077fbde9bd3052690aed03d","date":1490280009,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY | LARGE_FIELD;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/SchemaField#calcProps(String,FieldType,Map[String,#]).mjava","sourceNew":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY | LARGE_FIELD;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS | UNINVERTIBLE);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,UNINVERTIBLE) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-docValues/non-uninvertible field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","sourceOld":"  static int calcProps(String name, FieldType ft, Map<String,?> props) {\n    int trueProps = parseProperties(props,true,true);\n    int falseProps = parseProperties(props,false,true);\n\n    int p = ft.properties;\n\n    //\n    // If any properties were explicitly turned off, then turn off other properties\n    // that depend on that.\n    //\n    if (on(falseProps,STORED)) {\n      int pp = STORED | BINARY | LARGE_FIELD;\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting stored field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,INDEXED)) {\n      int pp = (INDEXED \n              | STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED) && on(falseProps,DOC_VALUES)) {\n      int pp = (SORT_MISSING_FIRST | SORT_MISSING_LAST);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'true' field options for non-indexed/non-docValues field:\" + props);\n      }\n      p &= ~pp;\n    }\n    \n    if (on(falseProps,INDEXED)) {\n      int pp = (OMIT_NORMS | OMIT_TF_POSITIONS | OMIT_POSITIONS);\n      if (on(pp,falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting 'false' field options for non-indexed field:\" + props);\n      }\n      p &= ~pp;\n\n    }\n\n    if (on(trueProps,OMIT_TF_POSITIONS)) {\n      int pp = (OMIT_POSITIONS | OMIT_TF_POSITIONS);\n      if (on(pp, falseProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting tf and position field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    if (on(falseProps,STORE_TERMVECTORS)) {\n      int pp = (STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS | STORE_TERMPAYLOADS);\n      if (on(pp,trueProps)) {\n        throw new RuntimeException(\"SchemaField: \" + name + \" conflicting termvector field options:\" + props);\n      }\n      p &= ~pp;\n    }\n\n    // override sort flags\n    if (on(trueProps,SORT_MISSING_FIRST)) {\n      p &= ~SORT_MISSING_LAST;\n    }\n\n    if (on(trueProps,SORT_MISSING_LAST)) {\n      p &= ~SORT_MISSING_FIRST;\n    }\n\n    p &= ~falseProps;\n    p |= trueProps;\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","a76608e7f735dce831f49f9b0c6bc13f10adc5a6"],"a76608e7f735dce831f49f9b0c6bc13f10adc5a6":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"30fc21bc72828e962cb0797aabe8a1b75f3ed399":["08970e5b8411182a29412c177eff67ec1110095b"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["08970e5b8411182a29412c177eff67ec1110095b","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b4eb0a25318cc756077fbde9bd3052690aed03d":["a76608e7f735dce831f49f9b0c6bc13f10adc5a6"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["08970e5b8411182a29412c177eff67ec1110095b","30fc21bc72828e962cb0797aabe8a1b75f3ed399"],"12f7f335611574989edc8f87d25d91e89aa385b6":["a76608e7f735dce831f49f9b0c6bc13f10adc5a6"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["12f7f335611574989edc8f87d25d91e89aa385b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"08970e5b8411182a29412c177eff67ec1110095b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a76608e7f735dce831f49f9b0c6bc13f10adc5a6":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7b4eb0a25318cc756077fbde9bd3052690aed03d","12f7f335611574989edc8f87d25d91e89aa385b6"],"30fc21bc72828e962cb0797aabe8a1b75f3ed399":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["08970e5b8411182a29412c177eff67ec1110095b"],"7b4eb0a25318cc756077fbde9bd3052690aed03d":[],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a76608e7f735dce831f49f9b0c6bc13f10adc5a6","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"12f7f335611574989edc8f87d25d91e89aa385b6":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08970e5b8411182a29412c177eff67ec1110095b":["30fc21bc72828e962cb0797aabe8a1b75f3ed399","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","7b4eb0a25318cc756077fbde9bd3052690aed03d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}