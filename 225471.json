{"path":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","commits":[{"id":"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2","date":1326399048,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find best path from input lattice.\n   * @param lattice the result of build method\n   * @return\tList of ViterbiNode which consist best path \n   */\n  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {\n    ViterbiNode[][] startIndexArr = lattice[0];\n    ViterbiNode[][] endIndexArr = lattice[1];\n    \n    for (int i = 1; i < startIndexArr.length; i++){\n      \n      if (startIndexArr[i] == null || endIndexArr[i] == null){\t// continue since no array which contains ViterbiNodes exists. Or no previous node exists.\n        continue;\n      }\n      \n      for (ViterbiNode node : startIndexArr[i]) {\n        if (node == null){\t// If array doesn't contain ViterbiNode any more, continue to next index\n          break;\n        }\n        \n        int backwardConnectionId = node.getLeftId();\n        int wordCost = node.getWordCost();\n        int leastPathCost = DEFAULT_COST;\n        for (ViterbiNode leftNode : endIndexArr[i]) {\n          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index\n            break;\n          }\n          \n          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;\t// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]\n          \n          // \"Search mode\". Add extra costs if it is long node.\n          if (searchMode) {\n            //\t\t\t\t\t\tSystem.out.print(\"\"); // If this line exists, kuromoji runs faster for some reason when searchMode == false.\n            char[] surfaceForm = node.getSurfaceForm();\n            int offset = node.getOffset();\n            int length = node.getLength();\n            if (length > SEARCH_MODE_LENGTH_KANJI) {\n              boolean allKanji = true;\n              // check if node consists of only kanji\n              for (int pos = 0; pos < length; pos++) {\n                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){\n                  allKanji = false;\n                  break;\n                }\t\t\t\t\n              }\n              \n              if (allKanji) {\t// Process only Kanji keywords\n                pathCost += (length - SEARCH_MODE_LENGTH_KANJI) * SEARCH_MODE_PENALTY;\n              } else if (length > SEARCH_MODE_LENGTH) {\n                pathCost += (length - SEARCH_MODE_LENGTH) * SEARCH_MODE_PENALTY;\t\t\t\t\t\t\t\t\n              }\n            }\n          }\n          \n          if (pathCost < leastPathCost){\t// If total cost is lower than before, set current previous node as best left node (previous means left).\n            leastPathCost = pathCost;\n            node.setPathCost(leastPathCost);\n            node.setLeftNode(leftNode);\n          }\t\t\t\t\t\n        }\n      }\n    }\n    \n    // track best path\n    ViterbiNode node = endIndexArr[0][0];\t// EOS\n    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();\n    result.add(node);\n    while (true) {\n      ViterbiNode leftNode = node.getLeftNode();\n      if (leftNode == null) {\n        break;\n      }\n      \n      // EXTENDED mode convert unknown word into unigram node\n      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {\n        byte unigramWordId = CharacterDefinition.NGRAM;\n        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required\n        char[] surfaceForm = leftNode.getSurfaceForm();\n        int offset = leftNode.getOffset();\n        int length = leftNode.getLength();\n        for (int i = length - 1; i >= 0; i--) {\n          int charLen = 1;\n          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {\n            i--;\n            charLen = 2;\n          }\n          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);\n          result.addFirst(uniGramNode);\n        }\n      } else {\n        result.addFirst(leftNode);\t\t\n      }\n      node = leftNode;\n    }\n    \n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7df4efdafac6329df3550939440c9f79b5ad525","date":1328094197,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","sourceNew":"  /**\n   * Find best path from input lattice.\n   * @param lattice the result of build method\n   * @return\tList of ViterbiNode which consist best path \n   */\n  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {\n    ViterbiNode[][] startIndexArr = lattice[0];\n    ViterbiNode[][] endIndexArr = lattice[1];\n    \n    for (int i = 1; i < startIndexArr.length; i++){\n      \n      if (startIndexArr[i] == null || endIndexArr[i] == null){\t// continue since no array which contains ViterbiNodes exists. Or no previous node exists.\n        continue;\n      }\n      \n      for (ViterbiNode node : startIndexArr[i]) {\n        if (node == null){\t// If array doesn't contain ViterbiNode any more, continue to next index\n          break;\n        }\n        \n        int backwardConnectionId = node.getLeftId();\n        int wordCost = node.getWordCost();\n        int leastPathCost = DEFAULT_COST;\n        for (ViterbiNode leftNode : endIndexArr[i]) {\n          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index\n            break;\n          }\n          \n          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;\t// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]\n          \n          // \"Search mode\". Add extra costs if it is long node.\n          if (searchMode) {\n            //\t\t\t\t\t\tSystem.out.print(\"\"); // If this line exists, kuromoji runs faster for some reason when searchMode == false.\n            char[] surfaceForm = node.getSurfaceForm();\n            int offset = node.getOffset();\n            int length = node.getLength();\n            if (length > SEARCH_MODE_KANJI_LENGTH) {\n              boolean allKanji = true;\n              // check if node consists of only kanji\n              for (int pos = 0; pos < length; pos++) {\n                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){\n                  allKanji = false;\n                  break;\n                }\t\t\t\t\n              }\n              \n              if (allKanji) {\t// Process only Kanji keywords\n                pathCost += (length - SEARCH_MODE_KANJI_LENGTH) * SEARCH_MODE_KANJI_PENALTY;\n              } else if (length > SEARCH_MODE_OTHER_LENGTH) {\n                pathCost += (length - SEARCH_MODE_OTHER_LENGTH) * SEARCH_MODE_OTHER_PENALTY;\t\t\t\t\t\t\t\t\n              }\n            }\n          }\n          \n          if (pathCost < leastPathCost){\t// If total cost is lower than before, set current previous node as best left node (previous means left).\n            leastPathCost = pathCost;\n            node.setPathCost(leastPathCost);\n            node.setLeftNode(leftNode);\n          }\t\t\t\t\t\n        }\n      }\n    }\n    \n    // track best path\n    ViterbiNode node = endIndexArr[0][0];\t// EOS\n    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();\n    result.add(node);\n    while (true) {\n      ViterbiNode leftNode = node.getLeftNode();\n      if (leftNode == null) {\n        break;\n      }\n      \n      // EXTENDED mode convert unknown word into unigram node\n      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {\n        byte unigramWordId = CharacterDefinition.NGRAM;\n        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required\n        char[] surfaceForm = leftNode.getSurfaceForm();\n        int offset = leftNode.getOffset();\n        int length = leftNode.getLength();\n        for (int i = length - 1; i >= 0; i--) {\n          int charLen = 1;\n          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {\n            i--;\n            charLen = 2;\n          }\n          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);\n          result.addFirst(uniGramNode);\n        }\n      } else {\n        result.addFirst(leftNode);\t\t\n      }\n      node = leftNode;\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /**\n   * Find best path from input lattice.\n   * @param lattice the result of build method\n   * @return\tList of ViterbiNode which consist best path \n   */\n  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {\n    ViterbiNode[][] startIndexArr = lattice[0];\n    ViterbiNode[][] endIndexArr = lattice[1];\n    \n    for (int i = 1; i < startIndexArr.length; i++){\n      \n      if (startIndexArr[i] == null || endIndexArr[i] == null){\t// continue since no array which contains ViterbiNodes exists. Or no previous node exists.\n        continue;\n      }\n      \n      for (ViterbiNode node : startIndexArr[i]) {\n        if (node == null){\t// If array doesn't contain ViterbiNode any more, continue to next index\n          break;\n        }\n        \n        int backwardConnectionId = node.getLeftId();\n        int wordCost = node.getWordCost();\n        int leastPathCost = DEFAULT_COST;\n        for (ViterbiNode leftNode : endIndexArr[i]) {\n          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index\n            break;\n          }\n          \n          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;\t// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]\n          \n          // \"Search mode\". Add extra costs if it is long node.\n          if (searchMode) {\n            //\t\t\t\t\t\tSystem.out.print(\"\"); // If this line exists, kuromoji runs faster for some reason when searchMode == false.\n            char[] surfaceForm = node.getSurfaceForm();\n            int offset = node.getOffset();\n            int length = node.getLength();\n            if (length > SEARCH_MODE_LENGTH_KANJI) {\n              boolean allKanji = true;\n              // check if node consists of only kanji\n              for (int pos = 0; pos < length; pos++) {\n                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){\n                  allKanji = false;\n                  break;\n                }\t\t\t\t\n              }\n              \n              if (allKanji) {\t// Process only Kanji keywords\n                pathCost += (length - SEARCH_MODE_LENGTH_KANJI) * SEARCH_MODE_PENALTY;\n              } else if (length > SEARCH_MODE_LENGTH) {\n                pathCost += (length - SEARCH_MODE_LENGTH) * SEARCH_MODE_PENALTY;\t\t\t\t\t\t\t\t\n              }\n            }\n          }\n          \n          if (pathCost < leastPathCost){\t// If total cost is lower than before, set current previous node as best left node (previous means left).\n            leastPathCost = pathCost;\n            node.setPathCost(leastPathCost);\n            node.setLeftNode(leftNode);\n          }\t\t\t\t\t\n        }\n      }\n    }\n    \n    // track best path\n    ViterbiNode node = endIndexArr[0][0];\t// EOS\n    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();\n    result.add(node);\n    while (true) {\n      ViterbiNode leftNode = node.getLeftNode();\n      if (leftNode == null) {\n        break;\n      }\n      \n      // EXTENDED mode convert unknown word into unigram node\n      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {\n        byte unigramWordId = CharacterDefinition.NGRAM;\n        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required\n        char[] surfaceForm = leftNode.getSurfaceForm();\n        int offset = leftNode.getOffset();\n        int length = leftNode.getLength();\n        for (int i = length - 1; i >= 0; i--) {\n          int charLen = 1;\n          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {\n            i--;\n            charLen = 2;\n          }\n          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);\n          result.addFirst(uniGramNode);\n        }\n      } else {\n        result.addFirst(leftNode);\t\t\n      }\n      node = leftNode;\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0984ad47974c2d5d354519ddb2aa8358973a6271","date":1330868053,"type":4,"author":"Christian Moen","isMerge":false,"pathNew":"/dev/null","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Find best path from input lattice.\n   * @param lattice the result of build method\n   * @return\tList of ViterbiNode which consist best path \n   */\n  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {\n    ViterbiNode[][] startIndexArr = lattice[0];\n    ViterbiNode[][] endIndexArr = lattice[1];\n    \n    for (int i = 1; i < startIndexArr.length; i++){\n      \n      if (startIndexArr[i] == null || endIndexArr[i] == null){\t// continue since no array which contains ViterbiNodes exists. Or no previous node exists.\n        continue;\n      }\n      \n      for (ViterbiNode node : startIndexArr[i]) {\n        if (node == null){\t// If array doesn't contain ViterbiNode any more, continue to next index\n          break;\n        }\n        \n        int backwardConnectionId = node.getLeftId();\n        int wordCost = node.getWordCost();\n        int leastPathCost = DEFAULT_COST;\n        for (ViterbiNode leftNode : endIndexArr[i]) {\n          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index\n            break;\n          }\n          \n          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;\t// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]\n          \n          // \"Search mode\". Add extra costs if it is long node.\n          if (searchMode) {\n            //\t\t\t\t\t\tSystem.out.print(\"\"); // If this line exists, kuromoji runs faster for some reason when searchMode == false.\n            char[] surfaceForm = node.getSurfaceForm();\n            int offset = node.getOffset();\n            int length = node.getLength();\n            if (length > SEARCH_MODE_KANJI_LENGTH) {\n              boolean allKanji = true;\n              // check if node consists of only kanji\n              for (int pos = 0; pos < length; pos++) {\n                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){\n                  allKanji = false;\n                  break;\n                }\t\t\t\t\n              }\n              \n              if (allKanji) {\t// Process only Kanji keywords\n                pathCost += (length - SEARCH_MODE_KANJI_LENGTH) * SEARCH_MODE_KANJI_PENALTY;\n              } else if (length > SEARCH_MODE_OTHER_LENGTH) {\n                pathCost += (length - SEARCH_MODE_OTHER_LENGTH) * SEARCH_MODE_OTHER_PENALTY;\t\t\t\t\t\t\t\t\n              }\n            }\n          }\n          \n          if (pathCost < leastPathCost){\t// If total cost is lower than before, set current previous node as best left node (previous means left).\n            leastPathCost = pathCost;\n            node.setPathCost(leastPathCost);\n            node.setLeftNode(leftNode);\n          }\t\t\t\t\t\n        }\n      }\n    }\n    \n    // track best path\n    ViterbiNode node = endIndexArr[0][0];\t// EOS\n    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();\n    result.add(node);\n    while (true) {\n      ViterbiNode leftNode = node.getLeftNode();\n      if (leftNode == null) {\n        break;\n      }\n      \n      // EXTENDED mode convert unknown word into unigram node\n      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {\n        byte unigramWordId = CharacterDefinition.NGRAM;\n        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required\n        char[] surfaceForm = leftNode.getSurfaceForm();\n        int offset = leftNode.getOffset();\n        int length = leftNode.getLength();\n        for (int i = length - 1; i >= 0; i--) {\n          int charLen = 1;\n          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {\n            i--;\n            charLen = 2;\n          }\n          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);\n          result.addFirst(uniGramNode);\n        }\n      } else {\n        result.addFirst(leftNode);\t\t\n      }\n      node = leftNode;\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":4,"author":"Ryan McKinley","isMerge":true,"pathNew":"/dev/null","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#search(ViterbiNode[][][]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Find best path from input lattice.\n   * @param lattice the result of build method\n   * @return\tList of ViterbiNode which consist best path \n   */\n  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {\n    ViterbiNode[][] startIndexArr = lattice[0];\n    ViterbiNode[][] endIndexArr = lattice[1];\n    \n    for (int i = 1; i < startIndexArr.length; i++){\n      \n      if (startIndexArr[i] == null || endIndexArr[i] == null){\t// continue since no array which contains ViterbiNodes exists. Or no previous node exists.\n        continue;\n      }\n      \n      for (ViterbiNode node : startIndexArr[i]) {\n        if (node == null){\t// If array doesn't contain ViterbiNode any more, continue to next index\n          break;\n        }\n        \n        int backwardConnectionId = node.getLeftId();\n        int wordCost = node.getWordCost();\n        int leastPathCost = DEFAULT_COST;\n        for (ViterbiNode leftNode : endIndexArr[i]) {\n          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index\n            break;\n          }\n          \n          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;\t// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]\n          \n          // \"Search mode\". Add extra costs if it is long node.\n          if (searchMode) {\n            //\t\t\t\t\t\tSystem.out.print(\"\"); // If this line exists, kuromoji runs faster for some reason when searchMode == false.\n            char[] surfaceForm = node.getSurfaceForm();\n            int offset = node.getOffset();\n            int length = node.getLength();\n            if (length > SEARCH_MODE_KANJI_LENGTH) {\n              boolean allKanji = true;\n              // check if node consists of only kanji\n              for (int pos = 0; pos < length; pos++) {\n                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){\n                  allKanji = false;\n                  break;\n                }\t\t\t\t\n              }\n              \n              if (allKanji) {\t// Process only Kanji keywords\n                pathCost += (length - SEARCH_MODE_KANJI_LENGTH) * SEARCH_MODE_KANJI_PENALTY;\n              } else if (length > SEARCH_MODE_OTHER_LENGTH) {\n                pathCost += (length - SEARCH_MODE_OTHER_LENGTH) * SEARCH_MODE_OTHER_PENALTY;\t\t\t\t\t\t\t\t\n              }\n            }\n          }\n          \n          if (pathCost < leastPathCost){\t// If total cost is lower than before, set current previous node as best left node (previous means left).\n            leastPathCost = pathCost;\n            node.setPathCost(leastPathCost);\n            node.setLeftNode(leftNode);\n          }\t\t\t\t\t\n        }\n      }\n    }\n    \n    // track best path\n    ViterbiNode node = endIndexArr[0][0];\t// EOS\n    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();\n    result.add(node);\n    while (true) {\n      ViterbiNode leftNode = node.getLeftNode();\n      if (leftNode == null) {\n        break;\n      }\n      \n      // EXTENDED mode convert unknown word into unigram node\n      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {\n        byte unigramWordId = CharacterDefinition.NGRAM;\n        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required\n        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required\n        char[] surfaceForm = leftNode.getSurfaceForm();\n        int offset = leftNode.getOffset();\n        int length = leftNode.getLength();\n        for (int i = length - 1; i >= 0; i--) {\n          int charLen = 1;\n          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {\n            i--;\n            charLen = 2;\n          }\n          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);\n          result.addFirst(uniGramNode);\n        }\n      } else {\n        result.addFirst(leftNode);\t\t\n      }\n      node = leftNode;\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["f7df4efdafac6329df3550939440c9f79b5ad525","0984ad47974c2d5d354519ddb2aa8358973a6271"],"0984ad47974c2d5d354519ddb2aa8358973a6271":["f7df4efdafac6329df3550939440c9f79b5ad525"],"f7df4efdafac6329df3550939440c9f79b5ad525":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0984ad47974c2d5d354519ddb2aa8358973a6271"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"0984ad47974c2d5d354519ddb2aa8358973a6271":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f7df4efdafac6329df3550939440c9f79b5ad525":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0984ad47974c2d5d354519ddb2aa8358973a6271"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["f7df4efdafac6329df3550939440c9f79b5ad525"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}