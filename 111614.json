{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","commits":[{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24b51843dd98041bc40be26a47e44d7cb49bef72","date":1403043869,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = null;\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = null;\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f13b9d4c228e77327b284419c8cafd16913a7a19","date":1405437837,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = null;\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdf16ebe435fc9daea90a73b8683ff001c6d3523","date":1409931231,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      // create a unified collection of field types from zk and in the local\n      newSchema.mergeFieldTypesFromZk(document, xpath);\n\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39794fb4aa0ff1978711872806f396013716b868","date":1421259910,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      // create a unified collection of field types from zk and in the local\n      newSchema.mergeFieldTypesFromZk(document, xpath);\n\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n\n      // notify analyzers and other objects for our fieldTypes\n      for (FieldType fieldType : newSchema.fieldTypes.values())\n        informResourceLoaderAwareObjectsForFieldType(fieldType);\n\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      // create a unified collection of field types from zk and in the local\n      newSchema.mergeFieldTypesFromZk(document, xpath);\n\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeeea2295d6355a29e259130a5c48ace73022d7c","date":1426569216,"type":4,"author":"Steven Rowe","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":null,"sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      // create a unified collection of field types from zk and in the local\n      newSchema.mergeFieldTypesFromZk(document, xpath);\n\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n\n      // notify analyzers and other objects for our fieldTypes\n      for (FieldType fieldType : newSchema.fieldTypes.values())\n        informResourceLoaderAwareObjectsForFieldType(fieldType);\n\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#reloadFields(InputSource,int).mjava","sourceNew":null,"sourceOld":"  /** \n   * Called from ZkIndexSchemaReader to merge the fields from the serialized managed schema\n   * on ZooKeeper with the local managed schema.\n   * \n   * @param inputSource The serialized content of the managed schema from ZooKeeper\n   * @param schemaZkVersion The ZK version of the managed schema on ZooKeeper\n   * @return The new merged schema\n   */\n  ManagedIndexSchema reloadFields(InputSource inputSource, int schemaZkVersion) {\n    ManagedIndexSchema newSchema;\n    try {\n      newSchema = shallowCopy(false);\n      Config schemaConf = new Config(loader, SCHEMA, inputSource, SLASH+SCHEMA+SLASH);\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      // create a unified collection of field types from zk and in the local\n      newSchema.mergeFieldTypesFromZk(document, xpath);\n\n      newSchema.loadFields(document, xpath);\n      // let's completely rebuild the copy fields from the schema in ZK.\n      // create new copyField-related objects so we don't affect the\n      // old schema\n      newSchema.copyFieldsMap = new HashMap<>();\n      newSchema.dynamicCopyFields = new DynamicCopy[] {};\n      newSchema.copyFieldTargetCounts = new HashMap<>();\n      newSchema.loadCopyFields(document, xpath);\n      if (null != uniqueKeyField) {\n        newSchema.requiredFields.add(uniqueKeyField);\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : newSchema.schemaAware) {\n        aware.inform(newSchema);\n      }\n\n      // notify analyzers and other objects for our fieldTypes\n      for (FieldType fieldType : newSchema.fieldTypes.values())\n        informResourceLoaderAwareObjectsForFieldType(fieldType);\n\n      newSchema.refreshAnalyzers();\n      newSchema.schemaZkVersion = schemaZkVersion;\n    } catch (SolrException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Schema Parsing Failed: \" + e.getMessage(), e);\n    }\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39794fb4aa0ff1978711872806f396013716b868":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["39794fb4aa0ff1978711872806f396013716b868","eeeea2295d6355a29e259130a5c48ace73022d7c"],"24b51843dd98041bc40be26a47e44d7cb49bef72":["08970e5b8411182a29412c177eff67ec1110095b"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["39794fb4aa0ff1978711872806f396013716b868"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["08970e5b8411182a29412c177eff67ec1110095b","24b51843dd98041bc40be26a47e44d7cb49bef72"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f13b9d4c228e77327b284419c8cafd16913a7a19":["24b51843dd98041bc40be26a47e44d7cb49bef72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["f13b9d4c228e77327b284419c8cafd16913a7a19"],"08970e5b8411182a29412c177eff67ec1110095b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"39794fb4aa0ff1978711872806f396013716b868":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","eeeea2295d6355a29e259130a5c48ace73022d7c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"24b51843dd98041bc40be26a47e44d7cb49bef72":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","f13b9d4c228e77327b284419c8cafd16913a7a19"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["08970e5b8411182a29412c177eff67ec1110095b"],"f13b9d4c228e77327b284419c8cafd16913a7a19":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["39794fb4aa0ff1978711872806f396013716b868"],"08970e5b8411182a29412c177eff67ec1110095b":["24b51843dd98041bc40be26a47e44d7cb49bef72","e57c73924f3b8c19defa62e96bfa34a4922d49c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","e57c73924f3b8c19defa62e96bfa34a4922d49c2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}