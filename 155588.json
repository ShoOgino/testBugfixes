{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","commits":[{"id":"f9043cd220362869f58e50f635c13c362f8377da","date":1404227796,"type":1,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n      \n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = zkr.getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n      \n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n      \n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(replicas.size() == rf);\n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n    \n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n    \n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n      \n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n      \n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n        \n        if (!leader.equals(replica)) \n          notLeaders.put(replica.getName(), replica);\n      }\n      \n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n    \n    if (!allReplicasUp) \n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n    \n    if (notLeaders.isEmpty()) \n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n    \n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n    \n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98287baa2c8d136e801f366a73e27a23285b7b98","date":1427241813,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<String,Replica>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<Replica>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        String replicaState = replica.getStr(ZkStateReader.STATE_PROP);\n        if (!ZkStateReader.ACTIVE.equals(replicaState)) {\n          log.info(\"Replica \" + replica.getName() + \" is currently \" + replicaState);\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(true); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState(true);\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    long startMs = System.currentTimeMillis();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    long diffMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took \" + diffMs + \" ms to see all replicas become active.\");\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.updateClusterState(); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      // refresh state every 2 secs\n      if (waitMs % 2000 == 0)\n        cloudClient.getZkStateReader().updateClusterState();\n\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getActiveSlices(testCollectionName);\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      Slice shard = cs.getSlice(testCollectionName, shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","date":1571071547,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>();\n    replicas.addAll(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#ensureAllReplicasAreActive(String,String,int,int,int).mjava","sourceNew":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      if (log.isInfoEnabled()) {\n        log.info(\"Found {}  replicas and leader on {} for {} in {}\"\n            , replicas.size(), leader.getNodeName(), shardId, testCollectionName);\n      }\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          }\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n    }\n\n    List<Replica> replicas = new ArrayList<>(notLeaders.values());\n    return replicas;\n  }\n\n","sourceOld":"  protected List<Replica> ensureAllReplicasAreActive(String testCollectionName, String shardId, int shards, int rf, int maxWaitSecs) throws Exception {\n    final RTimer timer = new RTimer();\n\n    Map<String,Replica> notLeaders = new HashMap<>();\n\n    ZkStateReader zkr = cloudClient.getZkStateReader();\n    zkr.forceUpdateCollection(testCollectionName); // force the state to be fresh\n\n    ClusterState cs = zkr.getClusterState();\n    Collection<Slice> slices = cs.getCollection(testCollectionName).getActiveSlices();\n    assertTrue(slices.size() == shards);\n    boolean allReplicasUp = false;\n    long waitMs = 0L;\n    long maxWaitMs = maxWaitSecs * 1000L;\n    Replica leader = null;\n    ZkShardTerms zkShardTerms = new ZkShardTerms(testCollectionName, shardId, cloudClient.getZkStateReader().getZkClient());\n    while (waitMs < maxWaitMs && !allReplicasUp) {\n      cs = cloudClient.getZkStateReader().getClusterState();\n      assertNotNull(cs);\n      final DocCollection docCollection = cs.getCollectionOrNull(testCollectionName);\n      assertNotNull(\"No collection found for \" + testCollectionName, docCollection);\n      Slice shard = docCollection.getSlice(shardId);\n      assertNotNull(\"No Slice for \"+shardId, shard);\n      allReplicasUp = true; // assume true\n      Collection<Replica> replicas = shard.getReplicas();\n      assertTrue(\"Did not find correct number of replicas. Expected:\" + rf + \" Found:\" + replicas.size(), replicas.size() == rf);\n      \n      leader = shard.getLeader();\n      assertNotNull(leader);\n      log.info(\"Found \"+replicas.size()+\" replicas and leader on \"+\n        leader.getNodeName()+\" for \"+shardId+\" in \"+testCollectionName);\n\n      // ensure all replicas are \"active\" and identify the non-leader replica\n      for (Replica replica : replicas) {\n        if (!zkShardTerms.canBecomeLeader(replica.getName()) ||\n            replica.getState() != Replica.State.ACTIVE) {\n          log.info(\"Replica {} is currently {}\", replica.getName(), replica.getState());\n          allReplicasUp = false;\n        }\n\n        if (!leader.equals(replica))\n          notLeaders.put(replica.getName(), replica);\n      }\n\n      if (!allReplicasUp) {\n        try {\n          Thread.sleep(500L);\n        } catch (Exception ignoreMe) {}\n        waitMs += 500L;\n      }\n    } // end while\n\n    zkShardTerms.close();\n    if (!allReplicasUp)\n      fail(\"Didn't see all replicas for shard \"+shardId+\" in \"+testCollectionName+\n          \" come up within \" + maxWaitMs + \" ms! ClusterState: \" + printClusterStateInfo());\n\n    if (notLeaders.isEmpty())\n      fail(\"Didn't isolate any replicas that are not the leader! ClusterState: \" + printClusterStateInfo());\n\n    log.info(\"Took {} ms to see all replicas become active.\", timer.getTime());\n\n    List<Replica> replicas = new ArrayList<>(notLeaders.values());\n    return replicas;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["84f20f331d8001864545c7021812d8c6509c7593"],"abb23fcc2461782ab204e61213240feb77d355aa":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"344b0840364d990b29b97467bfcc766ff8325d11":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"98287baa2c8d136e801f366a73e27a23285b7b98":["abb23fcc2461782ab204e61213240feb77d355aa"],"84f20f331d8001864545c7021812d8c6509c7593":["344b0840364d990b29b97467bfcc766ff8325d11"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"f9043cd220362869f58e50f635c13c362f8377da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["98287baa2c8d136e801f366a73e27a23285b7b98"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["abb23fcc2461782ab204e61213240feb77d355aa","98287baa2c8d136e801f366a73e27a23285b7b98"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","344b0840364d990b29b97467bfcc766ff8325d11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["f9043cd220362869f58e50f635c13c362f8377da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"b0b597c65628ca9e73913a07e81691f8229bae35":["84f20f331d8001864545c7021812d8c6509c7593","23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"]},"commit2Childs":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["a966532d92cf9ba2856f15a8140151bb6b518e4b","b0b597c65628ca9e73913a07e81691f8229bae35"],"abb23fcc2461782ab204e61213240feb77d355aa":["98287baa2c8d136e801f366a73e27a23285b7b98","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"344b0840364d990b29b97467bfcc766ff8325d11":["84f20f331d8001864545c7021812d8c6509c7593","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"98287baa2c8d136e801f366a73e27a23285b7b98":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"84f20f331d8001864545c7021812d8c6509c7593":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","b0b597c65628ca9e73913a07e81691f8229bae35"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["344b0840364d990b29b97467bfcc766ff8325d11","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f9043cd220362869f58e50f635c13c362f8377da":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f9043cd220362869f58e50f635c13c362f8377da"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["abb23fcc2461782ab204e61213240feb77d355aa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}