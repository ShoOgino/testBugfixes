{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","commits":[{"id":"c83f985d9828d30801541f1eed26aa3169646baf","date":1409315453,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"/dev/null","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, connManager,\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    numOpens.incrementAndGet();\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8f10f8a5700202b5f7eba33d154eace46f05bd4","date":1416408776,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    numOpens.incrementAndGet();\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, connManager,\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    numOpens.incrementAndGet();\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    numOpens.incrementAndGet();\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":["c83f985d9828d30801541f1eed26aa3169646baf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout, \n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    \n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n    \n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    \n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9272a617a9cbebf86be127014bbbacd7cf8f8e83","date":1467480344,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20be168d828ac40d262f85364d02f15b491dd88b","date":1469725145,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkClientConnectionStrategy = strat;\n    this.zkServerAddress = zkServerAddress;\n\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eacdba691ec9e0ff24c589e65a852b9915265e6","date":1508917488,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          new ZkUpdate() {\n            @Override\n            public void update(SolrZooKeeper zooKeeper) {\n              SolrZooKeeper oldKeeper = keeper;\n              keeper = zooKeeper;\n              try {\n                closeKeeper(oldKeeper);\n              } finally {\n                if (isClosed) {\n                  // we may have been closed\n                  closeKeeper(SolrZkClient.this.keeper);\n                }\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":5,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider,IsClosed).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient#SolrZkClient(String,int,int,ZkClientConnectionStrategy,OnReconnect,BeforeReconnect,ZkACLProvider).mjava","sourceNew":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider, IsClosed higherLevelIsClosed) {\n    this.zkServerAddress = zkServerAddress;\n    this.higherLevelIsClosed = higherLevelIsClosed;\n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout, new IsClosed() {\n      \n      @Override\n      public boolean isClosed() {\n        return SolrZkClient.this.isClosed();\n      }\n    });\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect, new IsClosed() {\n          \n          @Override\n          public boolean isClosed() {\n            return SolrZkClient.this.isClosed();\n          }\n        });\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","sourceOld":"  public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n      ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n    this.zkServerAddress = zkServerAddress;\n    \n    if (strat == null) {\n      strat = new DefaultConnectionStrategy();\n    }\n    this.zkClientConnectionStrategy = strat;\n\n    if (!strat.hasZkCredentialsToAddAutomatically()) {\n      ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();\n      strat.setZkCredentialsToAddAutomatically(zkCredentialsToAddAutomatically);\n    }\n\n    this.zkClientTimeout = zkClientTimeout;\n    // we must retry at least as long as the session timeout\n    zkCmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    connManager = new ConnectionManager(\"ZooKeeperConnection Watcher:\"\n        + zkServerAddress, this, zkServerAddress, strat, onReconnect, beforeReconnect);\n\n    try {\n      strat.connect(zkServerAddress, zkClientTimeout, wrapWatcher(connManager),\n          zooKeeper -> {\n            SolrZooKeeper oldKeeper = keeper;\n            keeper = zooKeeper;\n            try {\n              closeKeeper(oldKeeper);\n            } finally {\n              if (isClosed) {\n                // we may have been closed\n                closeKeeper(SolrZkClient.this.keeper);\n              }\n            }\n          });\n    } catch (Exception e) {\n      connManager.close();\n      if (keeper != null) {\n        try {\n          keeper.close();\n        } catch (InterruptedException e1) {\n          Thread.currentThread().interrupt();\n        }\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n\n    try {\n      connManager.waitForConnected(clientConnectTimeout);\n    } catch (Exception e) {\n      connManager.close();\n      try {\n        keeper.close();\n      } catch (InterruptedException e1) {\n        Thread.currentThread().interrupt();\n      }\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n    assert ObjectReleaseTracker.track(this);\n    if (zkACLProvider == null) {\n      this.zkACLProvider = createZkACLProvider();\n    } else {\n      this.zkACLProvider = zkACLProvider;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"86290366cefc1b9d4eced13b430858c4a4c0421d":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"a8f10f8a5700202b5f7eba33d154eace46f05bd4":["c83f985d9828d30801541f1eed26aa3169646baf"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["1eacdba691ec9e0ff24c589e65a852b9915265e6"],"9272a617a9cbebf86be127014bbbacd7cf8f8e83":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eacdba691ec9e0ff24c589e65a852b9915265e6":["20be168d828ac40d262f85364d02f15b491dd88b"],"20be168d828ac40d262f85364d02f15b491dd88b":["9272a617a9cbebf86be127014bbbacd7cf8f8e83"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["a8f10f8a5700202b5f7eba33d154eace46f05bd4"],"c83f985d9828d30801541f1eed26aa3169646baf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["86290366cefc1b9d4eced13b430858c4a4c0421d","20be168d828ac40d262f85364d02f15b491dd88b"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["9272a617a9cbebf86be127014bbbacd7cf8f8e83","20be168d828ac40d262f85364d02f15b491dd88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"86290366cefc1b9d4eced13b430858c4a4c0421d":["9272a617a9cbebf86be127014bbbacd7cf8f8e83","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a8f10f8a5700202b5f7eba33d154eace46f05bd4":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9272a617a9cbebf86be127014bbbacd7cf8f8e83":["20be168d828ac40d262f85364d02f15b491dd88b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c83f985d9828d30801541f1eed26aa3169646baf"],"1eacdba691ec9e0ff24c589e65a852b9915265e6":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"20be168d828ac40d262f85364d02f15b491dd88b":["1eacdba691ec9e0ff24c589e65a852b9915265e6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"c83f985d9828d30801541f1eed26aa3169646baf":["a8f10f8a5700202b5f7eba33d154eace46f05bd4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}