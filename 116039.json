{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","commits":[{"id":"f366ce28775e2b8ea4e06355009471328711666d","date":1360551293,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedSetDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedSetDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e129598ae448211d969dd7cdf2ad4558a0658a1","date":1362963550,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedSetDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64e6baad25b7155a116cb0126b4e2a06b945a5c5","date":1362976847,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedSetDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6","date":1363054647,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = new SortedSetDocValuesTermsEnum(values[i]);\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","date":1397206443,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_SORTED_SET;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = SortedSetDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":["f366ce28775e2b8ea4e06355009471328711666d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_SORTED_SET;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bcfd864fb8b916f7d21f2579d2010a31892055d","date":1403359094,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      TermsEnum enums[] = new TermsEnum[values.length];\n      for (int i = 0; i < values.length; i++) {\n        enums[i] = values[i].termsEnum();\n      }\n      OrdinalMap mapping = new OrdinalMap(r.getCoreCacheKey(), enums);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link AtomicReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getSortedSetValues(IndexReader,String).mjava","sourceNew":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      IndexReader.CacheHelper cacheHelper = r.getReaderCacheHelper();\n      IndexReader.CacheKey owner = cacheHelper == null ? null : cacheHelper.getKey();\n      OrdinalMap mapping = OrdinalMap.build(owner, values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","sourceOld":"  /** Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).\n   * <p>\n   * This is an extremely slow way to access sorted values. Instead, access them per-segment\n   * with {@link LeafReader#getSortedSetDocValues(String)}\n   * </p>  \n   */\n  public static SortedSetDocValues getSortedSetValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getSortedSetDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final SortedSetDocValues[] values = new SortedSetDocValues[size];\n    final int[] starts = new int[size+1];\n    long totalCost = 0;\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      SortedSetDocValues v = context.reader().getSortedSetDocValues(field);\n      if (v == null) {\n        v = DocValues.emptySortedSet();\n      } else {\n        anyReal = true;\n        totalCost += v.cost();\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (anyReal == false) {\n      return null;\n    } else {\n      OrdinalMap mapping = OrdinalMap.build(r.getCoreCacheKey(), values, PackedInts.DEFAULT);\n      return new MultiSortedSetDocValues(values, starts, mapping, totalCost);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f366ce28775e2b8ea4e06355009471328711666d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["5bcfd864fb8b916f7d21f2579d2010a31892055d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c9fb5f46e264daf5ba3860defe623a89d202dd87","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["5c2b6033d1fc841b41dbf56c765ce3dc053ecba6"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6":["64e6baad25b7155a116cb0126b4e2a06b945a5c5"],"7e129598ae448211d969dd7cdf2ad4558a0658a1":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"d211216c83f01894810543d1c107160a9ae3650b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"64e6baad25b7155a116cb0126b4e2a06b945a5c5":["7e129598ae448211d969dd7cdf2ad4558a0658a1"],"f366ce28775e2b8ea4e06355009471328711666d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"5bcfd864fb8b916f7d21f2579d2010a31892055d":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d211216c83f01894810543d1c107160a9ae3650b"]},"commit2Childs":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["5bcfd864fb8b916f7d21f2579d2010a31892055d"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["7e129598ae448211d969dd7cdf2ad4558a0658a1"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","22aab7a3b640b0dba26cc5e9416bc7af93614b46","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"5c2b6033d1fc841b41dbf56c765ce3dc053ecba6":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"7e129598ae448211d969dd7cdf2ad4558a0658a1":["64e6baad25b7155a116cb0126b4e2a06b945a5c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ddbb72a33557d2b5bc22ee95daf3281c43560502","f366ce28775e2b8ea4e06355009471328711666d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d211216c83f01894810543d1c107160a9ae3650b"],"d211216c83f01894810543d1c107160a9ae3650b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"f366ce28775e2b8ea4e06355009471328711666d":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"64e6baad25b7155a116cb0126b4e2a06b945a5c5":["5c2b6033d1fc841b41dbf56c765ce3dc053ecba6"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"5bcfd864fb8b916f7d21f2579d2010a31892055d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","815972da4a13279b8e975d2e32ca450649d6c295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}