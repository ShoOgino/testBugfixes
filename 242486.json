{"path":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","commits":[{"id":"3e37a877cbb3c0d736bdc1fcb3aea4c24015799f","date":1293976079,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"/dev/null","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"/dev/null","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"/dev/null","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9325c7ff9928fabe81c28553b41fc7aa57dfab","date":1295896411,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790e1fde4caa765b3faaad3fbcd25c6973450336","date":1296689245,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = new IndexSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"160d004a0e8f5361a446f9d01456aee1c1af20dc","date":1301061642,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", Field.Store.NO, Field.Index.NOT_ANALYZED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (searcher != null) searcher.close();\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","date":1328532481,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarityProvider(new DefaultSimilarityProvider() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestConstantScoreQuery#testWrapped2Times().mjava","sourceNew":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","sourceOld":"  public void testWrapped2Times() throws Exception {\n    Directory directory = null;\n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    try {\n      directory = newDirectory();\n      RandomIndexWriter writer = new RandomIndexWriter (random, directory);\n\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"term\", StringField.TYPE_UNSTORED));\n      writer.addDocument(doc);\n\n      reader = writer.getReader();\n      writer.close();\n      searcher = newSearcher(reader);\n      \n      // set a similarity that does not normalize our boost away\n      searcher.setSimilarity(new DefaultSimilarity() {\n        @Override\n        public float queryNorm(float sumOfSquaredWeights) {\n          return 1.0f;\n        }\n      });\n      \n      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term (\"field\", \"term\")));\n      csq1.setBoost(2.0f);\n      final Query csq2 = new ConstantScoreQuery(csq1);\n      csq2.setBoost(5.0f);\n      \n      final BooleanQuery bq = new BooleanQuery();\n      bq.add(csq1, BooleanClause.Occur.SHOULD);\n      bq.add(csq2, BooleanClause.Occur.SHOULD);\n      \n      final Query csqbq = new ConstantScoreQuery(bq);\n      csqbq.setBoost(17.0f);\n      \n      checkHits(searcher, csq1, csq1.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), null);\n      checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());\n      \n      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!\n      final String bucketScorerClass = BooleanScorer.class.getName() + \"$BucketScorer\";\n      checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);\n      checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);\n    } finally {\n      if (reader != null) reader.close();\n      if (directory != null) directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e37a877cbb3c0d736bdc1fcb3aea4c24015799f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["1509f151d7692d84fae414b2b799ac06ba60fcb4","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"3e37a877cbb3c0d736bdc1fcb3aea4c24015799f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["fd9325c7ff9928fabe81c28553b41fc7aa57dfab"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["3e37a877cbb3c0d736bdc1fcb3aea4c24015799f"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e37a877cbb3c0d736bdc1fcb3aea4c24015799f"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","160d004a0e8f5361a446f9d01456aee1c1af20dc"],"160d004a0e8f5361a446f9d01456aee1c1af20dc":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","160d004a0e8f5361a446f9d01456aee1c1af20dc"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","790e1fde4caa765b3faaad3fbcd25c6973450336"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["160d004a0e8f5361a446f9d01456aee1c1af20dc"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","790e1fde4caa765b3faaad3fbcd25c6973450336"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"3e37a877cbb3c0d736bdc1fcb3aea4c24015799f":["70ad682703b8585f5d0a637efec044d57ec05efb","fd9325c7ff9928fabe81c28553b41fc7aa57dfab","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["160d004a0e8f5361a446f9d01456aee1c1af20dc","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"fd9325c7ff9928fabe81c28553b41fc7aa57dfab":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","790e1fde4caa765b3faaad3fbcd25c6973450336"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"160d004a0e8f5361a446f9d01456aee1c1af20dc":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","1509f151d7692d84fae414b2b799ac06ba60fcb4"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","3e37a877cbb3c0d736bdc1fcb3aea4c24015799f","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}