{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), clusterStateVersion, ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), col.getZNodeVersion(), ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.get(collection).invalidate();\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), clusterStateVersion, ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<Replica> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            Replica ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getProperties().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getProperties().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getProperties().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        Replica ri = null;\n        for (Replica a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getProperties().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), col.getZNodeVersion(), ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.get(collection).invalidate();\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), col.getZNodeVersion(), ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.get(collection).invalidate();\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","sourceNew":null,"sourceOld":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n              s.getState(), collection, slice);\n        }\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        if (log.isTraceEnabled()) {\n          log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n              s.getState(), collection, slice);\n        }\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<Replica> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            Replica ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getProperties().get(ZkStateReader.LEADER_PROP) != null) {\n                  if (log.isTraceEnabled()) {\n                    log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  }\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                if (log.isTraceEnabled()) {\n                  log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                }\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getProperties().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getProperties().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          if (log.isTraceEnabled()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          }\n          return;\n        }\n        if (active.isEmpty()) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          }\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          }\n          return;\n        }\n        // pick first active one\n        Replica ri = null;\n        for (Replica a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getProperties().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        if (log.isDebugEnabled()) {\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), col.getZNodeVersion(), ri);\n        }\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.get(collection).invalidate();\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["e35f2dde06b35aa9904949a3a93fabd090371077"],"e35f2dde06b35aa9904949a3a93fabd090371077":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"e35f2dde06b35aa9904949a3a93fabd090371077":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["e35f2dde06b35aa9904949a3a93fabd090371077"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}