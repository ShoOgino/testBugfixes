{"path":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","commits":[{"id":"c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa","date":1502501808,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","pathOld":"/dev/null","sourceNew":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","pathOld":"/dev/null","sourceNew":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b67953ff80d8ef5d119fd6c3782f2552cf8e60c","date":1504237573,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","sourceNew":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","sourceOld":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    final Long firstSearcherNanos = monitor.searcher.poll(5000, MILLISECONDS);\n    assertNotNull(\"didn't get a single new searcher\", firstSearcherNanos);\n    for (int i = 0; i <= softCommitMaxDocs; i++) {\n      assertQ(\"should find one\", req(\"id:\"+(8000 + i)) ,\"//result[@numFound=1]\" );\n    }\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","sourceNew":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","sourceOld":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    final Long firstSearcherNanos = monitor.searcher.poll(5000, MILLISECONDS);\n    assertNotNull(\"didn't get a single new searcher\", firstSearcherNanos);\n    for (int i = 0; i <= softCommitMaxDocs; i++) {\n      assertQ(\"should find one\", req(\"id:\"+(8000 + i)) ,\"//result[@numFound=1]\" );\n    }\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/SoftAutoCommitTest#testSoftAndHardCommitMaxDocs().mjava","sourceNew":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","sourceOld":"  public void testSoftAndHardCommitMaxDocs() throws Exception {\n\n    // NOTE WHEN READING THIS TEST...\n    // The maxDocs settings on the CommitTrackers are the \"upper bound\"\n    // of how many docs can be added with out doing a commit.\n    // That means they are one less then the actual number of docs that will trigger a commit.\n    final int softCommitMaxDocs = 5;\n    final int hardCommitMaxDocs = 7;\n\n    assert softCommitMaxDocs < hardCommitMaxDocs; // remainder of test designed with these assumptions\n    \n    CommitTracker hardTracker = updater.commitTracker;\n    CommitTracker softTracker = updater.softCommitTracker;\n    \n    // wait out any leaked commits\n    monitor.hard.poll(3000, MILLISECONDS);\n    monitor.soft.poll(0, MILLISECONDS);\n    monitor.clear();\n    \n    softTracker.setDocsUpperBound(softCommitMaxDocs);\n    softTracker.setTimeUpperBound(-1);\n    hardTracker.setDocsUpperBound(hardCommitMaxDocs);\n    hardTracker.setTimeUpperBound(-1);\n    // simplify whats going on by only having soft auto commits trigger new searchers\n    hardTracker.setOpenSearcher(false);\n\n    // Note: doc id counting starts at 0, see comment at start of test regarding \"upper bound\"\n\n    // add num docs up to the soft commit upper bound\n    for (int i = 0; i < softCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first soft commit we see must be after this.\n    final long minSoftCommitNanos = System.nanoTime();\n    \n    // now add the doc that will trigger the soft commit,\n    // as well as additional docs up to the hard commit upper bound\n    for (int i = softCommitMaxDocs; i < hardCommitMaxDocs; i++) {\n      assertU(adoc(\"id\", \"\"+(8000 + i), \"subject\", \"testMaxDocs\"));\n    }\n    // the first hard commit we see must be after this.\n    final long minHardCommitNanos = System.nanoTime();\n\n    // a final doc to trigger the hard commit\n    assertU(adoc(\"id\", \"\"+(8000 + hardCommitMaxDocs), \"subject\", \"testMaxDocs\"));\n\n    // now poll our monitors for the timestamps on the first commits\n    final Long firstSoftNanos = monitor.soft.poll(5000, MILLISECONDS);\n    final Long firstHardNanos = monitor.hard.poll(5000, MILLISECONDS);\n\n    assertNotNull(\"didn't get a single softCommit after adding the max docs\", firstSoftNanos);\n    assertNotNull(\"didn't get a single hardCommit after adding the max docs\", firstHardNanos);\n                  \n    assertTrue(\"softCommit @ \" + firstSoftNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minSoftCommitNanos + \"ns\",\n               minSoftCommitNanos < firstSoftNanos);\n    assertTrue(\"hardCommit @ \" + firstHardNanos + \"ns is before the maxDocs should have triggered it @ \" +\n               minHardCommitNanos + \"ns\",\n               minHardCommitNanos < firstHardNanos);\n\n    final Long firstSearcherNanos = monitor.searcher.poll(5000, MILLISECONDS);\n    assertNotNull(\"didn't get a single new searcher\", firstSearcherNanos);\n    for (int i = 0; i <= softCommitMaxDocs; i++) {\n      assertQ(\"should find one\", req(\"id:\"+(8000 + i)) ,\"//result[@numFound=1]\" );\n    }\n\n    // wait a bit, w/o other action we shouldn't see any new hard/soft commits \n    assertNull(\"Got a hard commit we weren't expecting\",\n               monitor.hard.poll(1000, MILLISECONDS));\n    assertNull(\"Got a soft commit we weren't expecting\",\n               monitor.soft.poll(0, MILLISECONDS));\n    \n    monitor.assertSaneOffers();\n    monitor.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa","8b67953ff80d8ef5d119fd6c3782f2552cf8e60c"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"8b67953ff80d8ef5d119fd6c3782f2552cf8e60c":["c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"c5b34be7e619e79554fd42a87d0a6d5f01e4cbfa":["b21283ed01203901a7257aa4b7f0a0899c86e56e","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","8b67953ff80d8ef5d119fd6c3782f2552cf8e60c"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"8b67953ff80d8ef5d119fd6c3782f2552cf8e60c":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}