{"path":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    char c = 0;\n    if (position < utf16.length) {\n      c = utf16.result[position];\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c == '\\uFFFF')\n        return false;\n      else\n        c++;\n    }\n\n    utf16.setLength(position);\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        char nextChar = (char) Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        utf16.setLength(utf16.length + 1);\n        utf16.result[utf16.length - 1] = nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = utf16.length;\n          }\n          // append the minimum transition\n          utf16.setLength(utf16.length + 1);\n          utf16.result[utf16.length - 1] = transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF16(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (compareToUTF16(transition.getMax(), c) >= 0) {\n        int nextChar = compareToUTF16(c, transition.getMin()) > 0 ? c : transition.getMin();\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    char c = 0;\n    if (position < utf16.length) {\n      c = utf16.result[position];\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c == '\\uFFFF')\n        return false;\n      else\n        c++;\n    }\n\n    utf16.setLength(position);\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        char nextChar = (char) Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        utf16.setLength(utf16.length + 1);\n        utf16.result[utf16.length - 1] = nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = utf16.length;\n          }\n          // append the minimum transition\n          utf16.setLength(utf16.length + 1);\n          utf16.result[utf16.length - 1] = transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF8(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF16(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (compareToUTF16(transition.getMax(), c) >= 0) {\n        int nextChar = compareToUTF16(c, transition.getMin()) > 0 ? c : transition.getMin();\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF8(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF16(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (compareToUTF16(transition.getMax(), c) >= 0) {\n        int nextChar = compareToUTF16(c, transition.getMin()) > 0 ? c : transition.getMin();\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"780a676adba1080a3bb08ca427a08ff996227ecd","date":1285561731,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF8(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next character is U+FFFF and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      c = incrementUTF8(c);\n      if (c == -1)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","date":1297092846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            linear = true;\n            infinitePosition = seekBytesRef.length;\n          }\n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString(int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString(int,int).mjava","sourceNew":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns the next String in lexicographic order that will not put\n   * the machine into a reject state. \n   * \n   * This method traverses the DFA from the given position in the String,\n   * starting at the given state.\n   * \n   * If this cannot satisfy the machine, returns false. This method will\n   * walk the minimal path, in lexicographic order, as long as possible.\n   * \n   * If this method returns false, then there might still be more solutions,\n   * it is necessary to backtrack to find out.\n   * \n   * @param state current non-reject state\n   * @param position useful portion of the string\n   * @return true if more possible solutions exist for the DFA from this\n   *         position\n   */\n  private boolean nextString(int state, int position) {\n    /* \n     * the next lexicographic character must be greater than the existing\n     * character, if it exists.\n     */\n    int c = 0;\n    if (position < seekBytesRef.length) {\n      c = seekBytesRef.bytes[position] & 0xff;\n      // if the next byte is 0xff and is not part of the useful portion,\n      // then by definition it puts us in a reject state, and therefore this\n      // path is dead. there cannot be any higher transitions. backtrack.\n      if (c++ == 0xff)\n        return false;\n    }\n\n    seekBytesRef.length = position;\n    visited[state] = curGen;\n\n    Transition transitions[] = allTransitions[state];\n\n    // find the minimal path (lexicographic order) that is >= c\n    \n    for (int i = 0; i < transitions.length; i++) {\n      Transition transition = transitions[i];\n      if (transition.getMax() >= c) {\n        int nextChar = Math.max(c, transition.getMin());\n        // append either the next sequential char, or the minimum transition\n        seekBytesRef.grow(seekBytesRef.length + 1);\n        seekBytesRef.length++;\n        seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) nextChar;\n        state = transition.getDest().getNumber();\n        /* \n         * as long as is possible, continue down the minimal path in\n         * lexicographic order. if a loop or accept state is encountered, stop.\n         */\n        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {\n          visited[state] = curGen;\n          /* \n           * Note: we work with a DFA with no transitions to dead states.\n           * so the below is ok, if it is not an accept state,\n           * then there MUST be at least one transition.\n           */\n          transition = allTransitions[state][0];\n          state = transition.getDest().getNumber();\n          \n          // append the minimum transition\n          seekBytesRef.grow(seekBytesRef.length + 1);\n          seekBytesRef.length++;\n          seekBytesRef.bytes[seekBytesRef.length - 1] = (byte) transition.getMin();\n          \n          // we found a loop, record it for faster enumeration\n          if (!finite && !linear && visited[state] == curGen) {\n            setLinear(seekBytesRef.length-1);\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"08932c793647a36953d1816b1060121f48820d3f":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["780a676adba1080a3bb08ca427a08ff996227ecd"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["780a676adba1080a3bb08ca427a08ff996227ecd","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","08932c793647a36953d1816b1060121f48820d3f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","780a676adba1080a3bb08ca427a08ff996227ecd"],"780a676adba1080a3bb08ca427a08ff996227ecd":["08932c793647a36953d1816b1060121f48820d3f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60ba444201d2570214b6fcf1d15600dc1a01f548"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08932c793647a36953d1816b1060121f48820d3f":["5f4e87790277826a2aea119328600dfb07761f32","780a676adba1080a3bb08ca427a08ff996227ecd"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["60ba444201d2570214b6fcf1d15600dc1a01f548","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["08932c793647a36953d1816b1060121f48820d3f","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"780a676adba1080a3bb08ca427a08ff996227ecd":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","29ef99d61cda9641b6250bf9567329a6e65f901d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}