{"path":"solr/core/src/test/org/apache/solr/handler/TestBlobHandler#checkBlobPost(String,CloudSolrClient).mjava","commits":[{"id":"a44383d1bc1b3dfe9db7b05ecda8951270911aab","date":1486011386,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestBlobHandler#checkBlobPost(String,CloudSolrClient).mjava","pathOld":"/dev/null","sourceNew":"  static void checkBlobPost(String baseUrl, CloudSolrClient cloudClient) throws Exception {\n    String url;\n    Map map;\n    byte[] bytarr = new byte[1024];\n    for (int i = 0; i < bytarr.length; i++) bytarr[i] = (byte) (i % 127);\n    byte[] bytarr2 = new byte[2048];\n    for (int i = 0; i < bytarr2.length; i++) bytarr2[i] = (byte) (i % 127);\n    String blobName = \"test\";\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr), 1);\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr2), 2);\n\n    url = baseUrl + \"/.system/blob/test/1\";\n    map = TestSolrConfigHandlerConcurrent.getAsMap(url, cloudClient);\n    List l = (List) Utils.getObjectByPath(map, false, Arrays.asList(\"response\", \"docs\"));\n    assertNotNull(\"\" + map, l);\n    assertTrue(\"\" + map, l.size() > 0);\n    map = (Map) l.get(0);\n    assertEquals(\"\" + bytarr.length, String.valueOf(map.get(\"size\")));\n\n    compareInputAndOutput(baseUrl + \"/.system/blob/test?wt=filestream\", bytarr2, cloudClient);\n    compareInputAndOutput(baseUrl + \"/.system/blob/test/1?wt=filestream\", bytarr, cloudClient);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c9780b447ddf847479e7fa9978cb7809a15a0bf","date":1538692320,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestBlobHandler#checkBlobPost(String,CloudSolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestBlobHandler#checkBlobPost(String,CloudSolrClient).mjava","sourceNew":"  static void checkBlobPost(String baseUrl, CloudSolrClient cloudClient) throws Exception {\n    String url;\n    MapWriter map;\n    byte[] bytarr = new byte[1024];\n    for (int i = 0; i < bytarr.length; i++) bytarr[i] = (byte) (i % 127);\n    byte[] bytarr2 = new byte[2048];\n    for (int i = 0; i < bytarr2.length; i++) bytarr2[i] = (byte) (i % 127);\n    String blobName = \"test\";\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr), 1);\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr2), 2);\n\n    url = baseUrl + \"/.system/blob/test/1\";\n    map = TestSolrConfigHandlerConcurrent.getAsMap(url, cloudClient);\n    assertEquals(\"\" + bytarr.length, map._getStr(\"response/docs[0]/size\",null));\n\n    compareInputAndOutput(baseUrl + \"/.system/blob/test?wt=filestream\", bytarr2, cloudClient);\n    compareInputAndOutput(baseUrl + \"/.system/blob/test/1?wt=filestream\", bytarr, cloudClient);\n  }\n\n","sourceOld":"  static void checkBlobPost(String baseUrl, CloudSolrClient cloudClient) throws Exception {\n    String url;\n    Map map;\n    byte[] bytarr = new byte[1024];\n    for (int i = 0; i < bytarr.length; i++) bytarr[i] = (byte) (i % 127);\n    byte[] bytarr2 = new byte[2048];\n    for (int i = 0; i < bytarr2.length; i++) bytarr2[i] = (byte) (i % 127);\n    String blobName = \"test\";\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr), 1);\n    postAndCheck(cloudClient, baseUrl, blobName, ByteBuffer.wrap(bytarr2), 2);\n\n    url = baseUrl + \"/.system/blob/test/1\";\n    map = TestSolrConfigHandlerConcurrent.getAsMap(url, cloudClient);\n    List l = (List) Utils.getObjectByPath(map, false, Arrays.asList(\"response\", \"docs\"));\n    assertNotNull(\"\" + map, l);\n    assertTrue(\"\" + map, l.size() > 0);\n    map = (Map) l.get(0);\n    assertEquals(\"\" + bytarr.length, String.valueOf(map.get(\"size\")));\n\n    compareInputAndOutput(baseUrl + \"/.system/blob/test?wt=filestream\", bytarr2, cloudClient);\n    compareInputAndOutput(baseUrl + \"/.system/blob/test/1?wt=filestream\", bytarr, cloudClient);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a44383d1bc1b3dfe9db7b05ecda8951270911aab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c9780b447ddf847479e7fa9978cb7809a15a0bf":["a44383d1bc1b3dfe9db7b05ecda8951270911aab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9c9780b447ddf847479e7fa9978cb7809a15a0bf"]},"commit2Childs":{"a44383d1bc1b3dfe9db7b05ecda8951270911aab":["9c9780b447ddf847479e7fa9978cb7809a15a0bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a44383d1bc1b3dfe9db7b05ecda8951270911aab"],"9c9780b447ddf847479e7fa9978cb7809a15a0bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}