{"path":"lucene/contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36f91bf9cfc9d0c3155edab43359e7670ea8a5af","date":1269580873,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"36f91bf9cfc9d0c3155edab43359e7670ea8a5af":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["36f91bf9cfc9d0c3155edab43359e7670ea8a5af"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"36f91bf9cfc9d0c3155edab43359e7670ea8a5af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["36f91bf9cfc9d0c3155edab43359e7670ea8a5af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}