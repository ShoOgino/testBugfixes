{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", reader.hasNorms(\"f1\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", reader.hasNorms(\"f2\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", reader.hasNorms(\"f1\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", reader.hasNorms(\"f2\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46818a810eab72123f0e37e6ec5f2d426bd47be1","date":1331482161,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", reader.hasNorms(\"f1\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", reader.hasNorms(\"f2\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", reader.hasNorms(\"f1\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", reader.hasNorms(\"f2\"));\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76923f6a33f2c4bec7f584e3f251261afe7ea276","date":1337149711,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").indexOptions);\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").indexOptions);\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(IndexReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_UNSTORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_UNSTORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    _TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.shutdown();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.shutdown();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.shutdown();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.shutdown();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS_ONLY);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS_ONLY, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter#testLUCENE_1590().mjava","sourceNew":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    LeafReader reader = getOnlyLeafReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","sourceOld":"  /**\n   * Test adding two fields with the same name, one indexed\n   * the other stored only. The omitNorms and omitTermFreqAndPositions setting\n   * of the stored field should not affect the indexed one (LUCENE-1590)\n   */\n  public void testLUCENE_1590() throws Exception {\n    Document doc = new Document();\n    // f1 has no norms\n    FieldType customType = new FieldType(TextField.TYPE_NOT_STORED);\n    customType.setOmitNorms(true);\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    doc.add(newField(\"f1\", \"v1\", customType));\n    doc.add(newField(\"f1\", \"v2\", customType2));\n    // f2 has no TF\n    FieldType customType3 = new FieldType(TextField.TYPE_NOT_STORED);\n    customType3.setIndexOptions(IndexOptions.DOCS);\n    Field f = newField(\"f2\", \"v1\", customType3);\n    doc.add(f);\n    doc.add(newField(\"f2\", \"v2\", customType2));\n\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n    writer.addDocument(doc);\n    writer.forceMerge(1); // be sure to have a single segment\n    writer.close();\n\n    TestUtil.checkIndex(dir);\n\n    SegmentReader reader = getOnlySegmentReader(DirectoryReader.open(dir));\n    FieldInfos fi = reader.getFieldInfos();\n    // f1\n    assertFalse(\"f1 should have no norms\", fi.fieldInfo(\"f1\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should not be set for f1\", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo(\"f1\").getIndexOptions());\n    // f2\n    assertTrue(\"f2 should have norms\", fi.fieldInfo(\"f2\").hasNorms());\n    assertEquals(\"omitTermFreqAndPositions field bit should be set for f2\", IndexOptions.DOCS, fi.fieldInfo(\"f2\").getIndexOptions());\n    reader.close();\n  }\n\n","bugFix":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","46818a810eab72123f0e37e6ec5f2d426bd47be1"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","76923f6a33f2c4bec7f584e3f251261afe7ea276"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"46818a810eab72123f0e37e6ec5f2d426bd47be1":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["46818a810eab72123f0e37e6ec5f2d426bd47be1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","46818a810eab72123f0e37e6ec5f2d426bd47be1"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["6613659748fe4411a7dcf85266e55db1f95f7315"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"46818a810eab72123f0e37e6ec5f2d426bd47be1":["38e3b736c7ca086d61b7dbb841c905ee115490da","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["76923f6a33f2c4bec7f584e3f251261afe7ea276","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}