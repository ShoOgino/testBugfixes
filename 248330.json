{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","commits":[{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(CategoryPath).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(CategoryPath cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe9946d3cd818d329255e4c325597ac3480503e","date":1385580921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(cp.toString(delimiter)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    PostingsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    DocsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    PostingsEnum docs = MultiFields.getTermDocsEnum(indexReader, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    PostingsEnum docs = MultiFields.getTermDocsEnum(indexReader, null, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader#getOrdinal(FacetLabel).mjava","sourceNew":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    PostingsEnum docs = MultiTerms.getTermPostingsEnum(indexReader, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","sourceOld":"  @Override\n  public int getOrdinal(FacetLabel cp) throws IOException {\n    ensureOpen();\n    if (cp.length == 0) {\n      return ROOT_ORDINAL;\n    }\n\n    // First try to find the answer in the LRU cache:\n    synchronized (ordinalCache) {\n      Integer res = ordinalCache.get(cp);\n      if (res != null) {\n        if (res.intValue() < indexReader.maxDoc()) {\n          // Since the cache is shared with DTR instances allocated from\n          // doOpenIfChanged, we need to ensure that the ordinal is one that\n          // this DTR instance recognizes.\n          return res.intValue();\n        } else {\n          // if we get here, it means that the category was found in the cache,\n          // but is not recognized by this TR instance. Therefore there's no\n          // need to continue search for the path on disk, because we won't find\n          // it there too.\n          return TaxonomyReader.INVALID_ORDINAL;\n        }\n      }\n    }\n\n    // If we're still here, we have a cache miss. We need to fetch the\n    // value from disk, and then also put it in the cache:\n    int ret = TaxonomyReader.INVALID_ORDINAL;\n    PostingsEnum docs = MultiFields.getTermDocsEnum(indexReader, Consts.FULL, new BytesRef(FacetsConfig.pathToString(cp.components, cp.length)), 0);\n    if (docs != null && docs.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n      ret = docs.docID();\n      \n      // we only store the fact that a category exists, not its inexistence.\n      // This is required because the caches are shared with new DTR instances\n      // that are allocated from doOpenIfChanged. Therefore, if we only store\n      // information about found categories, we cannot accidently tell a new\n      // generation of DTR that a category does not exist.\n      synchronized (ordinalCache) {\n        ordinalCache.put(cp, Integer.valueOf(ret));\n      }\n    }\n\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["51f5280f31484820499077f41fcdfe92d527d9dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bbe9946d3cd818d329255e4c325597ac3480503e"],"51f5280f31484820499077f41fcdfe92d527d9dc":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"bbe9946d3cd818d329255e4c325597ac3480503e":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["51f5280f31484820499077f41fcdfe92d527d9dc"],"51f5280f31484820499077f41fcdfe92d527d9dc":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"bbe9946d3cd818d329255e4c325597ac3480503e":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["bbe9946d3cd818d329255e4c325597ac3480503e"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}