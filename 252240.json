{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillDownQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n    return query;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n\n    List<Filter> filters = new ArrayList<Filter>();\n    List<Query> queries = new ArrayList<Query>();\n    List<BooleanClause> clauses = query.clauses();\n    Query baseQuery;\n    int startIndex;\n    if (drillDownDims.size() == query.clauses().size()) {\n      baseQuery = new MatchAllDocsQuery();\n      startIndex = 0;\n    } else {\n      baseQuery = clauses.get(0).getQuery();\n      startIndex = 1;\n    }\n\n    for(int i=startIndex;i<clauses.size();i++) {\n      BooleanClause clause = clauses.get(i);\n      Query queryClause = clause.getQuery();\n      Filter filter = getFilter(queryClause);\n      if (filter != null) {\n        filters.add(filter);\n      } else {\n        queries.add(queryClause);\n      }\n    }\n\n    if (filters.isEmpty()) {\n      return query;\n    } else {\n      // Wrap all filters using FilteredQuery\n      \n      // TODO: this is hackish; we need to do it because\n      // BooleanQuery can't be trusted to handle the\n      // \"expensive filter\" case.  Really, each Filter should\n      // know its cost and we should take that more\n      // carefully into account when picking the right\n      // strategy/optimization:\n      Query wrapped;\n      if (queries.isEmpty()) {\n        wrapped = baseQuery;\n      } else {\n        // disable coord\n        BooleanQuery wrappedBQ = new BooleanQuery(true);\n        if ((baseQuery instanceof MatchAllDocsQuery) == false) {\n          wrappedBQ.add(baseQuery, BooleanClause.Occur.MUST);\n        }\n        for(Query q : queries) {\n          wrappedBQ.add(q, BooleanClause.Occur.MUST);\n        }\n        wrapped = wrappedBQ;\n      }\n\n      for(Filter filter : filters) {\n        wrapped = new FilteredQuery(wrapped, filter, FilteredQuery.QUERY_FIRST_FILTER_STRATEGY);\n      }\n\n      return wrapped;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n\n    List<Filter> filters = new ArrayList<>();\n    List<Query> queries = new ArrayList<>();\n    List<BooleanClause> clauses = query.clauses();\n    Query baseQuery;\n    int startIndex;\n    if (drillDownDims.size() == query.clauses().size()) {\n      baseQuery = new MatchAllDocsQuery();\n      startIndex = 0;\n    } else {\n      baseQuery = clauses.get(0).getQuery();\n      startIndex = 1;\n    }\n\n    for(int i=startIndex;i<clauses.size();i++) {\n      BooleanClause clause = clauses.get(i);\n      Query queryClause = clause.getQuery();\n      Filter filter = getFilter(queryClause);\n      if (filter != null) {\n        filters.add(filter);\n      } else {\n        queries.add(queryClause);\n      }\n    }\n\n    if (filters.isEmpty()) {\n      return query;\n    } else {\n      // Wrap all filters using FilteredQuery\n      \n      // TODO: this is hackish; we need to do it because\n      // BooleanQuery can't be trusted to handle the\n      // \"expensive filter\" case.  Really, each Filter should\n      // know its cost and we should take that more\n      // carefully into account when picking the right\n      // strategy/optimization:\n      Query wrapped;\n      if (queries.isEmpty()) {\n        wrapped = baseQuery;\n      } else {\n        // disable coord\n        BooleanQuery wrappedBQ = new BooleanQuery(true);\n        if ((baseQuery instanceof MatchAllDocsQuery) == false) {\n          wrappedBQ.add(baseQuery, BooleanClause.Occur.MUST);\n        }\n        for(Query q : queries) {\n          wrappedBQ.add(q, BooleanClause.Occur.MUST);\n        }\n        wrapped = wrappedBQ;\n      }\n\n      for(Filter filter : filters) {\n        wrapped = new FilteredQuery(wrapped, filter, FilteredQuery.QUERY_FIRST_FILTER_STRATEGY);\n      }\n\n      return wrapped;\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n\n    List<Filter> filters = new ArrayList<Filter>();\n    List<Query> queries = new ArrayList<Query>();\n    List<BooleanClause> clauses = query.clauses();\n    Query baseQuery;\n    int startIndex;\n    if (drillDownDims.size() == query.clauses().size()) {\n      baseQuery = new MatchAllDocsQuery();\n      startIndex = 0;\n    } else {\n      baseQuery = clauses.get(0).getQuery();\n      startIndex = 1;\n    }\n\n    for(int i=startIndex;i<clauses.size();i++) {\n      BooleanClause clause = clauses.get(i);\n      Query queryClause = clause.getQuery();\n      Filter filter = getFilter(queryClause);\n      if (filter != null) {\n        filters.add(filter);\n      } else {\n        queries.add(queryClause);\n      }\n    }\n\n    if (filters.isEmpty()) {\n      return query;\n    } else {\n      // Wrap all filters using FilteredQuery\n      \n      // TODO: this is hackish; we need to do it because\n      // BooleanQuery can't be trusted to handle the\n      // \"expensive filter\" case.  Really, each Filter should\n      // know its cost and we should take that more\n      // carefully into account when picking the right\n      // strategy/optimization:\n      Query wrapped;\n      if (queries.isEmpty()) {\n        wrapped = baseQuery;\n      } else {\n        // disable coord\n        BooleanQuery wrappedBQ = new BooleanQuery(true);\n        if ((baseQuery instanceof MatchAllDocsQuery) == false) {\n          wrappedBQ.add(baseQuery, BooleanClause.Occur.MUST);\n        }\n        for(Query q : queries) {\n          wrappedBQ.add(q, BooleanClause.Occur.MUST);\n        }\n        wrapped = wrappedBQ;\n      }\n\n      for(Filter filter : filters) {\n        wrapped = new FilteredQuery(wrapped, filter, FilteredQuery.QUERY_FIRST_FILTER_STRATEGY);\n      }\n\n      return wrapped;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillDownQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    BooleanQuery rewritten = getBooleanQuery();\n    if (rewritten.clauses().isEmpty()) {\n      return new MatchAllDocsQuery();\n    }\n    return rewritten;\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader r) throws IOException {\n    if (query.clauses().size() == 0) {\n      return new MatchAllDocsQuery();\n    }\n\n    List<Filter> filters = new ArrayList<>();\n    List<Query> queries = new ArrayList<>();\n    List<BooleanClause> clauses = query.clauses();\n    Query baseQuery;\n    int startIndex;\n    if (drillDownDims.size() == query.clauses().size()) {\n      baseQuery = new MatchAllDocsQuery();\n      startIndex = 0;\n    } else {\n      baseQuery = clauses.get(0).getQuery();\n      startIndex = 1;\n    }\n\n    for(int i=startIndex;i<clauses.size();i++) {\n      BooleanClause clause = clauses.get(i);\n      Query queryClause = clause.getQuery();\n      Filter filter = getFilter(queryClause);\n      if (filter != null) {\n        filters.add(filter);\n      } else {\n        queries.add(queryClause);\n      }\n    }\n\n    if (filters.isEmpty()) {\n      return query;\n    } else {\n      // Wrap all filters using FilteredQuery\n      \n      // TODO: this is hackish; we need to do it because\n      // BooleanQuery can't be trusted to handle the\n      // \"expensive filter\" case.  Really, each Filter should\n      // know its cost and we should take that more\n      // carefully into account when picking the right\n      // strategy/optimization:\n      Query wrapped;\n      if (queries.isEmpty()) {\n        wrapped = baseQuery;\n      } else {\n        // disable coord\n        BooleanQuery wrappedBQ = new BooleanQuery(true);\n        if ((baseQuery instanceof MatchAllDocsQuery) == false) {\n          wrappedBQ.add(baseQuery, BooleanClause.Occur.MUST);\n        }\n        for(Query q : queries) {\n          wrappedBQ.add(q, BooleanClause.Occur.MUST);\n        }\n        wrapped = wrappedBQ;\n      }\n\n      for(Filter filter : filters) {\n        wrapped = new FilteredQuery(wrapped, filter, FilteredQuery.QUERY_FIRST_FILTER_STRATEGY);\n      }\n\n      return wrapped;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["40640359164f629dd440a47df2e145d084ce9645"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","21d36d0db865f7b84026b447bec653469a6e66df"],"40640359164f629dd440a47df2e145d084ce9645":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"21d36d0db865f7b84026b447bec653469a6e66df":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["40640359164f629dd440a47df2e145d084ce9645"],"40640359164f629dd440a47df2e145d084ce9645":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}