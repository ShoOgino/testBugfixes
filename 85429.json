{"path":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","commits":[{"id":"3b7a068f550e13e49517c6899cc3b94c8eeb72e5","date":1309354772,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"/dev/null","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\");\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\");\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"/dev/null","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\");\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\");\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"/dev/null","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\");\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\");\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\");\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\");\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copyChars(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copyChars(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copy(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copy(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5090f41e198d9dd9374e99981f940b111973af2","date":1325969785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copyChars(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copyChars(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (EOFException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copyChars(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copyChars(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (IOException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestByteBlockPool#testCopyRefAndWrite().mjava","sourceNew":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copyChars(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copyChars(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (EOFException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testCopyRefAndWrite() throws IOException {\n    List<String> list = new ArrayList<String>();\n    int maxLength = atLeast(500);\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectAllocator());\n    pool.nextBuffer();\n    final int numValues = atLeast(100);\n    BytesRef ref = new BytesRef();\n    for (int i = 0; i < numValues; i++) {\n      final String value = _TestUtil.randomRealisticUnicodeString(random,\n          maxLength);\n      list.add(value);\n      ref.copyChars(value);\n      pool.copy(ref);\n    }\n    RAMDirectory dir = new RAMDirectory();\n    IndexOutput stream = dir.createOutput(\"foo.txt\", newIOContext(random));\n    pool.writePool(stream);\n    stream.flush();\n    stream.close();\n    IndexInput input = dir.openInput(\"foo.txt\", newIOContext(random));\n    assertEquals(pool.byteOffset + pool.byteUpto, stream.length());\n    BytesRef expected = new BytesRef();\n    BytesRef actual = new BytesRef();\n    for (String string : list) {\n      expected.copyChars(string);\n      actual.grow(expected.length);\n      actual.length = expected.length;\n      input.readBytes(actual.bytes, 0, actual.length);\n      assertEquals(expected, actual);\n    }\n    try {\n      input.readByte();\n      fail(\"must be EOF\");\n    } catch (EOFException e) {\n      // expected - read past EOF\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e5090f41e198d9dd9374e99981f940b111973af2"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["817d8435e9135b756f08ce6710ab0baac51bdf88","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["3b7a068f550e13e49517c6899cc3b94c8eeb72e5","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"e5090f41e198d9dd9374e99981f940b111973af2":["e6e919043fa85ee891123768dd655a98edbbf63c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"e6e919043fa85ee891123768dd655a98edbbf63c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["ddc4c914be86e34b54f70023f45a60fa7f04e929","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b7a068f550e13e49517c6899cc3b94c8eeb72e5","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","e6e919043fa85ee891123768dd655a98edbbf63c"],"e5090f41e198d9dd9374e99981f940b111973af2":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"e6e919043fa85ee891123768dd655a98edbbf63c":["e5090f41e198d9dd9374e99981f940b111973af2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}