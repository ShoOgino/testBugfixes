{"path":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","commits":[{"id":"3e21d7642ee7e0c00429964e5b47504602fe218c","date":1460897579,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8cb57c50beb99a1245256e866350af8e5ea1f36","date":1460921840,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10005c6013abbd1102f2463cf95604d4c8774c99","date":1469460814,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0567940defa1ea6eb8a039d9d36e3682063f8a4","date":1469815320,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"084884d4602f4d1c7411eab29e897e349ce62675","date":1475571034,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene70\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1967bed916cc89da82a1c2085f27976da6d08cbd","date":1475588750,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene70\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene62\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene70\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene60\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6930fc653c2b86e857fce0af7ec99993593d0d89","date":1535014305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene80\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene70\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a0cc86697753659ac5e7f55243ccdcbf44d8a36","date":1574100512,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene84\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene80\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773bf150032d3ef6c95997a154fb914b82875cb8","date":1590150786,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene86\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene84\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene86\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene86PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene86PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene86\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene60PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene60PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db8230c9dbe474fc18e1e71cf04c1ada8046ec9","date":1598432674,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#doRandomDistanceTest(int,int).mjava","sourceNew":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    final Codec in = TestUtil.getDefaultCodec();\n    iwc.setCodec(new FilterCodec(in.getName(), in) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene86PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene86PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void doRandomDistanceTest(int numDocs, int numQueries) throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    int pointsInLeaf = 2 + random().nextInt(4);\n    iwc.setCodec(new FilterCodec(\"Lucene86\", TestUtil.getDefaultCodec()) {\n      @Override\n      public PointsFormat pointsFormat() {\n        return new PointsFormat() {\n          @Override\n          public PointsWriter fieldsWriter(SegmentWriteState writeState) throws IOException {\n            return new Lucene86PointsWriter(writeState, pointsInLeaf, BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n          }\n  \n          @Override\n          public PointsReader fieldsReader(SegmentReadState readState) throws IOException {\n            return new Lucene86PointsReader(readState);\n          }\n        };\n      }\n    });\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n  \n    for (int i = 0; i < numDocs; i++) {\n      double latRaw = nextLatitude();\n      double lonRaw = nextLongitude();\n      // pre-normalize up front, so we can just use quantized value for testing and do simple exact comparisons\n      double lat = quantizeLat(latRaw);\n      double lon = quantizeLon(lonRaw);\n      Document doc = new Document();\n      addPointToDoc(\"field\", doc, lat, lon);\n      doc.add(new StoredField(\"lat\", lat));\n      doc.add(new StoredField(\"lon\", lon));\n      writer.addDocument(doc);\n    }\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n  \n    for (int i = 0; i < numQueries; i++) {\n      double lat = nextLatitude();\n      double lon = nextLongitude();\n      double radius = 50000000D * random().nextDouble();\n  \n      BitSet expected = new BitSet();\n      for (int doc = 0; doc < reader.maxDoc(); doc++) {\n        double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n        double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n        double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n        if (distance <= radius) {\n          expected.set(doc);\n        }\n      }\n  \n      TopDocs topDocs = searcher.search(newDistanceQuery(\"field\", lat, lon, radius), reader.maxDoc(), Sort.INDEXORDER);\n      BitSet actual = new BitSet();\n      for (ScoreDoc doc : topDocs.scoreDocs) {\n        actual.set(doc.doc);\n      }\n      \n      try {\n        assertEquals(expected, actual);\n      } catch (AssertionError e) {\n        System.out.println(\"center: (\" + lat + \",\" + lon + \"), radius=\" + radius);\n        for (int doc = 0; doc < reader.maxDoc(); doc++) {\n          double docLatitude = reader.document(doc).getField(\"lat\").numericValue().doubleValue();\n          double docLongitude = reader.document(doc).getField(\"lon\").numericValue().doubleValue();\n          double distance = SloppyMath.haversinMeters(lat, lon, docLatitude, docLongitude);\n          System.out.println(\"\" + doc + \": (\" + docLatitude + \",\" + docLongitude + \"), distance=\" + distance);\n        }\n        throw e;\n      }\n    }\n    reader.close();\n    writer.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"9a0cc86697753659ac5e7f55243ccdcbf44d8a36":["6930fc653c2b86e857fce0af7ec99993593d0d89"],"1967bed916cc89da82a1c2085f27976da6d08cbd":["b0567940defa1ea6eb8a039d9d36e3682063f8a4","084884d4602f4d1c7411eab29e897e349ce62675"],"6930fc653c2b86e857fce0af7ec99993593d0d89":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"0db8230c9dbe474fc18e1e71cf04c1ada8046ec9":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"0ad30c6a479e764150a3316e57263319775f1df2":["f8cb57c50beb99a1245256e866350af8e5ea1f36","3d33e731a93d4b57e662ff094f64f94a745422d4"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e21d7642ee7e0c00429964e5b47504602fe218c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f8cb57c50beb99a1245256e866350af8e5ea1f36","1967bed916cc89da82a1c2085f27976da6d08cbd"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["f8cb57c50beb99a1245256e866350af8e5ea1f36","0ad30c6a479e764150a3316e57263319775f1df2"],"084884d4602f4d1c7411eab29e897e349ce62675":["b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"773bf150032d3ef6c95997a154fb914b82875cb8":["9a0cc86697753659ac5e7f55243ccdcbf44d8a36"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["773bf150032d3ef6c95997a154fb914b82875cb8"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["f8cb57c50beb99a1245256e866350af8e5ea1f36","fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["d470c8182e92b264680e34081b75e70a9f2b3c89","10005c6013abbd1102f2463cf95604d4c8774c99"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d08973aa47f2cf98a588293a53af4e948952ccfb","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0db8230c9dbe474fc18e1e71cf04c1ada8046ec9"]},"commit2Childs":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["1967bed916cc89da82a1c2085f27976da6d08cbd","084884d4602f4d1c7411eab29e897e349ce62675","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"9a0cc86697753659ac5e7f55243ccdcbf44d8a36":["773bf150032d3ef6c95997a154fb914b82875cb8"],"1967bed916cc89da82a1c2085f27976da6d08cbd":["6930fc653c2b86e857fce0af7ec99993593d0d89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6930fc653c2b86e857fce0af7ec99993593d0d89":["9a0cc86697753659ac5e7f55243ccdcbf44d8a36"],"0db8230c9dbe474fc18e1e71cf04c1ada8046ec9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","3d33e731a93d4b57e662ff094f64f94a745422d4","fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"084884d4602f4d1c7411eab29e897e349ce62675":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["10005c6013abbd1102f2463cf95604d4c8774c99","d08973aa47f2cf98a588293a53af4e948952ccfb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f8cb57c50beb99a1245256e866350af8e5ea1f36","3e21d7642ee7e0c00429964e5b47504602fe218c"],"773bf150032d3ef6c95997a154fb914b82875cb8":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["0db8230c9dbe474fc18e1e71cf04c1ada8046ec9"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["b0567940defa1ea6eb8a039d9d36e3682063f8a4","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}