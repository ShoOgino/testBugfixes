{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(List[GeoPoint],int,double).mjava","commits":[{"id":"e6c11570003964f18df228c7d98cf81d29cff66b","date":1517404858,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(List[GeoPoint],int,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Iterative path search through ordered list of points. The method merges together\n   * all consecutive coplanar points and builds the plane using the first and the last point.\n   * It does not converge if the starting point is coplanar with the last and next point of the path.\n   *\n   * @param points is the ordered raw list of points under consideration.\n   * @param startIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @param leniencyValue is the allowed distance of a point from the plane to be considered coplanar.\n   * @return null if the starting point is coplanar with the last and next point of the path.\n   */\n  private static SafePath findSafePath(final List<GeoPoint> points, final int startIndex, final double leniencyValue) {\n    SafePath safePath = null;\n    for (int i = startIndex; i < startIndex + points.size(); i++) {\n      //get start point, always the same for an iteration\n      final int startPointIndex = getLegalIndex(i -1, points.size());\n      final GeoPoint startPoint = points.get(startPointIndex);\n      //get end point, can be coplanar and therefore change\n      int endPointIndex = getLegalIndex(i, points.size());\n      GeoPoint endPoint = points.get(endPointIndex);\n\n      if (startPoint.isNumericallyIdentical(endPoint)) {\n        //go to next if identical\n        continue;\n      }\n      //Check if nextPoints are co-planar, if so advance to next point.\n      //if we go over the start index then we have no succeed.\n      while (true) {\n        int nextPointIndex = getLegalIndex(endPointIndex + 1, points.size());\n        final GeoPoint nextPoint = points.get(nextPointIndex);\n        if (startPoint.isNumericallyIdentical(nextPoint)) {\n          //all coplanar\n          return null;\n        }\n        Plane nextPlane = new Plane(startPoint, nextPoint);\n        if (Math.abs(nextPlane.evaluate(endPoint)) > Vector.MINIMUM_RESOLUTION + leniencyValue) {\n          //no coplanar.\n          break;\n        }\n        if (endPointIndex == startIndex) {\n          //we are over the path, we fail.\n          return null;\n        }\n        //advance\n        endPointIndex = nextPointIndex;\n        endPoint = nextPoint;\n        i++;\n      }\n\n      if (safePath != null && endPointIndex == startIndex) {\n        //We are already at the start, current point is coplanar with\n        //start point, no need to add this node.\n        break;\n      }\n      //Create node and move to next one\n      Plane currentPlane = new Plane(startPoint, endPoint);\n      safePath = new SafePath(safePath, endPoint, endPointIndex, currentPlane);\n    }\n    return safePath;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8","date":1518267216,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(List[GeoPoint],int,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findSafePath(List[GeoPoint],int,double).mjava","sourceNew":"  /** Iterative path search through ordered list of points. The method merges together\n   * all consecutive coplanar points and builds the plane using the first and the last point.\n   * It does not converge if the starting point is coplanar with the last and next point of the path.\n   *\n   * @param points is the ordered raw list of points under consideration.\n   * @param startIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @param leniencyValue is the allowed distance of a point from the plane to be considered coplanar.\n   * @return null if the starting point is coplanar with the last and next point of the path.\n   */\n  private static SafePath findSafePath(final List<GeoPoint> points, final int startIndex, final double leniencyValue) {\n    SafePath safePath = null;\n    for (int i = startIndex; i < startIndex + points.size(); i++) {\n      //get start point, always the same for an iteration\n      final int startPointIndex = getLegalIndex(i -1, points.size());\n      final GeoPoint startPoint = points.get(startPointIndex);\n      //get end point, can be coplanar and therefore change\n      int endPointIndex = getLegalIndex(i, points.size());\n      GeoPoint endPoint = points.get(endPointIndex);\n\n      if (startPoint.isNumericallyIdentical(endPoint)) {\n        //go to next if identical\n        continue;\n      }\n      //Check if nextPoints are co-planar, if so advance to next point.\n      //if we go over the start index then we have no succeed.\n      while (true) {\n        int nextPointIndex = getLegalIndex(endPointIndex + 1, points.size());\n        final GeoPoint nextPoint = points.get(nextPointIndex);\n        if (startPoint.isNumericallyIdentical(nextPoint)) {\n          //all coplanar\n          return null;\n        }\n        if (!Plane.arePointsCoplanar(startPoint, endPoint, nextPoint)) {\n          //no coplanar.\n          break;\n        }\n        if (endPointIndex == startIndex) {\n          //we are over the path, we fail.\n          return null;\n        }\n        //advance\n        endPointIndex = nextPointIndex;\n        endPoint = nextPoint;\n        i++;\n      }\n\n      if (safePath != null && endPointIndex == startIndex) {\n        //We are already at the start, current point is coplanar with\n        //start point, no need to add this node.\n        break;\n      }\n      //Create node and move to next one\n      Plane currentPlane = new Plane(startPoint, endPoint);\n      safePath = new SafePath(safePath, endPoint, endPointIndex, currentPlane);\n    }\n    return safePath;\n  }\n\n","sourceOld":"  /** Iterative path search through ordered list of points. The method merges together\n   * all consecutive coplanar points and builds the plane using the first and the last point.\n   * It does not converge if the starting point is coplanar with the last and next point of the path.\n   *\n   * @param points is the ordered raw list of points under consideration.\n   * @param startIndex is index of the point that starts the current path, so that we can know when we are done.\n   * @param leniencyValue is the allowed distance of a point from the plane to be considered coplanar.\n   * @return null if the starting point is coplanar with the last and next point of the path.\n   */\n  private static SafePath findSafePath(final List<GeoPoint> points, final int startIndex, final double leniencyValue) {\n    SafePath safePath = null;\n    for (int i = startIndex; i < startIndex + points.size(); i++) {\n      //get start point, always the same for an iteration\n      final int startPointIndex = getLegalIndex(i -1, points.size());\n      final GeoPoint startPoint = points.get(startPointIndex);\n      //get end point, can be coplanar and therefore change\n      int endPointIndex = getLegalIndex(i, points.size());\n      GeoPoint endPoint = points.get(endPointIndex);\n\n      if (startPoint.isNumericallyIdentical(endPoint)) {\n        //go to next if identical\n        continue;\n      }\n      //Check if nextPoints are co-planar, if so advance to next point.\n      //if we go over the start index then we have no succeed.\n      while (true) {\n        int nextPointIndex = getLegalIndex(endPointIndex + 1, points.size());\n        final GeoPoint nextPoint = points.get(nextPointIndex);\n        if (startPoint.isNumericallyIdentical(nextPoint)) {\n          //all coplanar\n          return null;\n        }\n        Plane nextPlane = new Plane(startPoint, nextPoint);\n        if (Math.abs(nextPlane.evaluate(endPoint)) > Vector.MINIMUM_RESOLUTION + leniencyValue) {\n          //no coplanar.\n          break;\n        }\n        if (endPointIndex == startIndex) {\n          //we are over the path, we fail.\n          return null;\n        }\n        //advance\n        endPointIndex = nextPointIndex;\n        endPoint = nextPoint;\n        i++;\n      }\n\n      if (safePath != null && endPointIndex == startIndex) {\n        //We are already at the start, current point is coplanar with\n        //start point, no need to add this node.\n        break;\n      }\n      //Create node and move to next one\n      Plane currentPlane = new Plane(startPoint, endPoint);\n      safePath = new SafePath(safePath, endPoint, endPointIndex, currentPlane);\n    }\n    return safePath;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["e6c11570003964f18df228c7d98cf81d29cff66b"],"e6c11570003964f18df228c7d98cf81d29cff66b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"]},"commit2Childs":{"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e6c11570003964f18df228c7d98cf81d29cff66b":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e6c11570003964f18df228c7d98cf81d29cff66b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}