{"path":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/graph/DistanceCount#printDistance(String,String).mjava","commits":[{"id":"05d36e0b328ec96237035fbcca240e73631396e5","date":1020520725,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/graph/DistanceCount#printDistance(String,String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Description of the Method\n     *\n     * @param nodeFrom  Description of the Parameter\n     * @param nodeTo    Description of the Parameter\n     */\n    public void printDistance(String nodeFrom, String nodeTo)\n    {\n\n        Node firstNode = (Node) nodes.get(nodeFrom);\n        if (firstNode == null)\n        {\n            System.out.println(\"FROM node not found\");\n            return;\n        }\n        Node toNode = (Node) nodes.get(nodeTo);\n        if (toNode == null)\n        {\n            System.out.println(\"TO node not found\");\n            return;\n        }\n        //System.out.println(\"resetting node distance...\");\n        //clearDistances();\n\n        System.out.println(\"calculating...\");\n        calculateShortestDistance(firstNode);\n\n        //t1 = System.currentTimeMillis();\n        //System.out.println(\"\" + (t1-t2) + \" ms\");\n\n\n        System.out.println(\"\\nSorting...\");\n\n        /*\n         *  Collection nodeCollection = nodes.values();\n         *  Object[] nodeArray = nodeCollection.toArray();\n         *  Arrays.sort(nodeArray);\n         *  t2 = System.currentTimeMillis();\n         *  System.out.println(\"\" + (t2-t1) + \" ms\");\n         *  int from = 0;\n         *  int to = 1;\n         */\n        /*\n         *  /calculate page Rank\n         *  for(int i = 0; i< 1; i++)\n         *  {\n         *  from = i%2;\n         *  to = (i+1) % 2;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node act = (Node)nodeArray[j];\n         *  LinkedList inc = act.getIncoming();\n         *  float pageRank = 0;\n         *  Iterator it = inc.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  pageRank += t.getLinkRank(from);\n         *  }\n         *  act.setNodeRank(pageRank, to);\n         *  LinkedList out = act.getOutgoing();\n         *  int size = out.size();\n         *  if(size > 0)\n         *  {\n         *  float linkRank = pageRank / size;\n         *  it = out.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  t.setLinkRank(linkRank, to);\n         *  }\n         *  }\n         *  }\n         *  }\n         */\n        /*\n         *  System.out.println(\"\\nLink Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  Node.sortType = to;\n         *  Arrays.sort(nodeArray);\n         *  System.out.println(\"\\nPageRank Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  System.out.println(\"\\nStats...\");\n         *  float distanceAccumulated=0;\n         *  float distanceMax = 0;\n         *  int notCounted = 0;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node n = (Node)nodeArray[j];\n         *  if(n.distance != Integer.MAX_VALUE)\n         *  {\n         *  distanceAccumulated += n.distance;\n         *  distanceMax = Math.max(distanceMax, n.distance);\n         *  }\n         *  else\n         *  {\n         *  notCounted++;\n         *  }\n         *  }\n         *  System.out.println(\"Mean Distance:          \" + ((double)distanceAccumulated)/nodeArray.length);\n         *  System.out.println(\"Max Distance:           \" + (distanceMax));\n         *  System.out.println(\"Not reachable nodes(?): \" + notCounted);\n         *  System.out.println(\"Referer Median:         \" + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());\n         *  System.out.println(\"\\nSamples:\");\n         */\n\n        printShortestRoute(toNode, 0,0);\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21b526e3e9974b2651365fbae52a976e6fc77aa4","date":1022108962,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/graph/DistanceCount#printDistance(String,String).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/graph/DistanceCount#printDistance(String,String).mjava","sourceNew":"    /**\n     * Description of the Method\n     *\n     * @param nodeFrom  Description of the Parameter\n     * @param nodeTo    Description of the Parameter\n     */\n\n    public void printDistance(String nodeFrom, String nodeTo)\n    {\n\n        Node firstNode = (Node) nodes.get(nodeFrom);\n\n        if (firstNode == null)\n        {\n\n            System.out.println(\"FROM node not found\");\n\n            return;\n        }\n\n        Node toNode = (Node) nodes.get(nodeTo);\n\n        if (toNode == null)\n        {\n\n            System.out.println(\"TO node not found\");\n\n            return;\n        }\n\n        //System.out.println(\"resetting node distance...\");\n\n        //clearDistances();\n\n        System.out.println(\"calculating...\");\n\n        calculateShortestDistance(firstNode);\n\n        //t1 = System.currentTimeMillis();\n\n        //System.out.println(\"\" + (t1-t2) + \" ms\");\n\n\n        System.out.println(\"\\nSorting...\");\n\n        /*\n         *  Collection nodeCollection = nodes.values();\n         *  Object[] nodeArray = nodeCollection.toArray();\n         *  Arrays.sort(nodeArray);\n         *  t2 = System.currentTimeMillis();\n         *  System.out.println(\"\" + (t2-t1) + \" ms\");\n         *  int from = 0;\n         *  int to = 1;\n         */\n        /*\n         *  /calculate page Rank\n         *  for(int i = 0; i< 1; i++)\n         *  {\n         *  from = i%2;\n         *  to = (i+1) % 2;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node act = (Node)nodeArray[j];\n         *  LinkedList inc = act.getIncoming();\n         *  float pageRank = 0;\n         *  Iterator it = inc.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  pageRank += t.getLinkRank(from);\n         *  }\n         *  act.setNodeRank(pageRank, to);\n         *  LinkedList out = act.getOutgoing();\n         *  int size = out.size();\n         *  if(size > 0)\n         *  {\n         *  float linkRank = pageRank / size;\n         *  it = out.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  t.setLinkRank(linkRank, to);\n         *  }\n         *  }\n         *  }\n         *  }\n         */\n        /*\n         *  System.out.println(\"\\nLink Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  Node.sortType = to;\n         *  Arrays.sort(nodeArray);\n         *  System.out.println(\"\\nPageRank Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  System.out.println(\"\\nStats...\");\n         *  float distanceAccumulated=0;\n         *  float distanceMax = 0;\n         *  int notCounted = 0;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node n = (Node)nodeArray[j];\n         *  if(n.distance != Integer.MAX_VALUE)\n         *  {\n         *  distanceAccumulated += n.distance;\n         *  distanceMax = Math.max(distanceMax, n.distance);\n         *  }\n         *  else\n         *  {\n         *  notCounted++;\n         *  }\n         *  }\n         *  System.out.println(\"Mean Distance:          \" + ((double)distanceAccumulated)/nodeArray.length);\n         *  System.out.println(\"Max Distance:           \" + (distanceMax));\n         *  System.out.println(\"Not reachable nodes(?): \" + notCounted);\n         *  System.out.println(\"Referer Median:         \" + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());\n         *  System.out.println(\"\\nSamples:\");\n         */\n        printShortestRoute(toNode, 0, 0);\n\n    }\n\n","sourceOld":"    /**\n     * Description of the Method\n     *\n     * @param nodeFrom  Description of the Parameter\n     * @param nodeTo    Description of the Parameter\n     */\n    public void printDistance(String nodeFrom, String nodeTo)\n    {\n\n        Node firstNode = (Node) nodes.get(nodeFrom);\n        if (firstNode == null)\n        {\n            System.out.println(\"FROM node not found\");\n            return;\n        }\n        Node toNode = (Node) nodes.get(nodeTo);\n        if (toNode == null)\n        {\n            System.out.println(\"TO node not found\");\n            return;\n        }\n        //System.out.println(\"resetting node distance...\");\n        //clearDistances();\n\n        System.out.println(\"calculating...\");\n        calculateShortestDistance(firstNode);\n\n        //t1 = System.currentTimeMillis();\n        //System.out.println(\"\" + (t1-t2) + \" ms\");\n\n\n        System.out.println(\"\\nSorting...\");\n\n        /*\n         *  Collection nodeCollection = nodes.values();\n         *  Object[] nodeArray = nodeCollection.toArray();\n         *  Arrays.sort(nodeArray);\n         *  t2 = System.currentTimeMillis();\n         *  System.out.println(\"\" + (t2-t1) + \" ms\");\n         *  int from = 0;\n         *  int to = 1;\n         */\n        /*\n         *  /calculate page Rank\n         *  for(int i = 0; i< 1; i++)\n         *  {\n         *  from = i%2;\n         *  to = (i+1) % 2;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node act = (Node)nodeArray[j];\n         *  LinkedList inc = act.getIncoming();\n         *  float pageRank = 0;\n         *  Iterator it = inc.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  pageRank += t.getLinkRank(from);\n         *  }\n         *  act.setNodeRank(pageRank, to);\n         *  LinkedList out = act.getOutgoing();\n         *  int size = out.size();\n         *  if(size > 0)\n         *  {\n         *  float linkRank = pageRank / size;\n         *  it = out.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  t.setLinkRank(linkRank, to);\n         *  }\n         *  }\n         *  }\n         *  }\n         */\n        /*\n         *  System.out.println(\"\\nLink Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  Node.sortType = to;\n         *  Arrays.sort(nodeArray);\n         *  System.out.println(\"\\nPageRank Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  System.out.println(\"\\nStats...\");\n         *  float distanceAccumulated=0;\n         *  float distanceMax = 0;\n         *  int notCounted = 0;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node n = (Node)nodeArray[j];\n         *  if(n.distance != Integer.MAX_VALUE)\n         *  {\n         *  distanceAccumulated += n.distance;\n         *  distanceMax = Math.max(distanceMax, n.distance);\n         *  }\n         *  else\n         *  {\n         *  notCounted++;\n         *  }\n         *  }\n         *  System.out.println(\"Mean Distance:          \" + ((double)distanceAccumulated)/nodeArray.length);\n         *  System.out.println(\"Max Distance:           \" + (distanceMax));\n         *  System.out.println(\"Not reachable nodes(?): \" + notCounted);\n         *  System.out.println(\"Referer Median:         \" + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());\n         *  System.out.println(\"\\nSamples:\");\n         */\n\n        printShortestRoute(toNode, 0,0);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/graph/DistanceCount#printDistance(String,String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Description of the Method\n     *\n     * @param nodeFrom  Description of the Parameter\n     * @param nodeTo    Description of the Parameter\n     */\n\n    public void printDistance(String nodeFrom, String nodeTo)\n    {\n\n        Node firstNode = (Node) nodes.get(nodeFrom);\n\n        if (firstNode == null)\n        {\n\n            System.out.println(\"FROM node not found\");\n\n            return;\n        }\n\n        Node toNode = (Node) nodes.get(nodeTo);\n\n        if (toNode == null)\n        {\n\n            System.out.println(\"TO node not found\");\n\n            return;\n        }\n\n        //System.out.println(\"resetting node distance...\");\n\n        //clearDistances();\n\n        System.out.println(\"calculating...\");\n\n        calculateShortestDistance(firstNode);\n\n        //t1 = System.currentTimeMillis();\n\n        //System.out.println(\"\" + (t1-t2) + \" ms\");\n\n\n        System.out.println(\"\\nSorting...\");\n\n        /*\n         *  Collection nodeCollection = nodes.values();\n         *  Object[] nodeArray = nodeCollection.toArray();\n         *  Arrays.sort(nodeArray);\n         *  t2 = System.currentTimeMillis();\n         *  System.out.println(\"\" + (t2-t1) + \" ms\");\n         *  int from = 0;\n         *  int to = 1;\n         */\n        /*\n         *  /calculate page Rank\n         *  for(int i = 0; i< 1; i++)\n         *  {\n         *  from = i%2;\n         *  to = (i+1) % 2;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node act = (Node)nodeArray[j];\n         *  LinkedList inc = act.getIncoming();\n         *  float pageRank = 0;\n         *  Iterator it = inc.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  pageRank += t.getLinkRank(from);\n         *  }\n         *  act.setNodeRank(pageRank, to);\n         *  LinkedList out = act.getOutgoing();\n         *  int size = out.size();\n         *  if(size > 0)\n         *  {\n         *  float linkRank = pageRank / size;\n         *  it = out.iterator();\n         *  while(it.hasNext())\n         *  {\n         *  Transition t = (Transition)it.next();\n         *  t.setLinkRank(linkRank, to);\n         *  }\n         *  }\n         *  }\n         *  }\n         */\n        /*\n         *  System.out.println(\"\\nLink Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  Node.sortType = to;\n         *  Arrays.sort(nodeArray);\n         *  System.out.println(\"\\nPageRank Count:\");\n         *  for(int i=0; i<10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)\n         *  {\n         *  Node n = ((Node)nodeArray[i]);\n         *  System.out.println(\"Node \" + n.name + \": \" + n.getIncoming().size() + \"; pageRank: \" + n.getNodeRank(to));\n         *  }\n         *  System.out.println(\"\\nStats...\");\n         *  float distanceAccumulated=0;\n         *  float distanceMax = 0;\n         *  int notCounted = 0;\n         *  for(int j = 0; j<nodeArray.length; j++)\n         *  {\n         *  Node n = (Node)nodeArray[j];\n         *  if(n.distance != Integer.MAX_VALUE)\n         *  {\n         *  distanceAccumulated += n.distance;\n         *  distanceMax = Math.max(distanceMax, n.distance);\n         *  }\n         *  else\n         *  {\n         *  notCounted++;\n         *  }\n         *  }\n         *  System.out.println(\"Mean Distance:          \" + ((double)distanceAccumulated)/nodeArray.length);\n         *  System.out.println(\"Max Distance:           \" + (distanceMax));\n         *  System.out.println(\"Not reachable nodes(?): \" + notCounted);\n         *  System.out.println(\"Referer Median:         \" + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());\n         *  System.out.println(\"\\nSamples:\");\n         */\n        printShortestRoute(toNode, 0, 0);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"21b526e3e9974b2651365fbae52a976e6fc77aa4":["05d36e0b328ec96237035fbcca240e73631396e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["21b526e3e9974b2651365fbae52a976e6fc77aa4"],"05d36e0b328ec96237035fbcca240e73631396e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"21b526e3e9974b2651365fbae52a976e6fc77aa4":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05d36e0b328ec96237035fbcca240e73631396e5"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05d36e0b328ec96237035fbcca240e73631396e5":["21b526e3e9974b2651365fbae52a976e6fc77aa4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}