{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76923f6a33f2c4bec7f584e3f251261afe7ea276","date":1337149711,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed()) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed()) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields#Lucene3xFields(Directory,FieldInfos,SegmentInfo,IOContext,int).mjava","sourceNew":null,"sourceOld":"  public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n    \n    boolean success = false;\n    try {\n      TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, context, indexDivisor);    \n      if (indexDivisor == -1) {\n        tisNoIndex = r;\n      } else {\n        tisNoIndex = null;\n        tis = r;\n      }\n      this.context = context;\n      this.fieldInfos = fieldInfos;\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.FREQ_EXTENSION), context);\n      boolean anyProx = false;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.isIndexed()) {\n          fields.put(fi.name, fi);\n          preTerms.put(fi.name, new PreTerms(fi));\n          if (fi.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {\n            anyProx = true;\n          }\n        }\n      }\n\n      if (anyProx) {\n        proxStream = dir.openInput(IndexFileNames.segmentFileName(info.name, \"\", Lucene3xPostingsFormat.PROX_EXTENSION), context);\n      } else {\n        proxStream = null;\n      }\n      success = true;\n    } finally {\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above. In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        close();\n      }\n    }\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"76923f6a33f2c4bec7f584e3f251261afe7ea276":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","76923f6a33f2c4bec7f584e3f251261afe7ea276"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"]},"commit2Childs":{"76923f6a33f2c4bec7f584e3f251261afe7ea276":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["76923f6a33f2c4bec7f584e3f251261afe7ea276","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}