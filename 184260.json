{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","pathOld":"/dev/null","sourceNew":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","sourceNew":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","sourceOld":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","sourceNew":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","sourceOld":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/ReplicationClient#doUpdate().mjava","sourceNew":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<>();\n    final Map<String,List<String>> copiedFiles = new HashMap<>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","sourceOld":"  private void doUpdate() throws IOException {\n    SessionToken session = null;\n    final Map<String,Directory> sourceDirectory = new HashMap<String,Directory>();\n    final Map<String,List<String>> copiedFiles = new HashMap<String,List<String>>();\n    boolean notify = false;\n    try {\n      final String version = handler.currentVersion();\n      session = replicator.checkForUpdate(version);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): handlerVersion=\" + version + \" session=\" + session);\n      }\n      if (session == null) {\n        // already up to date\n        return;\n      }\n      Map<String,List<RevisionFile>> requiredFiles = requiredFiles(session.sourceFiles);\n      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n        infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): requiredFiles=\" + requiredFiles);\n      }\n      for (Entry<String,List<RevisionFile>> e : requiredFiles.entrySet()) {\n        String source = e.getKey();\n        Directory dir = factory.getDirectory(session.id, source);\n        sourceDirectory.put(source, dir);\n        List<String> cpFiles = new ArrayList<String>();\n        copiedFiles.put(source, cpFiles);\n        for (RevisionFile file : e.getValue()) {\n          if (closed) {\n            // if we're closed, abort file copy\n            if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n              infoStream.message(INFO_STREAM_COMPONENT, \"doUpdate(): detected client was closed); abort file copy\");\n            }\n            return;\n          }\n          InputStream in = null;\n          IndexOutput out = null;\n          try {\n            in = replicator.obtainFile(session.id, source, file.fileName);\n            out = dir.createOutput(file.fileName, IOContext.DEFAULT);\n            copyBytes(out, in);\n            cpFiles.add(file.fileName);\n            // TODO add some validation, on size / checksum\n          } finally {\n            IOUtils.close(in, out);\n          }\n        }\n      }\n      // only notify if all required files were successfully obtained.\n      notify = true;\n    } finally {\n      if (session != null) {\n        try {\n          replicator.release(session.id);\n        } finally {\n          if (!notify) { // cleanup after ourselves\n            IOUtils.close(sourceDirectory.values());\n            factory.cleanupSession(session.id);\n          }\n        }\n      }\n    }\n    \n    // notify outside the try-finally above, so the session is released sooner.\n    // the handler may take time to finish acting on the copied files, but the\n    // session itself is no longer needed.\n    try {\n      if (notify && !closed ) { // no use to notify if we are closed already\n        handler.revisionReady(session.version, session.sourceFiles, copiedFiles, sourceDirectory);\n      }\n    } finally {\n      IOUtils.close(sourceDirectory.values());\n      if (session != null) {\n        factory.cleanupSession(session.id);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}