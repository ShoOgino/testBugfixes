{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      IntArrayAllocator iaa = new IntArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FloatArrayAllocator faa = new FloatArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, iaa, faa);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      IntArrayAllocator iaa = new IntArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FloatArrayAllocator faa = new FloatArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, iaa, faa);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a2548b7f050533ac9a884b31cab5fb6f0386fbb","date":1355233860,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams,tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      IntArrayAllocator iaa = new IntArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FloatArrayAllocator faa = new FloatArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, iaa, faa);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4c6c7f3cda7a0595cabd16e5e9107ca29852708","date":1355402234,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams,tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n        @Override\n        protected int fixedPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);\n      facetSearchParams.addFacetRequest(cfra23);\n      facetSearchParams.addFacetRequest(cfra22);\n      facetSearchParams.addFacetRequest(cfra21);\n      facetSearchParams.addFacetRequest(cfrb23);\n      facetSearchParams.addFacetRequest(cfrb22);\n      facetSearchParams.addFacetRequest(cfrb21);\n      facetSearchParams.addFacetRequest(doctor);\n      facetSearchParams.addFacetRequest(cfrb20);\n      \n      IntArrayAllocator iaa = new IntArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FloatArrayAllocator faa = new FloatArrayAllocator(PartitionsUtils.partitionSize(facetSearchParams,tr), 1);\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, iaa, faa);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().getComponent(0));\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2cd18c7da6f499a33f06fc89c07a463ec074c0","date":1358329431,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().getCategoryPath().components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"811cdb4a80352766eb0c762e48972707a924e5cd","date":1358767313,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d","date":1358784296,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07155cdd910937cdf6877e48884d5782845c8b8b","date":1358796205,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        node.setValue(5.0);\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues00[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues00[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues0[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.getResidue(), Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.getSubResults()) {\n          assertEquals(expectedValues0[i++], node2.getValue(), Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.getResidue(), Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues2[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.getResidue(), Double.MIN_VALUE);\n        assertEquals(node.getNumSubResults(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(2, parentRes.getNumSubResults());\n      i = 0;\n      for (FacetResultNode node : parentRes.getSubResults()) {\n        assertEquals(expectedValues3[i++], node.getValue(), Double.MIN_VALUE);\n        assertEquals(0.0, node.getResidue(), Double.MIN_VALUE);\n        assertEquals(0, node.getNumSubResults());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.getValue(), Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.getResidue(), Double.MIN_VALUE);\n      assertEquals(0, parentRes.getNumSubResults());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dae862628c7a5275e1ff00ff3bc9803dedf124a9","date":1358939646,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 2.0, 3.0, 0.0, 2.0, 0.0, 6.0, 0.0, 1.0, 0.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6 and residue 0, and one child a/c/1 with value 1\n      // then a/b with value 5 and residue 2, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 0.0, 1.0, 0.0, 5.0, 2.0, 3.0, 0.0, 2.0, 0.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues00[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues00[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has residue 2 and two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has residue 0, and one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues0[i++], node.residue, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n          assertEquals(expectedValues0[i++], node2.residue, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and residue 0 (because no children considered),  \n      //  and a/c with value 6 and residue 0 (because no children considered)\n      double [] expectedValues2 = { 8.0, 0.0, 6.0, 0.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(expectedValues2[i++], node.residue, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0.0, node.residue, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0.0, parentRes.residue, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"239f79ed06f0979cfe1911ec5fba32b94fda43c1","date":1359553898,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(16.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"571abba77e55fea386a38c0024f72ffa5b37a9ad","date":1360272747,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      StandardFacetsAccumulator sfa = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(StandardFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n      ScoredDocIdCollector scoredDoc = ScoredDocIdCollector.create(ir.maxDoc(), true);\n\n      // Collector collector = new MultiCollector(scoredDoc);\n      is.search(q, scoredDoc);\n\n      CountFacetRequest cfra23 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(\n          new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(\n          new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(\n          new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);\n      long start = System.currentTimeMillis();\n\n      List<FacetResult> facetResults = fctExtrctr.accumulate(scoredDoc.getScoredDocIDs());\n\n      long end = System.currentTimeMillis();\n      if (VERBOSE) {\n        System.out.println(\"Time: \" + (end - start));\n      }\n      \n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = cfra23.createFacetResultsHandler(tr).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      StandardFacetsAccumulator sfa = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(StandardFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      StandardFacetsAccumulator sfa = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(StandardFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // a/b, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertFalse(\"Shouldn't have found anything for a FacetRequest \" +\n          \"of a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than seven request.\", 7, facetResults.size());\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9b07d1cdffdee4f4bb3cef8670f6066cf6f64e6","date":1375108983,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      StandardFacetsAccumulator sfa = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(StandardFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b1c67b5eba853532b31132bf5aef70a3b2be63f","date":1375351298,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      StandardFacetsAccumulator sfa = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(StandardFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new FacetLabel(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new FacetLabel(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new FacetLabel(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new FacetLabel(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler#testSimple().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testSimple() throws Exception {\n\n    int[] partitionSizes = new int[] { \n        2,3,4, 5, 6, 7, 10, 1000,\n        Integer.MAX_VALUE };\n\n    for (int partitionSize : partitionSizes) {\n      Directory iDir = newDirectory();\n      Directory tDir = newDirectory();\n\n      if (VERBOSE) {\n        System.out.println(\"Partition Size: \" + partitionSize);\n      }\n      \n      final int pSize = partitionSize;\n      FacetIndexingParams iParams = new FacetIndexingParams() {\n        @Override\n        public int getPartitionSize() {\n          return pSize;\n        }\n      };\n\n      RandomIndexWriter iw = new RandomIndexWriter(random(), iDir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT,\n              new MockAnalyzer(random())).setOpenMode(OpenMode.CREATE));\n      TaxonomyWriter tw = new DirectoryTaxonomyWriter(tDir);\n      prvt_add(iParams, iw, tw, \"a\", \"b\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"2\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"3\");\n      prvt_add(iParams, iw, tw, \"a\", \"b\", \"4\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\");\n      prvt_add(iParams, iw, tw, \"a\", \"c\", \"1\");\n      prvt_add(iParams, iw, tw, \"a\", \"d\");\n      prvt_add(iParams, iw, tw, \"a\", \"e\");\n\n      IndexReader ir = iw.getReader();\n      iw.close();\n      tw.commit();\n      tw.close();\n\n      IndexSearcher is = newSearcher(ir);\n      DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(tDir);\n\n      // Get all of the documents and run the query, then do different\n      // facet counts and compare to control\n      Query q = new TermQuery(new Term(\"content\", \"alpha\"));\n\n      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra23.setDepth(3);\n      cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra22.setDepth(2);\n      cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath(\"a\"), 2);\n      cfra21.setDepth(1);\n      cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb22.setDepth(2);\n      cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb23.setDepth(3);\n      cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb21.setDepth(1);\n      cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath(\"Doctor\"), 2);\n      doctor.setDepth(1);\n      doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath(\"a\", \"b\"), 2);\n      cfrb20.setDepth(0);\n      cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);\n\n      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n      facetRequests.add(cfra23);\n      facetRequests.add(cfra22);\n      facetRequests.add(cfra21);\n      facetRequests.add(cfrb23);\n      facetRequests.add(cfrb22);\n      facetRequests.add(cfrb21);\n      facetRequests.add(doctor);\n      facetRequests.add(cfrb20);\n      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);\n      \n      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.indexingParams, tr));\n      OldFacetsAccumulator sfa = new OldFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);\n      sfa.setComplementThreshold(OldFacetsAccumulator.DISABLE_COMPLEMENT);\n      FacetsCollector fc = FacetsCollector.create(sfa);\n      \n      is.search(q, fc);\n      List<FacetResult> facetResults = fc.getFacetResults();\n\n      FacetResult fr = facetResults.get(0); // a, depth=3, K=2\n      boolean hasDoctor = \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      FacetResultNode parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      double [] expectedValues0 = { 8.0, 3.0, 2.0, 6.0, 1.0 };\n      int i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      // now just change the value of the first child of the root to 5, and then rearrange\n      // expected are: first a/c of value 6, and one child a/c/1 with value 1\n      // then a/b with value 5, and both children: a/b/2 with value 3, and a/b/1 with value 2.\n      for (FacetResultNode node : parentRes.subResults) {\n        node.value = 5.0;\n        break;\n      }\n      // now rearrange\n      double [] expectedValues00 = { 6.0, 1.0, 5.0, 3.0, 2.0 };\n      fr = sfa.createFacetResultsHandler(cfra23, sfa.createOrdinalValueResolver(cfra23)).rearrangeFacetResult(fr);\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues00[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues00[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(1); // a, depth=2, K=2. same result as before\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(9, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: a/b with 8  and a/c with 6\n      // a/b has two children a/b/2 with value 3, and a/b/1 with value 2. \n      // a/c has one child a/c/1 with value 1.\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues0[i++], node.value, Double.MIN_VALUE);\n        for (FacetResultNode node2 : node.subResults) {\n          assertEquals(expectedValues0[i++], node2.value, Double.MIN_VALUE);\n        }\n      }\n\n      fr = facetResults.get(2); // a, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants(), 4);\n      parentRes = fr.getFacetResultNode();\n      assertEquals(2, parentRes.subResults.size());\n      // two nodes sorted by descending values: \n      // a/b with value 8 and a/c with value 6\n      double [] expectedValues2 = { 8.0, 6.0, 0.0};\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues2[i++], node.value, Double.MIN_VALUE);\n        assertEquals(node.subResults.size(), 0);\n      }\n      \n      fr = facetResults.get(3); // a/b, depth=3, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      double [] expectedValues3 = { 3.0, 2.0 };\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(4); // a/b, depth=2, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      fr = facetResults.get(5); // a/b, depth=1, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(4, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(2, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n      \n      fr = facetResults.get(6); // Doctor, depth=0, K=2\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n      assertEquals(0, fr.getNumValidDescendants()); // 0 descendants but rootnode\n      parentRes = fr.getFacetResultNode();\n      assertEquals(0.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      hasDoctor |= \"Doctor\".equals(fr.getFacetRequest().categoryPath.components[0]);\n\n      // doctor, depth=1, K=2\n      assertTrue(\"Should have found an empty FacetResult \" +\n          \"for a facet that doesn't exist in the index.\", hasDoctor);\n      assertEquals(\"Shouldn't have found more than 8 request.\", 8, facetResults.size());\n\n      fr = facetResults.get(7); // a/b, depth=0, K=2\n      assertEquals(0, fr.getNumValidDescendants());\n      parentRes = fr.getFacetResultNode();\n      assertEquals(8.0, parentRes.value, Double.MIN_VALUE);\n      assertEquals(0, parentRes.subResults.size());\n      i = 0;\n      for (FacetResultNode node : parentRes.subResults) {\n        assertEquals(expectedValues3[i++], node.value, Double.MIN_VALUE);\n        assertEquals(0, node.subResults.size());\n      }\n\n      ir.close();\n      tr.close();\n      iDir.close();\n      tDir.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d":["811cdb4a80352766eb0c762e48972707a924e5cd"],"d33e19a97046248623a7591aeaa6547233fd15e2":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"07155cdd910937cdf6877e48884d5782845c8b8b":["c4015cd39dff8d4dec562d909f9766debac53aa6","f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3b1c67b5eba853532b31132bf5aef70a3b2be63f"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["07155cdd910937cdf6877e48884d5782845c8b8b","dae862628c7a5275e1ff00ff3bc9803dedf124a9"],"d9b07d1cdffdee4f4bb3cef8670f6066cf6f64e6":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["d9b07d1cdffdee4f4bb3cef8670f6066cf6f64e6"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"dae862628c7a5275e1ff00ff3bc9803dedf124a9":["f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"61d5f95d14e5b9b046998c51e16709a398c15226":["b2d5244a676b83c2d551c3746e8181588ba619e1","239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"2a2548b7f050533ac9a884b31cab5fb6f0386fbb":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["2a2548b7f050533ac9a884b31cab5fb6f0386fbb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["dae862628c7a5275e1ff00ff3bc9803dedf124a9"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["3b1c67b5eba853532b31132bf5aef70a3b2be63f","d33e19a97046248623a7591aeaa6547233fd15e2"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"811cdb4a80352766eb0c762e48972707a924e5cd":["6c2cd18c7da6f499a33f06fc89c07a463ec074c0"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["d9b07d1cdffdee4f4bb3cef8670f6066cf6f64e6","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d":["07155cdd910937cdf6877e48884d5782845c8b8b","dae862628c7a5275e1ff00ff3bc9803dedf124a9"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["07155cdd910937cdf6877e48884d5782845c8b8b"],"07155cdd910937cdf6877e48884d5782845c8b8b":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d33e19a97046248623a7591aeaa6547233fd15e2"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["61d5f95d14e5b9b046998c51e16709a398c15226"],"d9b07d1cdffdee4f4bb3cef8670f6066cf6f64e6":["3b1c67b5eba853532b31132bf5aef70a3b2be63f"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","2a2548b7f050533ac9a884b31cab5fb6f0386fbb"],"dae862628c7a5275e1ff00ff3bc9803dedf124a9":["b2d5244a676b83c2d551c3746e8181588ba619e1","239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"2a2548b7f050533ac9a884b31cab5fb6f0386fbb":["d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["571abba77e55fea386a38c0024f72ffa5b37a9ad","61d5f95d14e5b9b046998c51e16709a398c15226"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["c4015cd39dff8d4dec562d909f9766debac53aa6","811cdb4a80352766eb0c762e48972707a924e5cd"],"811cdb4a80352766eb0c762e48972707a924e5cd":["f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["61d5f95d14e5b9b046998c51e16709a398c15226","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}