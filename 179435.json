{"path":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","commits":[{"id":"3a2591037a85ef083e6588e0b846a5a34ff9b5a3","date":1326403130,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"/dev/null","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<K, V>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLFUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce13e934d6cfdcc82d51e85de460cf9790e97566","date":1563877281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    sizeLimit = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (sizeLimit * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (sizeLimit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? sizeLimit : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(sizeLimit, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit == 0) minLimit = 1;\n    if (limit <= minLimit) limit = minLimit + 1;\n\n    int acceptableSize;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableSize = (int) (limit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minLimit, acceptableSize);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(\"timeDecay\");\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = \"Concurrent LFU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n        \", minSize=\" + minLimit + \", acceptableSize=\" + acceptableSize + \", cleanupThread=\" + newThread +\n        \", timeDecay=\" + Boolean.toString(timeDecay);\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLFUCache<>(limit, minLimit, acceptableSize, initialSize, newThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7","date":1565791119,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    sizeLimit = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (sizeLimit * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (sizeLimit * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? sizeLimit : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(sizeLimit, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","date":1566455239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) || Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","date":1568645407,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) || Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) || Boolean.parseBoolean(str);\n\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize, cleanupThread, false, null, timeDecay);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) || Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str != null && Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) || Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d7d3943904804560937e6239effeebda0f920e4","date":1573762904,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/LFUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(NAME);\n    String str = (String) args.get(SIZE_PARAM);\n    maxSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(MIN_SIZE_PARAM);\n    if (str == null) {\n      minSizeLimit = (int) (maxSize * 0.9);\n    } else {\n      minSizeLimit = Integer.parseInt(str);\n    }\n    checkAndAdjustLimits();\n\n    str = (String) args.get(ACCEPTABLE_SIZE_PARAM);\n    if (str == null) {\n      acceptableSize = (int) (maxSize * 0.95);\n    } else {\n      acceptableSize = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableSize = Math.max(minSizeLimit, acceptableSize);\n\n    str = (String) args.get(INITIAL_SIZE_PARAM);\n    initialSize = str == null ? maxSize : Integer.parseInt(str);\n    str = (String) args.get(AUTOWARM_COUNT_PARAM);\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(CLEANUP_THREAD_PARAM);\n    cleanupThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(SHOW_ITEMS_PARAM);\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n    // Don't make this \"efficient\" by removing the test, default is true and omitting the param will make it false.\n    str = (String) args.get(TIME_DECAY_PARAM);\n    timeDecay = (str == null) ? true : Boolean.parseBoolean(str);\n\n    str = (String) args.get(MAX_IDLE_TIME_PARAM);\n    if (str == null) {\n      maxIdleTimeSec = -1;\n    } else {\n      maxIdleTimeSec = Integer.parseInt(str);\n    }\n    description = generateDescription();\n\n    cache = new ConcurrentLFUCache<>(maxSize, minSizeLimit, acceptableSize, initialSize,\n        cleanupThread, false, null, timeDecay, maxIdleTimeSec);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLFUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLFUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3a2591037a85ef083e6588e0b846a5a34ff9b5a3","7530de27b87b961b51f01bd1299b7004d46e8823"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7530de27b87b961b51f01bd1299b7004d46e8823"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"4d7d3943904804560937e6239effeebda0f920e4":["c44cc06c26e456fe9c215072b79fce30babe3975"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["0e33a2e75ecee8b06fba2bd570c0fb9273962bc7"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1390137e395d2f07f9ba5b8c43d293befe84d563"],"7530de27b87b961b51f01bd1299b7004d46e8823":["3a2591037a85ef083e6588e0b846a5a34ff9b5a3"],"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7":["ce13e934d6cfdcc82d51e85de460cf9790e97566"],"3a2591037a85ef083e6588e0b846a5a34ff9b5a3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d7d3943904804560937e6239effeebda0f920e4"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"4d7d3943904804560937e6239effeebda0f920e4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c44cc06c26e456fe9c215072b79fce30babe3975":["4d7d3943904804560937e6239effeebda0f920e4","b0b597c65628ca9e73913a07e81691f8229bae35"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["0e33a2e75ecee8b06fba2bd570c0fb9273962bc7"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["ce13e934d6cfdcc82d51e85de460cf9790e97566","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a2591037a85ef083e6588e0b846a5a34ff9b5a3"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a2591037a85ef083e6588e0b846a5a34ff9b5a3":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"0e33a2e75ecee8b06fba2bd570c0fb9273962bc7":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}