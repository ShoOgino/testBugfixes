{"path":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","commits":[{"id":"71b83dcf02fe2854488bc83d70dee29c5baa7e5c","date":1383232808,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["25d54572ea9273dffb6e6f670b9ecd12bcc5e478"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"582a32eeb049d563d59e2958fe2d130e473101ff","date":1385502371,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25d54572ea9273dffb6e6f670b9ecd12bcc5e478","date":1391023212,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.                                                                          k\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<String,SortedSet<String>>();\n    Map<String, String> testScopePropertyKeys = new HashMap<String,String>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<String>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<String>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e4bd3aed493904d0bbb6c6e0394f619e175087","date":1401446035,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = loadPropertiesFile(moduleDependenciesPropertiesFile);\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea052815f3cac4119a481d69491a9dbff3f00a26","date":1436831120,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec1a71fbd0f533ceb6c940816637d33e90394dc1","date":1439660103,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44ca373a146e4fe32f6cd700238c38dab4fc26a9","date":1487082464,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = ivyModuleInfo.get(artifactId);\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = ivyModuleInfo.get(artifactId);\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = ivyModuleInfo.get(artifactId);\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = ivyModuleInfo.get(artifactId);\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = \"org.apache.\" + artifactId.substring(0, artifactId.indexOf('-'));\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e025cf1c07150c8db28879d785db17eb3a66ca9f","date":1598788864,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#setInternalDependencyProperties().mjava","sourceNew":null,"sourceOld":"  /**\n   * Sets the internal dependencies compile and test properties to be inserted \n   * into modules' POMs.\n   * \n   * Also collects shared external dependencies, \n   * e.g. solr-core wants all of solrj's external dependencies \n   */\n  private void  setInternalDependencyProperties() {\n    log(\"Loading module dependencies from: \" + moduleDependenciesPropertiesFile, verboseLevel);\n    Properties moduleDependencies = new Properties();\n    try (InputStream inputStream = new FileInputStream(moduleDependenciesPropertiesFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      moduleDependencies.load(reader);\n    } catch (FileNotFoundException e) {\n      throw new BuildException(\"Properties file does not exist: \" + moduleDependenciesPropertiesFile.getPath());\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading properties file \" + moduleDependenciesPropertiesFile.getPath(), e);\n    }\n    Map<String,SortedSet<String>> testScopeDependencies = new HashMap<>();\n    Map<String, String> testScopePropertyKeys = new HashMap<>();\n    for (Map.Entry<?,?> entry : moduleDependencies.entrySet()) {\n      String newPropertyKey = (String)entry.getKey();\n      StringBuilder newPropertyValue = new StringBuilder();\n      String value = (String)entry.getValue();\n      Matcher matcher = MODULE_DEPENDENCIES_COORDINATE_KEY_PATTERN.matcher(newPropertyKey);\n      if ( ! matcher.matches()) {\n        throw new BuildException(\"Malformed module dependencies property key: '\" + newPropertyKey + \"'\");\n      }\n      String antProjectName = matcher.group(1);\n      boolean isTest = null != matcher.group(2);\n      String artifactName = antProjectToArtifactName(antProjectName);\n      newPropertyKey = artifactName + (isTest ? \".internal.test\" : \".internal\") + \".dependencies\"; // Add \".internal\"\n      if (isTest) {\n        testScopePropertyKeys.put(artifactName, newPropertyKey);\n      }\n      if (null == value || value.isEmpty()) {\n        allProperties.setProperty(newPropertyKey, \"\");\n        Map<String,SortedSet<String>> scopedDependencies\n            = isTest ? testScopeDependencies : internalCompileScopeDependencies;\n        scopedDependencies.put(artifactName, new TreeSet<String>());\n      } else {\n        // Lucene analysis modules' build dirs do not include hyphens, but Solr contribs' build dirs do\n        String origModuleDir = antProjectName.replace(\"analyzers-\", \"analysis/\");\n        // Exclude the module's own build output, in addition to UNWANTED_INTERNAL_DEPENDENCIES\n        Pattern unwantedInternalDependencies = Pattern.compile\n            (\"(?:lucene/build/|solr/build/(?:contrib/)?)\" + origModuleDir + \"/\" // require dir separator \n             + \"|\" + UNWANTED_INTERNAL_DEPENDENCIES);\n        SortedSet<String> sortedDeps = new TreeSet<>();\n        for (String dependency : value.split(\",\")) {\n          matcher = SHARED_EXTERNAL_DEPENDENCIES_PATTERN.matcher(dependency);\n          if (matcher.find()) {\n            String otherArtifactName = matcher.group(1);\n            boolean isTestScope = null != matcher.group(2) && matcher.group(2).length() > 0;\n            otherArtifactName = otherArtifactName.replace('/', '-');\n            otherArtifactName = otherArtifactName.replace(\"lucene-analysis\", \"lucene-analyzers\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-solr-\", \"solr-\");\n            otherArtifactName = otherArtifactName.replace(\"solr-contrib-\", \"solr-\");\n            if ( ! otherArtifactName.equals(artifactName)) {\n              Map<String,Set<String>> sharedDeps\n                  = isTest ? interModuleExternalTestScopeDependencies : interModuleExternalCompileScopeDependencies;\n              Set<String> sharedSet = sharedDeps.get(artifactName);\n              if (null == sharedSet) {\n                sharedSet = new HashSet<>();\n                sharedDeps.put(artifactName, sharedSet);\n              }\n              if (isTestScope) {\n                otherArtifactName += \":test\";\n              }\n              sharedSet.add(otherArtifactName);\n            }\n          }\n          matcher = unwantedInternalDependencies.matcher(dependency);\n          if (matcher.find()) {\n            continue;  // skip external (/(test-)lib/), and non-jar and unwanted (self) internal deps\n          }\n          String artifactId = dependencyToArtifactId(newPropertyKey, dependency);\n          String groupId = ivyModuleInfo.get(artifactId);\n          String coordinate = groupId + ':' + artifactId;\n          sortedDeps.add(coordinate);\n        }\n        if (isTest) {  // Don't set test-scope properties until all compile-scope deps have been seen\n          testScopeDependencies.put(artifactName, sortedDeps);\n        } else {\n          internalCompileScopeDependencies.put(artifactName, sortedDeps);\n          for (String dependency : sortedDeps) {\n            int splitPos = dependency.indexOf(':');\n            String groupId = dependency.substring(0, splitPos);\n            String artifactId = dependency.substring(splitPos + 1);\n            appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, false, false, null, null);\n          }\n          if (newPropertyValue.length() > 0) {\n            newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n          }\n          allProperties.setProperty(newPropertyKey, newPropertyValue.toString());\n        }\n      }\n    }\n    // Now that all compile-scope dependencies have been seen, include only those test-scope\n    // dependencies that are not also compile-scope dependencies.\n    for (Map.Entry<String,SortedSet<String>> entry : testScopeDependencies.entrySet()) {\n      String module = entry.getKey();\n      SortedSet<String> testDeps = entry.getValue();\n      SortedSet<String> compileDeps = internalCompileScopeDependencies.get(module);\n      if (null == compileDeps) {\n        throw new BuildException(\"Can't find compile scope dependencies for module \" + module);\n      }\n      StringBuilder newPropertyValue = new StringBuilder();\n      for (String dependency : testDeps) {\n        // modules with separate compile-scope and test-scope POMs need their compile-scope deps\n        // included in their test-scope deps.\n        if (modulesWithSeparateCompileAndTestPOMs.contains(module) || ! compileDeps.contains(dependency)) {\n          int splitPos = dependency.indexOf(':');\n          String groupId = dependency.substring(0, splitPos);\n          String artifactId = dependency.substring(splitPos + 1);\n          appendDependencyXml(newPropertyValue, groupId, artifactId, \"    \", null, true, false, null, null);\n        }\n      }\n      if (newPropertyValue.length() > 0) {\n        newPropertyValue.setLength(newPropertyValue.length() - 1); // drop trailing newline\n      }\n      allProperties.setProperty(testScopePropertyKeys.get(module), newPropertyValue.toString());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["25d54572ea9273dffb6e6f670b9ecd12bcc5e478"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"582a32eeb049d563d59e2958fe2d130e473101ff":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ea052815f3cac4119a481d69491a9dbff3f00a26":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"25d54572ea9273dffb6e6f670b9ecd12bcc5e478":["582a32eeb049d563d59e2958fe2d130e473101ff"],"022a4de90e0479b604264ca9c2e134c996454ab3":["ec1a71fbd0f533ceb6c940816637d33e90394dc1","44ca373a146e4fe32f6cd700238c38dab4fc26a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c","582a32eeb049d563d59e2958fe2d130e473101ff"],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["ea052815f3cac4119a481d69491a9dbff3f00a26"],"44ca373a146e4fe32f6cd700238c38dab4fc26a9":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e025cf1c07150c8db28879d785db17eb3a66ca9f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"582a32eeb049d563d59e2958fe2d130e473101ff":["25d54572ea9273dffb6e6f670b9ecd12bcc5e478","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["582a32eeb049d563d59e2958fe2d130e473101ff","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ea052815f3cac4119a481d69491a9dbff3f00a26":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["ea052815f3cac4119a481d69491a9dbff3f00a26"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"25d54572ea9273dffb6e6f670b9ecd12bcc5e478":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["022a4de90e0479b604264ca9c2e134c996454ab3","44ca373a146e4fe32f6cd700238c38dab4fc26a9"],"44ca373a146e4fe32f6cd700238c38dab4fc26a9":["022a4de90e0479b604264ca9c2e134c996454ab3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}