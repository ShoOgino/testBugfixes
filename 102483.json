{"path":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","commits":[{"id":"aa380b0ac7fa6c578259afbb8eaa19927570010d","date":1333998347,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    pos += posIncAtt.getPositionIncrement();\n    if (pos == -1) {\n      throw new IllegalStateException(\"first posInc must be > 0\");\n    }\n\n    final int startOffset = offsetAtt.startOffset();\n    final int endOffset = offsetAtt.endOffset();\n\n    final int posLen = posLenAtt.getPositionLength();\n    if (!posToStartOffset.containsKey(pos)) {\n      // First time we've seen a token leaving from this position:\n      posToStartOffset.put(pos, startOffset);\n      System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n    } else {\n      // We've seen a token leaving from this position\n      // before; verify the startOffset is the same:\n      System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n      final int oldStartOffset = posToStartOffset.get(pos);\n      if (oldStartOffset != startOffset) {\n        throw new IllegalStateException(name + \": inconsistent startOffset as pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n      }\n    }\n\n    final int endPos = pos + posLen;\n\n    if (!posToEndOffset.containsKey(endPos)) {\n      // First time we've seen a token arriving to this position:\n      posToEndOffset.put(endPos, endOffset);\n      System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n    } else {\n      // We've seen a token arriving to this position\n      // before; verify the endOffset is the same:\n      System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n      final int oldEndOffset = posToEndOffset.get(endPos);\n      if (oldEndOffset != endOffset) {\n        throw new IllegalStateException(name + \": inconsistent endOffset as pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b718982cab7563e9344dfbedfbcf3808059f2a99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c","date":1334001650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    if (posIncAtt != null && offsetAtt != null) {\n\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n\n      final int startOffset = offsetAtt.startOffset();\n      final int endOffset = offsetAtt.endOffset();\n\n      final int posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset as pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset as pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    pos += posIncAtt.getPositionIncrement();\n    if (pos == -1) {\n      throw new IllegalStateException(\"first posInc must be > 0\");\n    }\n\n    final int startOffset = offsetAtt.startOffset();\n    final int endOffset = offsetAtt.endOffset();\n\n    final int posLen = posLenAtt.getPositionLength();\n    if (!posToStartOffset.containsKey(pos)) {\n      // First time we've seen a token leaving from this position:\n      posToStartOffset.put(pos, startOffset);\n      System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n    } else {\n      // We've seen a token leaving from this position\n      // before; verify the startOffset is the same:\n      System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n      final int oldStartOffset = posToStartOffset.get(pos);\n      if (oldStartOffset != startOffset) {\n        throw new IllegalStateException(name + \": inconsistent startOffset as pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n      }\n    }\n\n    final int endPos = pos + posLen;\n\n    if (!posToEndOffset.containsKey(endPos)) {\n      // First time we've seen a token arriving to this position:\n      posToEndOffset.put(endPos, endOffset);\n      System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n    } else {\n      // We've seen a token arriving to this position\n      // before; verify the endOffset is the same:\n      System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n      final int oldEndOffset = posToEndOffset.get(endPos);\n      if (oldEndOffset != endOffset) {\n        throw new IllegalStateException(name + \": inconsistent endOffset as pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["b718982cab7563e9344dfbedfbcf3808059f2a99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"338df4e195522e0470c227cc7cf52ad97a254ae4","date":1334001895,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    if (posIncAtt != null && offsetAtt != null) {\n\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n\n      final int startOffset = offsetAtt.startOffset();\n      final int endOffset = offsetAtt.endOffset();\n\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n\n      final int posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    if (posIncAtt != null && offsetAtt != null) {\n\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n\n      final int startOffset = offsetAtt.startOffset();\n      final int endOffset = offsetAtt.endOffset();\n\n      final int posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset as pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset as pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["cd65a3c65e7917a381c935b0b663d8e783bd9a1e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e28391b63c7411dda25cc455b28293ec9c37d7f","date":1334066955,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (startOffset < 0) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is < 0\");\n      }\n      if (endOffset < 0) {\n        throw new IllegalStateException(name + \": endOffset=\" + endOffset + \" is < 0\");\n      }\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    if (posIncAtt != null && offsetAtt != null) {\n\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n\n      final int startOffset = offsetAtt.startOffset();\n      final int endOffset = offsetAtt.endOffset();\n\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n\n      final int posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["cd65a3c65e7917a381c935b0b663d8e783bd9a1e","b718982cab7563e9344dfbedfbcf3808059f2a99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"888c2d6bca1edd8d9293631d6e1d188b036e0f05","date":1334076894,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (startOffset < 0) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is < 0\");\n      }\n      if (endOffset < 0) {\n        throw new IllegalStateException(name + \": endOffset=\" + endOffset + \" is < 0\");\n      }\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n      if (offsetsAreCorrect && offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null && offsetsAreCorrect) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (startOffset < 0) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is < 0\");\n      }\n      if (endOffset < 0) {\n        throw new IllegalStateException(name + \": endOffset=\" + endOffset + \" is < 0\");\n      }\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["ad55dd51ee5593c207639943b98a58782872b232"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","date":1334174049,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (startOffset < 0) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is < 0\");\n      }\n      if (endOffset < 0) {\n        throw new IllegalStateException(name + \": endOffset=\" + endOffset + \" is < 0\");\n      }\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n      if (offsetsAreCorrect && offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null && offsetsAreCorrect) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd65a3c65e7917a381c935b0b663d8e783bd9a1e","date":1339372221,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetsAreCorrect && offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null && offsetsAreCorrect) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (startOffset < 0) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is < 0\");\n      }\n      if (endOffset < 0) {\n        throw new IllegalStateException(name + \": endOffset=\" + endOffset + \" is < 0\");\n      }\n      if (endOffset < startOffset) {\n        throw new IllegalStateException(name + \": startOffset=\" + startOffset + \" is > endOffset=\" + endOffset + \" pos=\" + pos + \"; token=\" + termAtt);\n      }\n      if (offsetsAreCorrect && offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null && offsetsAreCorrect) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":["338df4e195522e0470c227cc7cf52ad97a254ae4","8e28391b63c7411dda25cc455b28293ec9c37d7f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad55dd51ee5593c207639943b98a58782872b232","date":1520180625,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetsAreCorrect && offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null && offsetsAreCorrect) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":["888c2d6bca1edd8d9293631d6e1d188b036e0f05"],"bugIntro":["b718982cab7563e9344dfbedfbcf3808059f2a99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57e34488c685935a055be1bc57b850be1e8c850d","date":1526645499,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        //System.out.println(\"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        //System.out.println(\"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(\"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(\"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8c072c5e1c6ed1643a8c71758930b6b13ccbd43","date":1529312258,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // System.out.println(name + \": incrementToken()\");\n\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n\n    // System.out.println(name + \": \" + this);\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(name + \": first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // System.out.println(name + \": incrementToken()\");\n\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n\n    // System.out.println(name + \": \" + this);\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(name + \": first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // System.out.println(name + \": incrementToken()\");\n\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n\n    // System.out.println(name + \": \" + this);\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(name + \": first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(\"first posInc must be > 0\");\n      }\n    }\n\n    // System.out.println(\"  got token=\" + termAtt + \" pos=\" + pos);\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b718982cab7563e9344dfbedfbcf3808059f2a99","date":1543316429,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/ValidatingTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // System.out.println(name + \": incrementToken()\");\n\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n    int posInc = 0;\n\n    if (posIncAtt != null) {\n      posInc = posIncAtt.getPositionIncrement();\n    }\n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n    }\n\n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n\n    addToken(startOffset, endOffset, posInc);\n\n    // System.out.println(name + \": \" + this);\n    \n    if (posIncAtt != null) {\n      pos += posInc;\n      if (pos == -1) {\n        dumpValidatingTokenFilters(this, System.err);\n        throw new IllegalStateException(name + \": first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      if (startOffset < lastStartOffset) {\n        dumpValidatingTokenFilters(this, System.err);\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          dumpValidatingTokenFilters(this, System.err);\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          dumpValidatingTokenFilters(this, System.err);\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // System.out.println(name + \": incrementToken()\");\n\n    if (!input.incrementToken()) {\n      return false;\n    }\n\n    int startOffset = 0;\n    int endOffset = 0;\n    int posLen = 0;\n\n    // System.out.println(name + \": \" + this);\n    \n    if (posIncAtt != null) {\n      pos += posIncAtt.getPositionIncrement();\n      if (pos == -1) {\n        throw new IllegalStateException(name + \": first posInc must be > 0\");\n      }\n    }\n    \n    if (offsetAtt != null) {\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n\n      if (offsetAtt.startOffset() < lastStartOffset) {\n        throw new IllegalStateException(name + \": offsets must not go backwards startOffset=\" + startOffset + \" is < lastStartOffset=\" + lastStartOffset);\n      }\n      lastStartOffset = offsetAtt.startOffset();\n    }\n    \n    posLen = posLenAtt == null ? 1 : posLenAtt.getPositionLength();\n    \n    if (offsetAtt != null && posIncAtt != null) {\n\n      if (!posToStartOffset.containsKey(pos)) {\n        // First time we've seen a token leaving from this position:\n        posToStartOffset.put(pos, startOffset);\n        // System.out.println(name + \"  + s \" + pos + \" -> \" + startOffset);\n      } else {\n        // We've seen a token leaving from this position\n        // before; verify the startOffset is the same:\n        // System.out.println(name + \"  + vs \" + pos + \" -> \" + startOffset);\n        final int oldStartOffset = posToStartOffset.get(pos);\n        if (oldStartOffset != startOffset) {\n          throw new IllegalStateException(name + \": inconsistent startOffset at pos=\" + pos + \": \" + oldStartOffset + \" vs \" + startOffset + \"; token=\" + termAtt);\n        }\n      }\n\n      final int endPos = pos + posLen;\n\n      if (!posToEndOffset.containsKey(endPos)) {\n        // First time we've seen a token arriving to this position:\n        posToEndOffset.put(endPos, endOffset);\n        //System.out.println(name + \"  + e \" + endPos + \" -> \" + endOffset);\n      } else {\n        // We've seen a token arriving to this position\n        // before; verify the endOffset is the same:\n        //System.out.println(name + \"  + ve \" + endPos + \" -> \" + endOffset);\n        final int oldEndOffset = posToEndOffset.get(endPos);\n        if (oldEndOffset != endOffset) {\n          throw new IllegalStateException(name + \": inconsistent endOffset at pos=\" + endPos + \": \" + oldEndOffset + \" vs \" + endOffset + \"; token=\" + termAtt);\n        }\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":["ad55dd51ee5593c207639943b98a58782872b232","cdc624cad80ac093c2e6b895c4e8ad05172b8c4c","8e28391b63c7411dda25cc455b28293ec9c37d7f","aa380b0ac7fa6c578259afbb8eaa19927570010d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad55dd51ee5593c207639943b98a58782872b232":["cd65a3c65e7917a381c935b0b663d8e783bd9a1e"],"b8c072c5e1c6ed1643a8c71758930b6b13ccbd43":["57e34488c685935a055be1bc57b850be1e8c850d"],"57e34488c685935a055be1bc57b850be1e8c850d":["ad55dd51ee5593c207639943b98a58782872b232"],"b718982cab7563e9344dfbedfbcf3808059f2a99":["b8c072c5e1c6ed1643a8c71758930b6b13ccbd43"],"888c2d6bca1edd8d9293631d6e1d188b036e0f05":["8e28391b63c7411dda25cc455b28293ec9c37d7f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["57e34488c685935a055be1bc57b850be1e8c850d","b8c072c5e1c6ed1643a8c71758930b6b13ccbd43"],"cd65a3c65e7917a381c935b0b663d8e783bd9a1e":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"8e28391b63c7411dda25cc455b28293ec9c37d7f":["338df4e195522e0470c227cc7cf52ad97a254ae4"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","888c2d6bca1edd8d9293631d6e1d188b036e0f05"],"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c":["aa380b0ac7fa6c578259afbb8eaa19927570010d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"338df4e195522e0470c227cc7cf52ad97a254ae4":["cdc624cad80ac093c2e6b895c4e8ad05172b8c4c"],"aa380b0ac7fa6c578259afbb8eaa19927570010d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b718982cab7563e9344dfbedfbcf3808059f2a99"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["57e34488c685935a055be1bc57b850be1e8c850d","b8c072c5e1c6ed1643a8c71758930b6b13ccbd43"]},"commit2Childs":{"ad55dd51ee5593c207639943b98a58782872b232":["57e34488c685935a055be1bc57b850be1e8c850d"],"b8c072c5e1c6ed1643a8c71758930b6b13ccbd43":["b718982cab7563e9344dfbedfbcf3808059f2a99","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"57e34488c685935a055be1bc57b850be1e8c850d":["b8c072c5e1c6ed1643a8c71758930b6b13ccbd43","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"b718982cab7563e9344dfbedfbcf3808059f2a99":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"888c2d6bca1edd8d9293631d6e1d188b036e0f05":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"cd65a3c65e7917a381c935b0b663d8e783bd9a1e":["ad55dd51ee5593c207639943b98a58782872b232"],"8e28391b63c7411dda25cc455b28293ec9c37d7f":["888c2d6bca1edd8d9293631d6e1d188b036e0f05"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["cd65a3c65e7917a381c935b0b663d8e783bd9a1e"],"cdc624cad80ac093c2e6b895c4e8ad05172b8c4c":["338df4e195522e0470c227cc7cf52ad97a254ae4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","aa380b0ac7fa6c578259afbb8eaa19927570010d"],"338df4e195522e0470c227cc7cf52ad97a254ae4":["8e28391b63c7411dda25cc455b28293ec9c37d7f"],"aa380b0ac7fa6c578259afbb8eaa19927570010d":["cdc624cad80ac093c2e6b895c4e8ad05172b8c4c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}