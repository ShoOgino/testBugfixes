{"path":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","commits":[{"id":"a3be7723008a2c26b93c1b9d6a5e67ed2e4a2976","date":1500994164,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"487de3f55283f58d7e02a16993f8be55bbe32061","date":1502123368,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":["644de864e024cdc6f1631b340e14c6d32c62352b","644de864e024cdc6f1631b340e14c6d32c62352b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphTermsCollector#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (useAutomaton) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(matchField.getName()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = (matchField.hasDocValues() && !matchField.indexed())\n            ? new DocValuesTermsQuery(matchField.getName(), termList)\n            : new TermInSetQuery(matchField.getName(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (collectorTerms == null || collectorTerms.size() == 0) {\n      // return null if there are no terms (edges) to traverse.\n      return null;\n    } else {\n      // Create a query\n      Query q = null;\n\n      GraphQuery gq = weight.getGraphQuery();\n      // TODO: see if we should dynamically select this based on the frontier size.\n      if (gq.isUseAutn()) {\n        // build an automaton based query for the frontier.\n        Automaton autn = buildAutomaton(collectorTerms);\n        AutomatonQuery autnQuery = new AutomatonQuery(new Term(gq.getFromField()), autn);\n        q = autnQuery;\n      } else {\n        List<BytesRef> termList = new ArrayList<>(collectorTerms.size());\n        for (int i = 0 ; i < collectorTerms.size(); i++) {\n          BytesRef ref = new BytesRef();\n          collectorTerms.get(i, ref);\n          termList.add(ref);\n        }\n        q = new TermInSetQuery(gq.getFromField(), termList);\n      }\n\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a3be7723008a2c26b93c1b9d6a5e67ed2e4a2976":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a52341299179de5479672f7cf518bf4b173f34b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a3be7723008a2c26b93c1b9d6a5e67ed2e4a2976"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["a52341299179de5479672f7cf518bf4b173f34b3","487de3f55283f58d7e02a16993f8be55bbe32061"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"487de3f55283f58d7e02a16993f8be55bbe32061":["a52341299179de5479672f7cf518bf4b173f34b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["487de3f55283f58d7e02a16993f8be55bbe32061"]},"commit2Childs":{"a3be7723008a2c26b93c1b9d6a5e67ed2e4a2976":["a52341299179de5479672f7cf518bf4b173f34b3"],"a52341299179de5479672f7cf518bf4b173f34b3":["58884af1f68e9d61c217c753fbd6266d86a63b14","487de3f55283f58d7e02a16993f8be55bbe32061"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3be7723008a2c26b93c1b9d6a5e67ed2e4a2976","a52341299179de5479672f7cf518bf4b173f34b3"],"487de3f55283f58d7e02a16993f8be55bbe32061":["58884af1f68e9d61c217c753fbd6266d86a63b14","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}