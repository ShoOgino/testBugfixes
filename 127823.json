{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","commits":[{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  // nocommit: probably want an option to like, require the first character or something :)\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n      int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions, int maxEdits, boolean transpositions, int minPrefix) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.minPrefix = minPrefix;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","date":1350576194,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   *   \n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param minPrefix length of common (non-fuzzy) prefix\n   *          \n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n      int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions, int maxEdits, boolean transpositions, int minPrefix) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (minPrefix < 0) {\n      throw new IllegalArgumentException(\"minPrefix must not be < 0\");\n    }\n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.minPrefix = minPrefix;\n  }\n\n","sourceOld":"  // nocommit: probably want an option to like, require the first character or something :)\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n      int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions, int maxEdits, boolean transpositions, int minPrefix) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.minPrefix = minPrefix;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ba222c174ec1943d8d14d012d1d6e24a1cc4972","date":1351522220,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param allowSepEdit if true, the token separater is allowed to be an edit (so words may be split/joined) (see default {@link #DEFAULT_ALLOW_SEP_EDIT})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean allowSepEdit) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.allowSepEdit = allowSepEdit;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   *   \n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param minPrefix length of common (non-fuzzy) prefix\n   *          \n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n      int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions, int maxEdits, boolean transpositions, int minPrefix) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (minPrefix < 0) {\n      throw new IllegalArgumentException(\"minPrefix must not be < 0\");\n    }\n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.minPrefix = minPrefix;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cc41b743423981e7ec17a024ce7e107096e472fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"cc41b743423981e7ec17a024ce7e107096e472fe":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cc41b743423981e7ec17a024ce7e107096e472fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":[],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}