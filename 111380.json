{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],Comparator[T],int).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   * completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, Comparator<T> comparator, int topN) throws IOException {\n    return new TopNSearcher<T>(fst, fromNode, topN, comparator).search();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414aae1db83a83d247caa9514e383e4ca3d43da5","date":1350824365,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39","date":1370266419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node.\n   *\n   *  <p>NOTE: you must share the outputs when you build the\n   *  FST (pass doShare=true to {@link\n   *  PositiveIntOutputs#getSingleton}). */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<T>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d245db17aaa41b338dae9da5d4edba4dd6f61612","date":1394644847,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> TopResults<T> shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> MinResult<T>[] shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_shortestPaths(FST[T],FST.Arc[T],T,Comparator[T],int,boolean).mjava","sourceNew":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> TopResults<T> shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRefBuilder());\n    return searcher.search();\n  } \n\n","sourceOld":"  /** Starting from node, find the top N min cost \n   *  completions to a final node. */\n  public static <T> TopResults<T> shortestPaths(FST<T> fst, FST.Arc<T> fromNode, T startOutput, Comparator<T> comparator, int topN,\n                                                 boolean allowEmptyString) throws IOException {\n\n    // All paths are kept, so we can pass topN for\n    // maxQueueDepth and the pruning is admissible:\n    TopNSearcher<T> searcher = new TopNSearcher<>(fst, topN, topN, comparator);\n\n    // since this search is initialized with a single start node \n    // it is okay to start with an empty input path here\n    searcher.addStartPaths(fromNode, startOutput, allowEmptyString, new IntsRef());\n    return searcher.search();\n  } \n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"62e52115b56781006682fd92c6938efaf174304d":["6ce825e9276493231308229152c48f755ce1a0a5","414aae1db83a83d247caa9514e383e4ca3d43da5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["6ce825e9276493231308229152c48f755ce1a0a5"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["414aae1db83a83d247caa9514e383e4ca3d43da5"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"62e52115b56781006682fd92c6938efaf174304d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"6ce825e9276493231308229152c48f755ce1a0a5":["62e52115b56781006682fd92c6938efaf174304d","414aae1db83a83d247caa9514e383e4ca3d43da5"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["62e52115b56781006682fd92c6938efaf174304d","6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["62e52115b56781006682fd92c6938efaf174304d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}