{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape#encodeTriangle(byte[],int,int,int,int,int,int).mjava","commits":[{"id":"2aeefba8262036d422d639e48c49d51316bea138","date":1545148224,"type":0,"author":"iverase","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape#encodeTriangle(byte[],int,int,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A triangle is encoded using 6 points and an extra point with encoded information in three bits of how to reconstruct it.\n   * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.\n   * Reconstruction always happens from west to east.\n   */\n  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, int bLat, int bLon, int cLat, int cLon) {\n    assert bytes.length == 7 * BYTES;\n    int aX;\n    int bX;\n    int cX;\n    int aY;\n    int bY;\n    int cY;\n    //change orientation if CW\n    if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {\n      aX = cLon;\n      bX = bLon;\n      cX = aLon;\n      aY = cLat;\n      bY = bLat;\n      cY = aLat;\n    } else {\n      aX = aLon;\n      bX = bLon;\n      cX = cLon;\n      aY = aLat;\n      bY = bLat;\n      cY = cLat;\n    }\n    //rotate edges and place minX at the beginning\n    if (bX < aX || cX < aX) {\n      if (bX < cX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = bX;\n        aY = bY;\n        bX = cX;\n        bY = cY;\n        cX = tempX;\n        cY = tempY;\n      } else if (cX < aX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = cX;\n        aY = cY;\n        cX = bX;\n        cY = bY;\n        bX = tempX;\n        bY = tempY;\n      }\n    } else if (aX == bX && aX == cX) {\n      //degenerated case, all points with same longitude\n      //we need to prevent that aX is in the middle (not part of the MBS)\n      if (bY < aY || cY < aY) {\n        if (bY < cY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = bX;\n          aY = bY;\n          bX = cX;\n          bY = cY;\n          cX = tempX;\n          cY = tempY;\n        } else if (cY < aY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = cX;\n          aY = cY;\n          cX = bX;\n          cY = bY;\n          bX = tempX;\n          bY = tempY;\n        }\n      }\n    }\n\n    int minX = aX;\n    int minY = StrictMath.min(aY, StrictMath.min(bY, cY));\n    int maxX = StrictMath.max(aX, StrictMath.max(bX, cX));\n    int maxY = StrictMath.max(aY, StrictMath.max(bY, cY));\n\n    int bits, x, y;\n    if (minY == aY) {\n      if (maxY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MINY_MINX_MAXY_MAXX_Y_X;\n      } else if (maxY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MINY_MINX_Y_X_MAXY_MAXX;\n      } else {\n        y = bY;\n        x = cX;\n        bits = MINY_MINX_Y_MAXX_MAXY_X;\n      }\n    } else if (maxY == aY) {\n      if (minY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MAXY_MINX_MINY_MAXX_Y_X;\n      } else if (minY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MAXY_MINX_Y_X_MINY_MAXX;\n      } else {\n        y = cY;\n        x = bX;\n        bits = MAXY_MINX_MINY_X_Y_MAXX;\n      }\n    }  else if (maxX == bX && minY == bY) {\n      y = aY;\n      x = cX;\n      bits = Y_MINX_MINY_MAXX_MAXY_X;\n    } else if (maxX == cX && maxY == cY) {\n      y = aY;\n      x = bX;\n      bits = Y_MINX_MINY_X_MAXY_MAXX;\n    } else {\n      throw new IllegalArgumentException(\"Could not encode the provided triangle\");\n    }\n    NumericUtils.intToSortableBytes(minY, bytes, 0);\n    NumericUtils.intToSortableBytes(minX, bytes, BYTES);\n    NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);\n    NumericUtils.intToSortableBytes(maxX, bytes, 3 * BYTES);\n    NumericUtils.intToSortableBytes(y, bytes, 4 * BYTES);\n    NumericUtils.intToSortableBytes(x, bytes, 5 * BYTES);\n    NumericUtils.intToSortableBytes(bits, bytes, 6 * BYTES);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c286b0d8c507a88b289407e2fe161effa275c6b0","date":1562615977,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/ShapeField#encodeTriangle(byte[],int,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape#encodeTriangle(byte[],int,int,int,int,int,int).mjava","sourceNew":"  /**\n   * A triangle is encoded using 6 points and an extra point with encoded information in three bits of how to reconstruct it.\n   * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.\n   * Reconstruction always happens from west to east.\n   */\n  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, int bLat, int bLon, int cLat, int cLon) {\n    assert bytes.length == 7 * BYTES;\n    int aX;\n    int bX;\n    int cX;\n    int aY;\n    int bY;\n    int cY;\n    //change orientation if CW\n    if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {\n      aX = cLon;\n      bX = bLon;\n      cX = aLon;\n      aY = cLat;\n      bY = bLat;\n      cY = aLat;\n    } else {\n      aX = aLon;\n      bX = bLon;\n      cX = cLon;\n      aY = aLat;\n      bY = bLat;\n      cY = cLat;\n    }\n    //rotate edges and place minX at the beginning\n    if (bX < aX || cX < aX) {\n      if (bX < cX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = bX;\n        aY = bY;\n        bX = cX;\n        bY = cY;\n        cX = tempX;\n        cY = tempY;\n      } else if (cX < aX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = cX;\n        aY = cY;\n        cX = bX;\n        cY = bY;\n        bX = tempX;\n        bY = tempY;\n      }\n    } else if (aX == bX && aX == cX) {\n      //degenerated case, all points with same longitude\n      //we need to prevent that aX is in the middle (not part of the MBS)\n      if (bY < aY || cY < aY) {\n        if (bY < cY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = bX;\n          aY = bY;\n          bX = cX;\n          bY = cY;\n          cX = tempX;\n          cY = tempY;\n        } else if (cY < aY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = cX;\n          aY = cY;\n          cX = bX;\n          cY = bY;\n          bX = tempX;\n          bY = tempY;\n        }\n      }\n    }\n\n    int minX = aX;\n    int minY = StrictMath.min(aY, StrictMath.min(bY, cY));\n    int maxX = StrictMath.max(aX, StrictMath.max(bX, cX));\n    int maxY = StrictMath.max(aY, StrictMath.max(bY, cY));\n\n    int bits, x, y;\n    if (minY == aY) {\n      if (maxY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MINY_MINX_MAXY_MAXX_Y_X;\n      } else if (maxY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MINY_MINX_Y_X_MAXY_MAXX;\n      } else {\n        y = bY;\n        x = cX;\n        bits = MINY_MINX_Y_MAXX_MAXY_X;\n      }\n    } else if (maxY == aY) {\n      if (minY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MAXY_MINX_MINY_MAXX_Y_X;\n      } else if (minY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MAXY_MINX_Y_X_MINY_MAXX;\n      } else {\n        y = cY;\n        x = bX;\n        bits = MAXY_MINX_MINY_X_Y_MAXX;\n      }\n    }  else if (maxX == bX && minY == bY) {\n      y = aY;\n      x = cX;\n      bits = Y_MINX_MINY_MAXX_MAXY_X;\n    } else if (maxX == cX && maxY == cY) {\n      y = aY;\n      x = bX;\n      bits = Y_MINX_MINY_X_MAXY_MAXX;\n    } else {\n      throw new IllegalArgumentException(\"Could not encode the provided triangle\");\n    }\n    NumericUtils.intToSortableBytes(minY, bytes, 0);\n    NumericUtils.intToSortableBytes(minX, bytes, BYTES);\n    NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);\n    NumericUtils.intToSortableBytes(maxX, bytes, 3 * BYTES);\n    NumericUtils.intToSortableBytes(y, bytes, 4 * BYTES);\n    NumericUtils.intToSortableBytes(x, bytes, 5 * BYTES);\n    NumericUtils.intToSortableBytes(bits, bytes, 6 * BYTES);\n  }\n\n","sourceOld":"  /**\n   * A triangle is encoded using 6 points and an extra point with encoded information in three bits of how to reconstruct it.\n   * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.\n   * Reconstruction always happens from west to east.\n   */\n  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, int bLat, int bLon, int cLat, int cLon) {\n    assert bytes.length == 7 * BYTES;\n    int aX;\n    int bX;\n    int cX;\n    int aY;\n    int bY;\n    int cY;\n    //change orientation if CW\n    if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {\n      aX = cLon;\n      bX = bLon;\n      cX = aLon;\n      aY = cLat;\n      bY = bLat;\n      cY = aLat;\n    } else {\n      aX = aLon;\n      bX = bLon;\n      cX = cLon;\n      aY = aLat;\n      bY = bLat;\n      cY = cLat;\n    }\n    //rotate edges and place minX at the beginning\n    if (bX < aX || cX < aX) {\n      if (bX < cX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = bX;\n        aY = bY;\n        bX = cX;\n        bY = cY;\n        cX = tempX;\n        cY = tempY;\n      } else if (cX < aX) {\n        int tempX = aX;\n        int tempY = aY;\n        aX = cX;\n        aY = cY;\n        cX = bX;\n        cY = bY;\n        bX = tempX;\n        bY = tempY;\n      }\n    } else if (aX == bX && aX == cX) {\n      //degenerated case, all points with same longitude\n      //we need to prevent that aX is in the middle (not part of the MBS)\n      if (bY < aY || cY < aY) {\n        if (bY < cY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = bX;\n          aY = bY;\n          bX = cX;\n          bY = cY;\n          cX = tempX;\n          cY = tempY;\n        } else if (cY < aY) {\n          int tempX = aX;\n          int tempY = aY;\n          aX = cX;\n          aY = cY;\n          cX = bX;\n          cY = bY;\n          bX = tempX;\n          bY = tempY;\n        }\n      }\n    }\n\n    int minX = aX;\n    int minY = StrictMath.min(aY, StrictMath.min(bY, cY));\n    int maxX = StrictMath.max(aX, StrictMath.max(bX, cX));\n    int maxY = StrictMath.max(aY, StrictMath.max(bY, cY));\n\n    int bits, x, y;\n    if (minY == aY) {\n      if (maxY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MINY_MINX_MAXY_MAXX_Y_X;\n      } else if (maxY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MINY_MINX_Y_X_MAXY_MAXX;\n      } else {\n        y = bY;\n        x = cX;\n        bits = MINY_MINX_Y_MAXX_MAXY_X;\n      }\n    } else if (maxY == aY) {\n      if (minY == bY && maxX == bX) {\n        y = cY;\n        x = cX;\n        bits = MAXY_MINX_MINY_MAXX_Y_X;\n      } else if (minY == cY && maxX == cX) {\n        y = bY;\n        x = bX;\n        bits = MAXY_MINX_Y_X_MINY_MAXX;\n      } else {\n        y = cY;\n        x = bX;\n        bits = MAXY_MINX_MINY_X_Y_MAXX;\n      }\n    }  else if (maxX == bX && minY == bY) {\n      y = aY;\n      x = cX;\n      bits = Y_MINX_MINY_MAXX_MAXY_X;\n    } else if (maxX == cX && maxY == cY) {\n      y = aY;\n      x = bX;\n      bits = Y_MINX_MINY_X_MAXY_MAXX;\n    } else {\n      throw new IllegalArgumentException(\"Could not encode the provided triangle\");\n    }\n    NumericUtils.intToSortableBytes(minY, bytes, 0);\n    NumericUtils.intToSortableBytes(minX, bytes, BYTES);\n    NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);\n    NumericUtils.intToSortableBytes(maxX, bytes, 3 * BYTES);\n    NumericUtils.intToSortableBytes(y, bytes, 4 * BYTES);\n    NumericUtils.intToSortableBytes(x, bytes, 5 * BYTES);\n    NumericUtils.intToSortableBytes(bits, bytes, 6 * BYTES);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2aeefba8262036d422d639e48c49d51316bea138":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c286b0d8c507a88b289407e2fe161effa275c6b0":["2aeefba8262036d422d639e48c49d51316bea138"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c286b0d8c507a88b289407e2fe161effa275c6b0"]},"commit2Childs":{"2aeefba8262036d422d639e48c49d51316bea138":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2aeefba8262036d422d639e48c49d51316bea138"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}