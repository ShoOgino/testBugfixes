{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","commits":[{"id":"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","date":1492411712,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        return;\n      }\n      List<TriggerAction> actions = source.getActions();\n      if (actions != null) {\n        actionExecutor.submit(() -> {\n          for (TriggerAction action : actions) {\n            try {\n              action.process(event);\n            } catch (Exception e) {\n              log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, 1, TimeUnit.SECONDS);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"326b5c746af092eb827c5c1accdab1b47fe0cf3c","date":1492433195,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        return;\n      }\n      List<TriggerAction> actions = source.getActions();\n      if (actions != null) {\n        actionExecutor.submit(() -> {\n          for (TriggerAction action : actions) {\n            try {\n              action.process(event);\n            } catch (Exception e) {\n              log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, 1, TimeUnit.SECONDS);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e","date":1493894873,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        return;\n      }\n      List<TriggerAction> actions = source.getActions();\n      if (actions != null) {\n        actionExecutor.submit(() -> {\n          for (TriggerAction action : actions) {\n            try {\n              action.process(event);\n            } catch (Exception e) {\n              log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        return;\n      }\n      List<TriggerAction> actions = source.getActions();\n      if (actions != null) {\n        actionExecutor.submit(() -> {\n          for (TriggerAction action : actions) {\n            try {\n              action.process(event);\n            } catch (Exception e) {\n              log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, 1, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"009caa80830ac6369c42e5f6515405d686eabfee","date":1494487120,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            // let the action executor thread wait instead of the trigger thread so we use the throttle here\n            actionThrottle.minimumWaitBetweenActions();\n            actionThrottle.markAttemptingAction();\n            for (TriggerAction action : actions) {\n              try {\n                action.process(event);\n              } catch (Exception e) {\n                log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                throw e;\n              } finally {\n                hasPendingActions.set(false);\n              }\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        return;\n      }\n      List<TriggerAction> actions = source.getActions();\n      if (actions != null) {\n        actionExecutor.submit(() -> {\n          for (TriggerAction action : actions) {\n            try {\n              action.process(event);\n            } catch (Exception e) {\n              log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n              throw e;\n            }\n          }\n        });\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4","date":1494854992,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            // let the action executor thread wait instead of the trigger thread so we use the throttle here\n            actionThrottle.minimumWaitBetweenActions();\n            actionThrottle.markAttemptingAction();\n            for (TriggerAction action : actions) {\n              try {\n                action.process(event);\n              } catch (Exception e) {\n                log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                throw e;\n              } finally {\n                hasPendingActions.set(false);\n              }\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e031777d485b735e3c778cf426bcb1d0c269380","date":1495616906,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    List<TriggerAction> actions = newTrigger.getActions();\n    for (TriggerAction action : actions) {\n      action.init(newTrigger.getProperties());\n    }\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7de61de2203cc64cd0731761f6e5840f458de78","date":1495616938,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    List<TriggerAction> actions = newTrigger.getActions();\n    for (TriggerAction action : actions) {\n      action.init(newTrigger.getProperties());\n    }\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a2106de37ce630e891f2b29595bc3bfcef1918d","date":1495624585,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    List<TriggerAction> actions = newTrigger.getActions();\n    for (TriggerAction action : actions) {\n      action.init(newTrigger.getProperties());\n    }\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2f4717538692c396242d8b00ae0001626caebdd","date":1495700710,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    List<TriggerAction> actions = newTrigger.getActions();\n    for (TriggerAction action : actions) {\n      action.init(newTrigger.getProperties());\n    }\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"464244264804e3f981bf1fb4b732516d8d62dbc2","date":1495736161,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + event.getSource() + \" doesn't exist.\");\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5531f16a602ef350b6c9adfb08ebaa13a60fe3db","date":1495756318,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + event.getSource() + \" doesn't exist.\");\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      AutoScaling.Trigger source = event.getSource();\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f6b20dc453cee198956989b90aa24bef0232bcf","date":1498221066,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + event.getSource() + \" doesn't exist.\");\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + event.getSource() + \" doesn't exist.\");\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5fd294da67452cd8d116692194908de00eb5209","date":1499704155,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setListener(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + event.getSource() + \" doesn't exist.\");\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        log.warn(\"Ignoring autoscaling event \" + event + \" because the source trigger: \" + source + \" has already been closed\");\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25","date":1499961129,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, AutoScaling.EventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55ed5a78f8a4b37108ac73a894a105db562d303e","date":1500477652,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger;\n    try {\n      scheduledTrigger = new ScheduledTrigger(newTrigger, clusterDataProvider, queueStats);\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"exception creating scheduled trigger\", e);\n    }\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(clusterDataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger;\n    try {\n      scheduledTrigger = new ScheduledTrigger(newTrigger, clusterDataProvider, queueStats);\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"exception creating scheduled trigger\", e);\n    }\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(clusterDataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8cffee0b9c10b78bd087c71485b482217fe84f","date":1505950827,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77756a7cefd7252e43f3917f35bec375ecba87c6","date":1507183453,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st = null;\n    try {\n      st = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    } catch (Exception e) {\n      //TODO to decide what to do\n      log.error(\"Failed to add trigger\", e);\n      return;\n    }\n\n    ScheduledTrigger scheduledTrigger = st;\n\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":["eea9e11d9fa696e376130be17730c83cf154f592"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eea9e11d9fa696e376130be17730c83cf154f592","date":1507193128,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (!zkClient.isConnected() || zkClient.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from ZK\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st = null;\n    try {\n      st = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    } catch (Exception e) {\n      //TODO to decide what to do\n      log.error(\"Failed to add trigger\", e);\n      return;\n    }\n\n    ScheduledTrigger scheduledTrigger = st;\n\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":["77756a7cefd7252e43f3917f35bec375ecba87c6"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d7859b8e6a469429413db808a609e8468be14c03","date":1507222263,"type":3,"author":"tballison","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (!zkClient.isConnected() || zkClient.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from ZK\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, zkClient, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (!zkClient.isConnected() || zkClient.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from ZK\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (coreContainer.isShutDown()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(coreContainer, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67e503ef0f418bc92404ff5d55694087c23d48eb","date":1509025368,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  log.error(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                  throw e;\n                }\n                List<String> afterActions = (List<String>)actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } finally {\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15ba547dfc0dd0b670e678cb3db8e5d27c694420","date":1511865512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, dataProvider, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (dataProvider.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (dataProvider.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(dataProvider, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n  }\n\n","bugFix":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > System.nanoTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(System.nanoTime());\n              hasPendingActions.set(false);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, triggerDelay.get(), TimeUnit.SECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0054ae381912e45884d3005a00486ed92a0f4925","date":1514900316,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d5ef2a9b4062088bd74169faad5ae11897a6d77","date":1516279764,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // reject events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // let the action executor thread wait instead of the trigger thread so we use the throttle here\n              ActionThrottle actionThrottle = this.actionThrottle.get();\n              actionThrottle.minimumWaitBetweenActions();\n              actionThrottle.markAttemptingAction();\n\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3102a9c9032617766c43974e7ec8b7a3148fb91","date":1519273763,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c252a8291191876badb5f6235f62895d6e36b33e","date":1519309955,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1dec9417ffbde1f9d7317d78c151248cb8f6af88","date":1520019381,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8af24f206736d88373229e8c83ddb84a433e57f3","date":1520362563,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    ScheduledTrigger st;\n    try {\n      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    ScheduledTrigger scheduledTrigger = st;\n\n    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      scheduledTrigger.setReplay(false);\n      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = scheduledTrigger.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = scheduledTrigger.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = scheduledTrigger.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + scheduledTrigger.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTime();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTime());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","date":1522763990,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new Exception(\"Error executing action: \" + action.getName() + \" for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (Exception e) {\n              log.warn(\"Exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":["eea9e11d9fa696e376130be17730c83cf154f592"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7fb1186f5b61e0b74289e6786df8cbecfa471bc","date":1545308188,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger {} - closing or disconnected from data provider\", newTrigger.getName(), e);\n      } else {\n        log.error(\"Failed to add trigger {}\", newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: {}\", event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: {}\", event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: {}\", event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for {}\", event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"-- processing took {} ms for event id={}\",\n                  TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger \" + newTrigger.getName() + \" - closing or disconnected from data provider\", e);\n      } else {\n        log.error(\"Failed to add trigger \" + newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: \" + event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: \" + event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: \" + event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for \" + event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            log.debug(\"-- processing took {} ms for event id={}\",\n                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger {} - closing or disconnected from data provider\", newTrigger.getName(), e);\n      } else {\n        log.error(\"Failed to add trigger {}\", newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: {}\", event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: {}\", event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: {}\", event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for {}\", event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                @SuppressWarnings({\"unchecked\"})\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                @SuppressWarnings({\"unchecked\"})\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"-- processing took {} ms for event id={}\",\n                  TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger {} - closing or disconnected from data provider\", newTrigger.getName(), e);\n      } else {\n        log.error(\"Failed to add trigger {}\", newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: {}\", event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: {}\", event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: {}\", event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for {}\", event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"-- processing took {} ms for event id={}\",\n                  TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTriggers#add(AutoScaling.Trigger).mjava","sourceNew":null,"sourceOld":"  /**\n   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed\n   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this\n   * operation becomes a no-op.\n   *\n   * @param newTrigger the trigger to be managed\n   * @throws AlreadyClosedException if this class has already been closed\n   */\n  public synchronized void add(AutoScaling.Trigger newTrigger) throws Exception {\n    if (isClosed) {\n      throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n    }\n    TriggerWrapper st;\n    try {\n      st = new TriggerWrapper(newTrigger, cloudManager, queueStats);\n    } catch (Exception e) {\n      if (isClosed || e instanceof AlreadyClosedException) {\n        throw new AlreadyClosedException(\"ScheduledTriggers has been closed and cannot be used anymore\");\n      }\n      if (cloudManager.isClosed()) {\n        log.error(\"Failed to add trigger {} - closing or disconnected from data provider\", newTrigger.getName(), e);\n      } else {\n        log.error(\"Failed to add trigger {}\", newTrigger.getName(), e);\n      }\n      return;\n    }\n    TriggerWrapper triggerWrapper = st;\n\n    TriggerWrapper old = scheduledTriggerWrappers.putIfAbsent(newTrigger.getName(), triggerWrapper);\n    if (old != null) {\n      if (old.trigger.equals(newTrigger)) {\n        // the trigger wasn't actually modified so we do nothing\n        return;\n      }\n      IOUtils.closeQuietly(old);\n      newTrigger.restoreState(old.trigger);\n      triggerWrapper.setReplay(false);\n      scheduledTriggerWrappers.replace(newTrigger.getName(), triggerWrapper);\n    }\n    newTrigger.setProcessor(event -> {\n      TriggerListeners triggerListeners = listeners.copy();\n      if (cloudManager.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because Solr has been shutdown.\", event.toString());\n        log.warn(msg);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        return false;\n      }\n      TriggerWrapper scheduledSource = scheduledTriggerWrappers.get(event.getSource());\n      if (scheduledSource == null) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s doesn't exist.\", event.toString(), event.getSource());\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);\n        log.warn(msg);\n        return false;\n      }\n      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;\n      AutoScaling.Trigger source = scheduledSource.trigger;\n      if (scheduledSource.isClosed || source.isClosed()) {\n        String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s because the source trigger: %s has already been closed\", event.toString(), source);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n        log.warn(msg);\n        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n        return false;\n      }\n      if (event.isIgnored())  {\n        log.debug(\"-------- Ignoring event: {}\", event);\n        event.getProperties().put(TriggerEvent.IGNORED, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Event was ignored.\");\n        return true; // always return true for ignored events\n      }\n      // even though we pause all triggers during action execution there is a possibility that a trigger was already\n      // running at the time and would have already created an event so we reject such events during cooldown period\n      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTimeNs()) {\n        log.debug(\"-------- Cooldown period - rejecting event: {}\", event);\n        event.getProperties().put(TriggerEvent.COOLDOWN, true);\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"In cooldown period.\");\n        return false;\n      } else {\n        log.debug(\"++++++++ Cooldown inactive - processing event: {}\", event);\n        // start cooldown here to immediately reject other events\n        cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n      }\n      if (hasPendingActions.compareAndSet(false, true)) {\n        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition\n        pauseTriggers();\n\n        final boolean enqueued;\n        if (replaying) {\n          enqueued = false;\n        } else {\n          enqueued = triggerWrapper.enqueue(event);\n        }\n        // fire STARTED event listeners after enqueuing the event is successful\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);\n        List<TriggerAction> actions = source.getActions();\n        if (actions != null) {\n          if (actionExecutor.isShutdown()) {\n            String msg = String.format(Locale.ROOT, \"Ignoring autoscaling event %s from trigger %s because the executor has already been closed\", event.toString(), source);\n            triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);\n            log.warn(msg);\n            hasPendingActions.set(false);\n            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it\n            return false;\n          }\n          actionExecutor.submit(() -> {\n            assert hasPendingActions.get();\n            long eventProcessingStart = cloudManager.getTimeSource().getTimeNs();\n            TriggerListeners triggerListeners1 = triggerListeners.copy();\n            log.debug(\"-- processing actions for {}\", event);\n            try {\n              // in future, we could wait for pending tasks in a different thread and re-enqueue\n              // this event so that we continue processing other events and not block this action executor\n              waitForPendingTasks(newTrigger, actions);\n\n              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());\n              for (TriggerAction action : actions) {\n                @SuppressWarnings({\"unchecked\"})\n                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());\n                beforeActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);\n                try {\n                  action.process(event, actionContext);\n                } catch (Exception e) {\n                  triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);\n                  throw new TriggerActionException(event.getSource(), action.getName(), \"Error processing action for trigger event: \" + event, e);\n                }\n                @SuppressWarnings({\"unchecked\"})\n                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());\n                afterActions.add(action.getName());\n                triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);\n              }\n              if (enqueued) {\n                TriggerEvent ev = triggerWrapper.dequeue();\n                assert ev.getId().equals(event.getId());\n              }\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n            } catch (TriggerActionException e) {\n              log.warn(\"Exception executing actions\", e);\n            } catch (Exception e) {\n              triggerListeners1.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED);\n              log.warn(\"Unhandled exception executing actions\", e);\n            } finally {\n              // update cooldown to the time when we actually finished processing the actions\n              cooldownStart.set(cloudManager.getTimeSource().getTimeNs());\n              hasPendingActions.set(false);\n              // resume triggers after cool down period\n              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));\n            }\n            if (log.isDebugEnabled()) {\n              log.debug(\"-- processing took {} ms for event id={}\",\n                  TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTimeNs() - eventProcessingStart), event.id);\n            }\n          });\n        } else {\n          if (enqueued) {\n            TriggerEvent ev = triggerWrapper.dequeue();\n            if (!ev.getId().equals(event.getId())) {\n              throw new RuntimeException(\"Wrong event dequeued, queue of \" + triggerWrapper.trigger.getName()\n              + \" is broken! Expected event=\" + event + \" but got \" + ev);\n            }\n          }\n          triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);\n          hasPendingActions.set(false);\n          // resume triggers now\n          resumeTriggers(0);\n        }\n        return true;\n      } else {\n        log.debug(\"Ignoring event {}, already processing other actions.\", event.id);\n        // there is an action in the queue and we don't want to enqueue another until it is complete\n        triggerListeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, \"Already processing another event.\");\n        return false;\n      }\n    });\n    newTrigger.init(); // mark as ready for scheduling\n    triggerWrapper.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(triggerWrapper, 0,\n        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),\n        TimeUnit.MILLISECONDS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","0d5ef2a9b4062088bd74169faad5ae11897a6d77"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5b8cffee0b9c10b78bd087c71485b482217fe84f"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"77756a7cefd7252e43f3917f35bec375ecba87c6":["560c18d71dad43d675158783c3840f8c80d6d39c"],"8af24f206736d88373229e8c83ddb84a433e57f3":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"e2f4717538692c396242d8b00ae0001626caebdd":["e7de61de2203cc64cd0731761f6e5840f458de78","7a2106de37ce630e891f2b29595bc3bfcef1918d"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["c5fd294da67452cd8d116692194908de00eb5209"],"1e031777d485b735e3c778cf426bcb1d0c269380":["2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4"],"1dec9417ffbde1f9d7317d78c151248cb8f6af88":["c252a8291191876badb5f6235f62895d6e36b33e"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"7a2106de37ce630e891f2b29595bc3bfcef1918d":["e7de61de2203cc64cd0731761f6e5840f458de78"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["67e503ef0f418bc92404ff5d55694087c23d48eb","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"009caa80830ac6369c42e5f6515405d686eabfee":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"c252a8291191876badb5f6235f62895d6e36b33e":["d3102a9c9032617766c43974e7ec8b7a3148fb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["9c6c0dad4932399aec99b4818086cb1772773916"],"0054ae381912e45884d3005a00486ed92a0f4925":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"d3102a9c9032617766c43974e7ec8b7a3148fb91":["b94236357aaa22b76c10629851fe4e376e0cea82"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["55ed5a78f8a4b37108ac73a894a105db562d303e"],"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"d7859b8e6a469429413db808a609e8468be14c03":["560c18d71dad43d675158783c3840f8c80d6d39c","eea9e11d9fa696e376130be17730c83cf154f592"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["eea9e11d9fa696e376130be17730c83cf154f592"],"eea9e11d9fa696e376130be17730c83cf154f592":["77756a7cefd7252e43f3917f35bec375ecba87c6"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09"],"9c6c0dad4932399aec99b4818086cb1772773916":["8af24f206736d88373229e8c83ddb84a433e57f3"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"55ed5a78f8a4b37108ac73a894a105db562d303e":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"e7de61de2203cc64cd0731761f6e5840f458de78":["2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4","1e031777d485b735e3c778cf426bcb1d0c269380"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["e2f4717538692c396242d8b00ae0001626caebdd","464244264804e3f981bf1fb4b732516d8d62dbc2"],"67e503ef0f418bc92404ff5d55694087c23d48eb":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"c5fd294da67452cd8d116692194908de00eb5209":["1f6b20dc453cee198956989b90aa24bef0232bcf"],"0d5ef2a9b4062088bd74169faad5ae11897a6d77":["0054ae381912e45884d3005a00486ed92a0f4925"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["e35f2dde06b35aa9904949a3a93fabd090371077"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4":["009caa80830ac6369c42e5f6515405d686eabfee"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["e2f4717538692c396242d8b00ae0001626caebdd"],"e35f2dde06b35aa9904949a3a93fabd090371077":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["d3102a9c9032617766c43974e7ec8b7a3148fb91"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"a7699e9ae4550ba2a55335a64ae7de9d5d9de39e":["009caa80830ac6369c42e5f6515405d686eabfee"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"77756a7cefd7252e43f3917f35bec375ecba87c6":["eea9e11d9fa696e376130be17730c83cf154f592"],"8af24f206736d88373229e8c83ddb84a433e57f3":["9c6c0dad4932399aec99b4818086cb1772773916"],"e2f4717538692c396242d8b00ae0001626caebdd":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","464244264804e3f981bf1fb4b732516d8d62dbc2"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["55ed5a78f8a4b37108ac73a894a105db562d303e"],"1e031777d485b735e3c778cf426bcb1d0c269380":["e7de61de2203cc64cd0731761f6e5840f458de78"],"1dec9417ffbde1f9d7317d78c151248cb8f6af88":["8af24f206736d88373229e8c83ddb84a433e57f3"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7a2106de37ce630e891f2b29595bc3bfcef1918d":["e2f4717538692c396242d8b00ae0001626caebdd"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["e35f2dde06b35aa9904949a3a93fabd090371077"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"009caa80830ac6369c42e5f6515405d686eabfee":["2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4"],"c252a8291191876badb5f6235f62895d6e36b33e":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c","6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09","326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"0054ae381912e45884d3005a00486ed92a0f4925":["0d5ef2a9b4062088bd74169faad5ae11897a6d77"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","0054ae381912e45884d3005a00486ed92a0f4925"],"560c18d71dad43d675158783c3840f8c80d6d39c":["77756a7cefd7252e43f3917f35bec375ecba87c6","d7859b8e6a469429413db808a609e8468be14c03"],"d3102a9c9032617766c43974e7ec8b7a3148fb91":["c252a8291191876badb5f6235f62895d6e36b33e"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"6ca81a50d0a6c6f97f1e2b15ef90c5bd81765d09":["326b5c746af092eb827c5c1accdab1b47fe0cf3c"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d7859b8e6a469429413db808a609e8468be14c03":[],"eea9e11d9fa696e376130be17730c83cf154f592":["d7859b8e6a469429413db808a609e8468be14c03","85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["5b8cffee0b9c10b78bd087c71485b482217fe84f"],"326b5c746af092eb827c5c1accdab1b47fe0cf3c":["a7699e9ae4550ba2a55335a64ae7de9d5d9de39e"],"9c6c0dad4932399aec99b4818086cb1772773916":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"55ed5a78f8a4b37108ac73a894a105db562d303e":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"e7de61de2203cc64cd0731761f6e5840f458de78":["e2f4717538692c396242d8b00ae0001626caebdd","7a2106de37ce630e891f2b29595bc3bfcef1918d"],"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["1f6b20dc453cee198956989b90aa24bef0232bcf"],"0d5ef2a9b4062088bd74169faad5ae11897a6d77":["b94236357aaa22b76c10629851fe4e376e0cea82"],"c5fd294da67452cd8d116692194908de00eb5209":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"67e503ef0f418bc92404ff5d55694087c23d48eb":["1aad05eeff7818b0833c02ac6b743aa72054963b","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"2421a6ea53a5f819d1e8a23b70ef2b882b0bb8c4":["1e031777d485b735e3c778cf426bcb1d0c269380","e7de61de2203cc64cd0731761f6e5840f458de78"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["3f504512a03d978990cbff30db0522b354e846db"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"e35f2dde06b35aa9904949a3a93fabd090371077":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["c5fd294da67452cd8d116692194908de00eb5209"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d7859b8e6a469429413db808a609e8468be14c03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}