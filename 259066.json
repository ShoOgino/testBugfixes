{"path":"solr/core/src/test/org/apache/solr/update/processor/DimensionalRoutedAliasUpdateProcessorTest#assertCatTimeInvariants(String[],String[]).mjava","commits":[{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/DimensionalRoutedAliasUpdateProcessorTest#assertCatTimeInvariants(String[],String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test for invariant conditions when dealing with a DRA that is category X time.\n   *\n   * @param expectedCols the collections we expect to see\n   * @param categories   the categories added thus far\n   */\n  private void assertCatTimeInvariants(String[] expectedCols, String[] categories) throws Exception {\n    final int expectNumFound = lastDocId - numDocsDeletedOrFailed; //lastDocId is effectively # generated docs\n    int totalNumFound = 0;\n\n    final List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(getSaferTestName());\n    assert !cols.isEmpty();\n\n    for (String category : categories) {\n      List<String> cats = cols.stream().filter(c -> c.contains(category)).collect(Collectors.toList());\n      Object[] expectedColOrder = cats.stream().sorted(Collections.reverseOrder()).toArray();\n      Object[] actuals = cats.toArray();\n      assertArrayEquals(\"expected reverse sorted\",\n          expectedColOrder,\n          actuals);\n\n      Instant colEndInstant = null; // exclusive end\n\n      for (String col : cats) { // ASSUMPTION: reverse sorted order\n        Instant colStartInstant;\n        try {\n          colStartInstant = TimeRoutedAlias.parseInstantFromCollectionName(getAlias(), col);\n        } catch (Exception e) {\n          String colTmp = col;\n          // special case for tests... all of which have no more than one TRA dimension\n          // This won't work if we decide to write a test with 2 time dimensions.\n          // (but that's an odd case so we'll wait)\n          int traIndex = colTmp.indexOf(TRA)+ TRA.length();\n          while (colTmp.lastIndexOf(\"__\") > traIndex) {\n            colTmp = colTmp.substring(0,colTmp.lastIndexOf(\"__\"));\n          }\n          colStartInstant = TimeRoutedAlias.parseInstantFromCollectionName(getAlias(), colTmp);\n        }\n        final QueryResponse colStatsResp = solrClient.query(col, params(\n            \"q\", \"*:*\",\n            \"fq\", catField + \":\" + category,\n            \"rows\", \"0\",\n            \"stats\", \"true\",\n            \"stats.field\", getTimeField()));\n        long numFound = colStatsResp.getResults().getNumFound();\n        if (numFound > 0) {\n          totalNumFound += numFound;\n          final FieldStatsInfo timestampStats = colStatsResp.getFieldStatsInfo().get(getTimeField());\n          assertTrue(colStartInstant.toEpochMilli() <= ((Date) timestampStats.getMin()).getTime());\n          if (colEndInstant != null) {\n            assertTrue(colEndInstant.toEpochMilli() > ((Date) timestampStats.getMax()).getTime());\n          }\n        }\n\n        colEndInstant = colStartInstant; // next older segment will max out at our current start time\n      }\n\n    }\n\n    assertEquals(expectNumFound, totalNumFound);\n\n    assertEquals(\"COLS FOUND:\" + cols, expectedCols.length, cols.size());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}