{"path":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","commits":[{"id":"5a07ca455ec3f405a6078602f3f3dcf2d4fa8679","date":1310042027,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"/dev/null","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for(IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers.size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts, true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(perDocProducers\n            .toArray(PerDocValues.EMPTY_ARRAY), perDocSlices\n            .toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n      } finally {\n        docsConsumer.close();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c61ee18b40abd78015c77a335ad05ff77899a8d0","date":1310043002,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    try {\n      for(IndexReader r : readers) {\n        final int maxDoc = r.maxDoc();\n        final PerDocValues producer = r.perDocValues();\n        if (producer != null) {\n          perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers.size()));\n          perDocProducers.add(producer);\n          perDocBits.add(r.getLiveDocs());\n          perDocBitsStarts.add(docBase);\n        }\n        docBase += maxDoc;\n      }\n      perDocBitsStarts.add(docBase);\n      if (!perDocSlices.isEmpty()) {\n        mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts, true);\n        final PerDocConsumer docsConsumer = codec\n            .docsConsumer(new PerDocWriteState(segmentWriteState));\n        boolean success = false;\n        try {\n          final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(perDocProducers\n              .toArray(PerDocValues.EMPTY_ARRAY), perDocSlices\n              .toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n          docsConsumer.merge(mergeState, multiPerDocValues);\n          success = true;\n        } finally {\n          IOUtils.closeSafely(!success, docsConsumer);\n        }\n      }\n    } finally {\n      IOUtils.closeSafely(false, perDocProducers);\n    }\n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for(IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers.size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts, true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(perDocProducers\n            .toArray(PerDocValues.EMPTY_ARRAY), perDocSlices\n            .toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n      } finally {\n        docsConsumer.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"250aaf3b513c8a8e6652869848450d9cf4a94302","date":1310050111,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts,\n          true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    try {\n      for(IndexReader r : readers) {\n        final int maxDoc = r.maxDoc();\n        final PerDocValues producer = r.perDocValues();\n        if (producer != null) {\n          perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers.size()));\n          perDocProducers.add(producer);\n          perDocBits.add(r.getLiveDocs());\n          perDocBitsStarts.add(docBase);\n        }\n        docBase += maxDoc;\n      }\n      perDocBitsStarts.add(docBase);\n      if (!perDocSlices.isEmpty()) {\n        mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts, true);\n        final PerDocConsumer docsConsumer = codec\n            .docsConsumer(new PerDocWriteState(segmentWriteState));\n        boolean success = false;\n        try {\n          final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(perDocProducers\n              .toArray(PerDocValues.EMPTY_ARRAY), perDocSlices\n              .toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n          docsConsumer.merge(mergeState, multiPerDocValues);\n          success = true;\n        } finally {\n          IOUtils.closeSafely(!success, docsConsumer);\n        }\n      }\n    } finally {\n      IOUtils.closeSafely(false, perDocProducers);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"/dev/null","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts,\n          true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"/dev/null","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts,\n          true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d53e0e0de54796610619b32f911e89d9fb752c4c","date":1310918942,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      mergeState.multiLiveDocs = new MultiBits(perDocBits, perDocBitsStarts,\n          true);\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    int docBase = 0;\n    for (MergeState.IndexReaderAndLiveDocs r : readers) {\n      final int maxDoc = r.reader.maxDoc();\n      final PerDocValues producer = r.reader.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n      }\n      docBase += maxDoc;\n    }\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    final List<Bits> perDocBits = new ArrayList<Bits>();\n    final List<Integer> perDocBitsStarts = new ArrayList<Integer>();\n    int docBase = 0;\n    for (IndexReader r : readers) {\n      final int maxDoc = r.maxDoc();\n      final PerDocValues producer = r.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n        perDocBits.add(r.getLiveDocs());\n        perDocBitsStarts.add(docBase);\n      }\n      docBase += maxDoc;\n    }\n    perDocBitsStarts.add(docBase);\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24230fe54121f9be9d85f2c2067536296785e421","date":1314462346,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    int docBase = 0;\n    for (MergeState.IndexReaderAndLiveDocs r : readers) {\n      final int maxDoc = r.reader.maxDoc();\n      final PerDocValues producer = r.reader.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n      }\n      docBase += maxDoc;\n    }\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    int docBase = 0;\n    for (MergeState.IndexReaderAndLiveDocs r : readers) {\n      final int maxDoc = r.reader.maxDoc();\n      final PerDocValues producer = r.reader.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n      }\n      docBase += maxDoc;\n    }\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        IOUtils.closeSafely(!success, docsConsumer);\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4","date":1318260487,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n    final List<PerDocValues> perDocProducers = new ArrayList<PerDocValues>();    \n    final List<ReaderUtil.Slice> perDocSlices = new ArrayList<ReaderUtil.Slice>();\n    int docBase = 0;\n    for (MergeState.IndexReaderAndLiveDocs r : readers) {\n      final int maxDoc = r.reader.maxDoc();\n      final PerDocValues producer = r.reader.perDocValues();\n      if (producer != null) {\n        perDocSlices.add(new ReaderUtil.Slice(docBase, maxDoc, perDocProducers\n            .size()));\n        perDocProducers.add(producer);\n      }\n      docBase += maxDoc;\n    }\n    if (!perDocSlices.isEmpty()) {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        final MultiPerDocValues multiPerDocValues = new MultiPerDocValues(\n            perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),\n            perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n        docsConsumer.merge(mergeState, multiPerDocValues);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n    }\n    /* don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f458fcb817a740e7906774b7ca2c54d37b34f24f","date":1319501743,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      // TODO: remove this check when 3.x indexes are no longer supported\n      // (3.x indexes don't have docvalues)\n      if (docsConsumer == null) {\n        return;\n      }\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec.docValuesFormat()\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      // TODO: remove this check when 3.x indexes are no longer supported\n      // (3.x indexes don't have docvalues)\n      if (docsConsumer == null) {\n        return;\n      }\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      // TODO: remove this check when 3.x indexes are no longer supported\n      // (3.x indexes don't have docvalues)\n      if (docsConsumer == null) {\n        return;\n      }\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergePerDoc().mjava","sourceNew":"  private void mergePerDoc(SegmentWriteState segmentWriteState) throws IOException {\n      final PerDocConsumer docsConsumer = codec.docValuesFormat()\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      // TODO: remove this check when 3.x indexes are no longer supported\n      // (3.x indexes don't have docvalues)\n      if (docsConsumer == null) {\n        return;\n      }\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","sourceOld":"  private void mergePerDoc() throws IOException {\n      final PerDocConsumer docsConsumer = codec.docValuesFormat()\n          .docsConsumer(new PerDocWriteState(segmentWriteState));\n      // TODO: remove this check when 3.x indexes are no longer supported\n      // (3.x indexes don't have docvalues)\n      if (docsConsumer == null) {\n        return;\n      }\n      boolean success = false;\n      try {\n        docsConsumer.merge(mergeState);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(docsConsumer);\n        } else {\n          IOUtils.closeWhileHandlingException(docsConsumer);\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"24230fe54121f9be9d85f2c2067536296785e421":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["d53e0e0de54796610619b32f911e89d9fb752c4c"],"d53e0e0de54796610619b32f911e89d9fb752c4c":["250aaf3b513c8a8e6652869848450d9cf4a94302"],"06584e6e98d592b34e1329b384182f368d2025e8":["7b91922b55d15444d554721b352861d028eb8278"],"7b91922b55d15444d554721b352861d028eb8278":["f458fcb817a740e7906774b7ca2c54d37b34f24f"],"1291e4568eb7d9463d751627596ef14baf4c1603":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","250aaf3b513c8a8e6652869848450d9cf4a94302"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","250aaf3b513c8a8e6652869848450d9cf4a94302"],"f458fcb817a740e7906774b7ca2c54d37b34f24f":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a07ca455ec3f405a6078602f3f3dcf2d4fa8679":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c61ee18b40abd78015c77a335ad05ff77899a8d0":["5a07ca455ec3f405a6078602f3f3dcf2d4fa8679"],"250aaf3b513c8a8e6652869848450d9cf4a94302":["c61ee18b40abd78015c77a335ad05ff77899a8d0"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["24230fe54121f9be9d85f2c2067536296785e421"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06584e6e98d592b34e1329b384182f368d2025e8"]},"commit2Childs":{"24230fe54121f9be9d85f2c2067536296785e421":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["24230fe54121f9be9d85f2c2067536296785e421"],"d53e0e0de54796610619b32f911e89d9fb752c4c":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"06584e6e98d592b34e1329b384182f368d2025e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7b91922b55d15444d554721b352861d028eb8278":["06584e6e98d592b34e1329b384182f368d2025e8"],"1291e4568eb7d9463d751627596ef14baf4c1603":[],"f0b9507caf22f292ac0e5e59f62db4275adf4511":[],"f458fcb817a740e7906774b7ca2c54d37b34f24f":["7b91922b55d15444d554721b352861d028eb8278"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","5a07ca455ec3f405a6078602f3f3dcf2d4fa8679"],"5a07ca455ec3f405a6078602f3f3dcf2d4fa8679":["c61ee18b40abd78015c77a335ad05ff77899a8d0"],"c61ee18b40abd78015c77a335ad05ff77899a8d0":["250aaf3b513c8a8e6652869848450d9cf4a94302"],"250aaf3b513c8a8e6652869848450d9cf4a94302":["d53e0e0de54796610619b32f911e89d9fb752c4c","1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["f458fcb817a740e7906774b7ca2c54d37b34f24f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}