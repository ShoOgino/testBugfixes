{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"/dev/null","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"/dev/null","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5048c558f8802f1689d38203111379406b171418","date":1486467652,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e11e54ce6015434b2aaadb49ca5071dbe7be50c","date":1489404389,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    \n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0","date":1490749780,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08807474e48bac766abf10459c3c25e4a5e4d7cc","date":1490873946,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":["5048c558f8802f1689d38203111379406b171418","415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderUpdatesIndividualReplicaTest().mjava","sourceNew":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Issuing well ordered update: {}\", update.getDocuments());\n      }\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      if (log.isInfoEnabled()) {\n        log.info(\"Testing client: {}\", ((HttpSolrClient) client).getBaseURL());\n      }\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","sourceOld":"  private void outOfOrderUpdatesIndividualReplicaTest() throws Exception {\n    clearIndex();\n    commit();\n\n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    for (int i=1; i<atLeast(3); i++) {\n      updates.add(simulatedUpdateRequest(version0 + i, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + i, \"_version_\", version0 + i + 1));\n    }\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads, since some of these updates will\n    // be blocking calls, waiting for some previous updates to arrive on which it depends.\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, r);\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n\n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      log.info(\"Testing client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"inplace_updatable_float\", (newinplace_updatable_float + (float)(updates.size() - 1)), \n          \"inplace_updatable_float didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertReplicaValue(client, 0, \"title_s\", \"title0_new\", \n          \"Title didn't match for replica at client: \" + ((HttpSolrClient)client).getBaseURL());\n      assertEquals(version0 + updates.size(), getReplicaValue(client, 0, \"_version_\"));\n    }\n\n    log.info(\"outOfOrderUpdatesIndividualReplicaTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["be320990bdc77e643388fa801e75017f19289c42"],"5048c558f8802f1689d38203111379406b171418":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":["ab68488225b6a6c357dda72ed11dedca9914a192"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["5048c558f8802f1689d38203111379406b171418"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"be320990bdc77e643388fa801e75017f19289c42":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"ab68488225b6a6c357dda72ed11dedca9914a192":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","5048c558f8802f1689d38203111379406b171418"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"5048c558f8802f1689d38203111379406b171418":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"be320990bdc77e643388fa801e75017f19289c42":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"ab68488225b6a6c357dda72ed11dedca9914a192":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","08807474e48bac766abf10459c3c25e4a5e4d7cc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}