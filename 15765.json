{"path":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","commits":[{"id":"1936b95f78af7bc57e67df5b0de3f21a54df10af","date":1420842770,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(\",\", loaders));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d94deac68514af4c985eabd56d9bb95ce27467b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8","date":1421575379,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(\",\", loaders));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(\",\", loaders));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":["d94deac68514af4c985eabd56d9bb95ce27467b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f53aceda5e047338a4c5ad7094ba589263b94f59","date":1421787179,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(loaders,','));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(\",\", loaders));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78956d805239de32e544cb115d4bcccbddbe4409","date":1440548118,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(loaders,','));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(loaders,','));\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":["d94deac68514af4c985eabd56d9bb95ce27467b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ac6494315d04f68950d2f00f5436b4861bcd467","date":1553125039,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, StringUtils.join(loaders,','));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ada1d1c1521680f2ede5f2a7e78c69f077b6caa6","date":1553522324,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // route all Velocity logging through Solr's logging facility\n    engine.setProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM, velocityLogger);\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9907d9700d3bc9287f928dbea44ab9e28f70470a","date":1553722975,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // Work around VELOCITY-908 with Velocity not handling locales properly\n    Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n    if(spaceGobblingInitProperty != null) {\n      // If there is an init property, uppercase it before Velocity.\n      velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n          String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n    } else {\n      // Fallback to checking if the engine default property is set and if not make it a reasonable default.\n      Object spaceGobblingEngineProperty = engine.getProperty(RuntimeConstants.SPACE_GOBBLING);\n      if(spaceGobblingEngineProperty == null) {\n        engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n      }\n    }\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":["d94deac68514af4c985eabd56d9bb95ce27467b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d94deac68514af4c985eabd56d9bb95ce27467b9","date":1576085774,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n\n    boolean trustedMode = request.getCore().getCoreDescriptor().isConfigSetTrusted();\n\n\n    VelocityEngine engine = new VelocityEngine();\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is `[file,][solr],builtin` intentionally ordered in this manner.\n      The \"file\" resource loader, enabled when the configset is trusted and `template.base.dir` is specified as a\n      response writer init property.\n\n      The \"solr\" resource loader, enabled when the configset is trusted, and provides templates from a velocity/\n      sub-tree in either the classpath or under conf/.\n\n      By default, only \"builtin\" resource loader is enabled, providing tenplates from builtin Solr .jar files.\n\n      The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory, or within a trusted configset's velocity/ directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if ((fileResourceLoaderBaseDir != null) && trustedMode) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (trustedMode) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n    engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n\n    // install a class/package restricting uberspector\n    engine.setProperty(RuntimeConstants.UBERSPECT_CLASSNAME,\"org.apache.velocity.util.introspection.SecureUberspector\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_PACKAGES,\"java.lang.reflect\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Class\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ClassLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Compiler\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.InheritableThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Package\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Process\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Runtime\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.RuntimePermission\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.SecurityManager\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.System\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Thread\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadGroup\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.SolrResourceLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.CoreContainer\");\n\n    if (trustedMode) {\n      // Work around VELOCITY-908 with Velocity not handling locales properly\n      Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n      if (spaceGobblingInitProperty != null) {\n        // If there is an init property, uppercase it before Velocity.\n        velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n            String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n      }\n      // bring in any custom properties too\n      engine.setProperties(velocityInitProps);\n    }\n\n    engine.init();\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // Work around VELOCITY-908 with Velocity not handling locales properly\n    Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n    if(spaceGobblingInitProperty != null) {\n      // If there is an init property, uppercase it before Velocity.\n      velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n          String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n    } else {\n      // Fallback to checking if the engine default property is set and if not make it a reasonable default.\n      Object spaceGobblingEngineProperty = engine.getProperty(RuntimeConstants.SPACE_GOBBLING);\n      if(spaceGobblingEngineProperty == null) {\n        engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n      }\n    }\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":["9907d9700d3bc9287f928dbea44ab9e28f70470a","1936b95f78af7bc57e67df5b0de3f21a54df10af","78956d805239de32e544cb115d4bcccbddbe4409","2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n\n    boolean trustedMode = request.getCore().getCoreDescriptor().isConfigSetTrusted();\n\n\n    VelocityEngine engine = new VelocityEngine();\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is `[file,][solr],builtin` intentionally ordered in this manner.\n      The \"file\" resource loader, enabled when the configset is trusted and `template.base.dir` is specified as a\n      response writer init property.\n\n      The \"solr\" resource loader, enabled when the configset is trusted, and provides templates from a velocity/\n      sub-tree in either the classpath or under conf/.\n\n      By default, only \"builtin\" resource loader is enabled, providing tenplates from builtin Solr .jar files.\n\n      The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory, or within a trusted configset's velocity/ directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if ((fileResourceLoaderBaseDir != null) && trustedMode) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (trustedMode) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n    engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n\n    // install a class/package restricting uberspector\n    engine.setProperty(RuntimeConstants.UBERSPECT_CLASSNAME,\"org.apache.velocity.util.introspection.SecureUberspector\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_PACKAGES,\"java.lang.reflect\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Class\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ClassLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Compiler\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.InheritableThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Package\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Process\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Runtime\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.RuntimePermission\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.SecurityManager\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.System\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Thread\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadGroup\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.SolrResourceLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.CoreContainer\");\n\n    if (trustedMode) {\n      // Work around VELOCITY-908 with Velocity not handling locales properly\n      Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n      if (spaceGobblingInitProperty != null) {\n        // If there is an init property, uppercase it before Velocity.\n        velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n            String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n      }\n      // bring in any custom properties too\n      engine.setProperties(velocityInitProps);\n    }\n\n    engine.init();\n\n    return engine;\n  }\n\n","sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n    VelocityEngine engine = new VelocityEngine();\n\n    // Set some engine properties that improve the experience\n    //   - these could be considered in the future for parameterization, but can also be overridden by using\n    //     the init.properties.file setting.  (TODO: add a test for this properties set here overridden)\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is [params,][file,][solr], intentionally ordered in this manner, and each\n      one optional and individually enable-able.  By default, only \"solr\" (resource loader) is used, parsing templates\n      from a velocity/ sub-tree in either the classpath or under conf/.\n\n      A common usage would be to enable the file template loader, keeping the solr loader enabled; the Velocity resource\n      loader path would then be \"file,solr\" (params is disabled by default).  The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if (paramsResourceLoaderEnabled) {\n      loaders.add(\"params\");\n      engine.setProperty(\"params.resource.loader.instance\", new SolrParamResourceLoader(request));\n    }\n    if (fileResourceLoaderBaseDir != null) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (solrResourceLoaderEnabled) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n\n    // Work around VELOCITY-908 with Velocity not handling locales properly\n    Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n    if(spaceGobblingInitProperty != null) {\n      // If there is an init property, uppercase it before Velocity.\n      velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n          String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n    } else {\n      // Fallback to checking if the engine default property is set and if not make it a reasonable default.\n      Object spaceGobblingEngineProperty = engine.getProperty(RuntimeConstants.SPACE_GOBBLING);\n      if(spaceGobblingEngineProperty == null) {\n        engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n      }\n    }\n\n    // bring in any custom properties too\n    engine.init(velocityInitProps);\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b659435fdb2401d91fa87bb3df798ae41a8046cd","date":1600346713,"type":4,"author":"Erik Hatcher","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/velocity/src/java/org/apache/solr/response/VelocityResponseWriter#createEngine(SolrQueryRequest).mjava","sourceNew":null,"sourceOld":"  private VelocityEngine createEngine(SolrQueryRequest request) {\n\n    boolean trustedMode = request.getCore().getCoreDescriptor().isConfigSetTrusted();\n\n\n    VelocityEngine engine = new VelocityEngine();\n\n    // load the built-in _macros.vm first, then load VM_global_library.vm for legacy (pre-5.0) support,\n    // and finally allow macros.vm to have the final say and override anything defined in the preceding files.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY, \"_macros.vm,VM_global_library.vm,macros.vm\");\n\n    // Standard templates autoload, but not the macro one(s), by default, so let's just make life\n    // easier, and consistent, for macro development too.\n    engine.setProperty(RuntimeConstants.VM_LIBRARY_AUTORELOAD, \"true\");\n\n    /*\n      Set up Velocity resource loader(s)\n       terminology note: \"resource loader\" is overloaded here, there is Solr's resource loader facility for plugins,\n       and there are Velocity template resource loaders.  It's confusing, they overlap: there is a Velocity resource\n       loader that loads templates from Solr's resource loader (SolrVelocityResourceLoader).\n\n      The Velocity resource loader order is `[file,][solr],builtin` intentionally ordered in this manner.\n      The \"file\" resource loader, enabled when the configset is trusted and `template.base.dir` is specified as a\n      response writer init property.\n\n      The \"solr\" resource loader, enabled when the configset is trusted, and provides templates from a velocity/\n      sub-tree in either the classpath or under conf/.\n\n      By default, only \"builtin\" resource loader is enabled, providing tenplates from builtin Solr .jar files.\n\n      The basic browse templates are built into\n      this plugin, but can be individually overridden by placing a same-named template in the template.base.dir specified\n      directory, or within a trusted configset's velocity/ directory.\n     */\n    ArrayList<String> loaders = new ArrayList<String>();\n    if ((fileResourceLoaderBaseDir != null) && trustedMode) {\n      loaders.add(\"file\");\n      engine.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, fileResourceLoaderBaseDir.getAbsolutePath());\n    }\n    if (trustedMode) {\n      // The solr resource loader serves templates under a velocity/ subtree from <lib>, conf/,\n      // or SolrCloud's configuration tree.  Or rather the other way around, other resource loaders are rooted\n      // from the top, whereas this is velocity/ sub-tree rooted.\n      loaders.add(\"solr\");\n      engine.setProperty(\"solr.resource.loader.instance\", new SolrVelocityResourceLoader(request.getCore().getSolrConfig().getResourceLoader()));\n    }\n\n    // Always have the built-in classpath loader.  This is needed when using VM_LIBRARY macros, as they are required\n    // to be present if specified, and we want to have a nice macros facility built-in for users to use easily, and to\n    // extend in custom ways.\n    loaders.add(\"builtin\");\n    engine.setProperty(\"builtin.resource.loader.instance\", new ClasspathResourceLoader());\n\n    engine.setProperty(RuntimeConstants.RESOURCE_LOADER, String.join(\",\", loaders));\n\n\n    engine.setProperty(RuntimeConstants.INPUT_ENCODING, \"UTF-8\");\n    engine.setProperty(RuntimeConstants.SPACE_GOBBLING, RuntimeConstants.SpaceGobbling.LINES.toString());\n\n    // install a class/package restricting uberspector\n    engine.setProperty(RuntimeConstants.UBERSPECT_CLASSNAME,\"org.apache.velocity.util.introspection.SecureUberspector\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_PACKAGES,\"java.lang.reflect\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Class\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ClassLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Compiler\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.InheritableThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Package\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Process\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Runtime\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.RuntimePermission\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.SecurityManager\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.System\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.Thread\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadGroup\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"java.lang.ThreadLocal\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.SolrResourceLoader\");\n    engine.addProperty(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES,\"org.apache.solr.core.CoreContainer\");\n\n    if (trustedMode) {\n      // Work around VELOCITY-908 with Velocity not handling locales properly\n      Object spaceGobblingInitProperty = velocityInitProps.get(RuntimeConstants.SPACE_GOBBLING);\n      if (spaceGobblingInitProperty != null) {\n        // If there is an init property, uppercase it before Velocity.\n        velocityInitProps.put(RuntimeConstants.SPACE_GOBBLING,\n            String.valueOf(spaceGobblingInitProperty).toUpperCase(Locale.ROOT));\n      }\n      // bring in any custom properties too\n      engine.setProperties(velocityInitProps);\n    }\n\n    engine.init();\n\n    return engine;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1936b95f78af7bc57e67df5b0de3f21a54df10af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"df724d84dab24a0cc54bec95a8680867adc7f171":["9907d9700d3bc9287f928dbea44ab9e28f70470a","d94deac68514af4c985eabd56d9bb95ce27467b9"],"f53aceda5e047338a4c5ad7094ba589263b94f59":["2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["78956d805239de32e544cb115d4bcccbddbe4409"],"2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8":["1936b95f78af7bc57e67df5b0de3f21a54df10af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b659435fdb2401d91fa87bb3df798ae41a8046cd":["d94deac68514af4c985eabd56d9bb95ce27467b9"],"d94deac68514af4c985eabd56d9bb95ce27467b9":["9907d9700d3bc9287f928dbea44ab9e28f70470a"],"ada1d1c1521680f2ede5f2a7e78c69f077b6caa6":["0ac6494315d04f68950d2f00f5436b4861bcd467"],"9907d9700d3bc9287f928dbea44ab9e28f70470a":["ada1d1c1521680f2ede5f2a7e78c69f077b6caa6"],"78956d805239de32e544cb115d4bcccbddbe4409":["f53aceda5e047338a4c5ad7094ba589263b94f59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b659435fdb2401d91fa87bb3df798ae41a8046cd"]},"commit2Childs":{"1936b95f78af7bc57e67df5b0de3f21a54df10af":["2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"f53aceda5e047338a4c5ad7094ba589263b94f59":["78956d805239de32e544cb115d4bcccbddbe4409"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["ada1d1c1521680f2ede5f2a7e78c69f077b6caa6"],"2a56cf4d99cfac921f5a0c55a44e5561b54b5cd8":["f53aceda5e047338a4c5ad7094ba589263b94f59"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1936b95f78af7bc57e67df5b0de3f21a54df10af"],"d94deac68514af4c985eabd56d9bb95ce27467b9":["df724d84dab24a0cc54bec95a8680867adc7f171","b659435fdb2401d91fa87bb3df798ae41a8046cd"],"b659435fdb2401d91fa87bb3df798ae41a8046cd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ada1d1c1521680f2ede5f2a7e78c69f077b6caa6":["9907d9700d3bc9287f928dbea44ab9e28f70470a"],"9907d9700d3bc9287f928dbea44ab9e28f70470a":["df724d84dab24a0cc54bec95a8680867adc7f171","d94deac68514af4c985eabd56d9bb95ce27467b9"],"78956d805239de32e544cb115d4bcccbddbe4409":["0ac6494315d04f68950d2f00f5436b4861bcd467"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}