{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    CloudState cloudState = zkStateReader.getCloudState();\n\n    String collection = request.getParams().get(\"collection\", defaultCollection);\n\n    // TODO: allow multiple collections to be specified via comma separated list\n\n    Map<String,Slice> slices = cloudState.getSlices(collection);\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        String node = nodeProps.get(ZkStateReader.NODE_NAME);\n        if (!liveNodes.contains(node)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = nodeProps.get(ZkStateReader.URL_PROP);\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    // System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n    // TODO: set distrib=true if we detected more than one shard?\n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd08c10a09eda889d5a981853fce5f82ac904d22","date":1330472213,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da94fd5fcff99442877e118f00fb42094b59f497","date":1344115365,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    if (clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            String url = coreNodeProps.getCoreUrl();\n            urlList.add(url);\n          }\n        }\n      }\n      this.urlList = urlList;\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["719a344a9f4424f4ca57e4453bb44b954df0a512"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9b79570dbb7dde96e0d8bf42339245b30df35b","date":1344117822,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    if (clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            String url = coreNodeProps.getCoreUrl();\n            urlList.add(url);\n          }\n        }\n      }\n      this.urlList = urlList;\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06","719a344a9f4424f4ca57e4453bb44b954df0a512"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (replicas != null) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n\n      theUrlList.addAll(theReplicas);\n    }\n    //System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["719a344a9f4424f4ca57e4453bb44b954df0a512"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (replicas != null) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n\n      theUrlList.addAll(theReplicas);\n    }\n    //System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    CloudState cloudState = zkStateReader.getCloudState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, cloudState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = cloudState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global cloudState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (replicas != null) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n\n      theUrlList.addAll(theReplicas);\n    }\n    //System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    // IDEA: have versions on various things... like a global clusterState version\n    // or shardAddressVersion (which only changes when the shards change)\n    // to allow caching.\n\n    // build a map of unique nodes\n    // TODO: allow filtering by group, role, etc\n    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n    List<String> urlList = new ArrayList<String>();\n    for (Slice slice : slices.values()) {\n      for (ZkNodeProps nodeProps : slice.getShards().values()) {\n        ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n        String node = coreNodeProps.getNodeName();\n        if (!liveNodes.contains(coreNodeProps.getNodeName())\n            || !coreNodeProps.getState().equals(\n                ZkStateReader.ACTIVE)) continue;\n        if (nodes.put(node, nodeProps) == null) {\n          String url = coreNodeProps.getCoreUrl();\n          urlList.add(url);\n        }\n      }\n    }\n\n    Collections.shuffle(urlList, rand);\n    //System.out.println(\"########################## MAKING REQUEST TO \" + urlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6c028637b33774cb89eeb72e4de3f2b837fc20b","date":1346332709,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (replicas != null) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n\n      theUrlList.addAll(theReplicas);\n    }\n    //System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06","719a344a9f4424f4ca57e4453bb44b954df0a512"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (replicas != null) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n\n      theUrlList.addAll(theReplicas);\n    }\n    //System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getShards().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["719a344a9f4424f4ca57e4453bb44b954df0a512"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"719a344a9f4424f4ca57e4453bb44b954df0a512","date":1351211403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      System.out.println(\"work with collection:\" + collection);\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        System.out.println(\"build a new map for \" + collection);\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","fa64435b5902ce266c23755a4a00691a3285dab8","fd9b79570dbb7dde96e0d8bf42339245b30df35b","da94fd5fcff99442877e118f00fb42094b59f497","2c30e4c1cee08b3b229a77991882594fe7250b66","a6c028637b33774cb89eeb72e4de3f2b837fc20b"],"bugIntro":["d334938e866757266d62025305edd378ac505a06","e086a6377e06f1ff139e957e119d766644bbce89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2fcc7dc05d7e9a978d67a2bc37a6c5d557636184","date":1351214800,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        System.out.println(\"build a new map for \" + collection);\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      System.out.println(\"work with collection:\" + collection);\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        System.out.println(\"build a new map for \" + collection);\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a","date":1351228731,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        System.out.println(\"build a new map for \" + collection);\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    if (sendToLeaders && leaderUrlList == null || !sendToLeaders && urlList == null || clusterState.hashCode() != this.lastClusterStateHashCode) {\n    \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      if (sendToLeaders) {\n        this.leaderUrlList = urlList; \n        this.replicasList = replicas;\n      } else {\n        this.urlList = urlList;\n      }\n      this.lastClusterStateHashCode = clusterState.hashCode();\n    }\n    \n    List<String> theUrlList;\n    if (sendToLeaders) {\n      theUrlList = new ArrayList<String>(leaderUrlList.size());\n      theUrlList.addAll(leaderUrlList);\n    } else {\n      theUrlList = new ArrayList<String>(urlList.size());\n      theUrlList.addAll(urlList);\n    }\n    Collections.shuffle(theUrlList, rand);\n    if (sendToLeaders) {\n      ArrayList<String> theReplicas = new ArrayList<String>(replicasList.size());\n      theReplicas.addAll(replicasList);\n      Collections.shuffle(theReplicas, rand);\n    //  System.out.println(\"leaders:\" + theUrlList);\n    //  System.out.println(\"replicas:\" + theReplicas);\n      theUrlList.addAll(theReplicas);\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlicesMap(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7754464847b06ced605515bd48219280ede29e9","date":1354586462,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (String collectionName : collectionList) {\n      ClientUtils.addSlices(slices, collectionName, clusterState.getSlices(collectionName), true);\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlicesMap(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["d334938e866757266d62025305edd378ac505a06"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (String collectionName : collectionList) {\n      ClientUtils.addSlices(slices, collectionName, clusterState.getSlices(collectionName), true);\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (int i = 0; i < collectionList.size(); i++) {\n      String coll= collectionList.get(i);\n      ClientUtils.appendMap(coll, slices, clusterState.getSlices(coll));\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d334938e866757266d62025305edd378ac505a06","date":1355368871,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + liveNode.substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      // Extract each comma separated collection name and store in a List.\n      List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n      \n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionList) {\n        ClientUtils.addSlices(slices, collectionName,\n            clusterState.getSlices(collectionName), true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (String collectionName : collectionList) {\n      ClientUtils.addSlices(slices, collectionName, clusterState.getSlices(collectionName), true);\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","719a344a9f4424f4ca57e4453bb44b954df0a512","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","3f767f8c99eaedb984df754fe61f21c5de260f94","dd08c10a09eda889d5a981853fce5f82ac904d22","fd9b79570dbb7dde96e0d8bf42339245b30df35b","e7754464847b06ced605515bd48219280ede29e9","a6c028637b33774cb89eeb72e4de3f2b837fc20b"],"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89","2e94f03e4cb1d65fde70cc354ea6ae54bd44424a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + liveNode.substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      // Extract each comma separated collection name and store in a List.\n      List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n      \n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionList) {\n        ClientUtils.addSlices(slices, collectionName,\n            clusterState.getSlices(collectionName), true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    connect();\n\n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    String collection = reqParams.get(\"collection\", defaultCollection);\n    \n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n    \n    // Extract each comma separated collection name and store in a List.\n    List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n    \n    // TODO: not a big deal because of the caching, but we could avoid looking at every shard\n    // when getting leaders if we tweaked some things\n    \n    // Retrieve slices from the cloud state and, for each collection specified,\n    // add it to the Map of slices.\n    Map<String,Slice> slices = new HashMap<String,Slice>();\n    for (String collectionName : collectionList) {\n      ClientUtils.addSlices(slices, collectionName, clusterState.getSlices(collectionName), true);\n    }\n\n    Set<String> liveNodes = clusterState.getLiveNodes();\n\n    List<String> theUrlList;\n    synchronized (cachLock) {\n      List<String> leaderUrlList = leaderUrlLists.get(collection);\n      List<String> urlList = urlLists.get(collection);\n      List<String> replicasList = replicasLists.get(collection);\n\n      if ((sendToLeaders && leaderUrlList == null) || (!sendToLeaders\n          && urlList == null)\n          || clusterState.hashCode() != this.lastClusterStateHashCode) {\n        // build a map of unique nodes\n        // TODO: allow filtering by group, role, etc\n        Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n        List<String> urlList2 = new ArrayList<String>();\n        for (Slice slice : slices.values()) {\n          for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n            ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n            String node = coreNodeProps.getNodeName();\n            if (!liveNodes.contains(coreNodeProps.getNodeName())\n                || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n            if (nodes.put(node, nodeProps) == null) {\n              if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n                String url = coreNodeProps.getCoreUrl();\n                urlList2.add(url);\n              } else if (sendToLeaders) {\n                String url = coreNodeProps.getCoreUrl();\n                replicas.add(url);\n              }\n            }\n          }\n        }\n        if (sendToLeaders) {\n          this.leaderUrlLists.put(collection, urlList2);\n          leaderUrlList = urlList2;\n          this.replicasLists.put(collection, replicas);\n          replicasList = replicas;\n        } else {\n          this.urlLists.put(collection, urlList2);\n          urlList = urlList2;\n        }\n        this.lastClusterStateHashCode = clusterState.hashCode();\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n    }\n \n   // System.out.println(\"########################## MAKING REQUEST TO \" + theUrlList);\n \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + liveNode.substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      // Extract each comma separated collection name and store in a List.\n      List<String> collectionList = StrUtils.splitSmart(collection, \",\", true);\n      \n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionList) {\n        ClientUtils.addSlices(slices, collectionName,\n            clusterState.getSlices(collectionName), true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89","2e94f03e4cb1d65fde70cc354ea6ae54bd44424a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","date":1378862385,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if(request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest)request,clusterState);\n        if(response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    // TODO: if you can hash here, you could favor the shard leader\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest && updatesToLeaders) {\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e086a6377e06f1ff139e957e119d766644bbce89","date":1380719702,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext)\n            + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(\n                splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next();\n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if(request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest)request,clusterState);\n        if(response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\") || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext) + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next(); \n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState.getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\" + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      synchronized (cachLock) {\n        List<String> leaderUrlList = leaderUrlLists.get(collection);\n        List<String> urlList = urlLists.get(collection);\n        List<String> replicasList = replicasLists.get(collection);\n        \n        if ((sendToLeaders && leaderUrlList == null)\n            || (!sendToLeaders && urlList == null)\n            || clusterState.hashCode() != this.lastClusterStateHashCode) {\n          // build a map of unique nodes\n          // TODO: allow filtering by group, role, etc\n          Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n          List<String> urlList2 = new ArrayList<String>();\n          for (Slice slice : slices.values()) {\n            for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              String node = coreNodeProps.getNodeName();\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n              if (nodes.put(node, nodeProps) == null) {\n                if (!sendToLeaders\n                    || (sendToLeaders && coreNodeProps.isLeader())) {\n                  String url = coreNodeProps.getCoreUrl();\n                  urlList2.add(url);\n                } else if (sendToLeaders) {\n                  String url = coreNodeProps.getCoreUrl();\n                  replicas.add(url);\n                }\n              }\n            }\n          }\n          \n          if (sendToLeaders) {\n            this.leaderUrlLists.put(collection, urlList2);\n            leaderUrlList = urlList2;\n            this.replicasLists.put(collection, replicas);\n            replicasList = replicas;\n          } else {\n            this.urlLists.put(collection, urlList2);\n            urlList = urlList2;\n          }\n          this.lastClusterStateHashCode = clusterState.hashCode();\n        }\n        \n        if (sendToLeaders) {\n          theUrlList = new ArrayList<String>(leaderUrlList.size());\n          theUrlList.addAll(leaderUrlList);\n        } else {\n          theUrlList = new ArrayList<String>(urlList.size());\n          theUrlList.addAll(urlList);\n        }\n        Collections.shuffle(theUrlList, rand);\n        if (sendToLeaders) {\n          ArrayList<String> theReplicas = new ArrayList<String>(\n              replicasList.size());\n          theReplicas.addAll(replicasList);\n          Collections.shuffle(theReplicas, rand);\n          // System.out.println(\"leaders:\" + theUrlList);\n          // System.out.println(\"replicas:\" + theReplicas);\n          theUrlList.addAll(theReplicas);\n        }\n      }\n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["719a344a9f4424f4ca57e4453bb44b954df0a512","43adc163640856c8b07e4cf1b2046c9af56d3ae7","d334938e866757266d62025305edd378ac505a06","1cfa38e36fa296bb93d77df7d5556257dffa4535","d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"bugIntro":["2e94f03e4cb1d65fde70cc354ea6ae54bd44424a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e94f03e4cb1d65fde70cc354ea6ae54bd44424a","date":1382548304,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext)\n            + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(\n                splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext)\n            + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(\n                splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n      collection = collectionsList.iterator().next();\n      \n      StringBuilder collectionString = new StringBuilder();\n      Iterator<String> it = collectionsList.iterator();\n      for (int i = 0; i < collectionsList.size(); i++) {\n        String col = it.next();\n        collectionString.append(col);\n        if (i < collectionsList.size() - 1) {\n          collectionString.append(\",\");\n        }\n      }\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url = coreNodeProps.getCoreUrl();\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url = coreNodeProps.getCoreUrl();\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["d334938e866757266d62025305edd378ac505a06","1cfa38e36fa296bb93d77df7d5556257dffa4535","e086a6377e06f1ff139e957e119d766644bbce89"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        int splitPointBetweenHostPortAndContext = liveNode.indexOf(\"_\");\n        theUrlList.add(\"http://\"\n            + liveNode.substring(0, splitPointBetweenHostPortAndContext)\n            + \"/\"\n            + URLDecoder.decode(liveNode, \"UTF-8\").substring(\n                splitPointBetweenHostPortAndContext + 1));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<String>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<String>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<String,Slice>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();\n      List<String> urlList2 = new ArrayList<String>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<String>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<String>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<String>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14f5fb047085ab89f16696609c848b225b51b482","date":1395311996,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        Collection<Slice> colSlices = clusterState\n            .getActiveSlices(collectionName);\n        if (colSlices == null) {\n          throw new SolrServerException(\"Could not find collection:\"\n              + collectionName);\n        }\n        ClientUtils.addSlices(slices, collectionName, colSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      \n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, true, collection);\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(\"collection\", defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(\"collection\") == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, true, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, 0, collection);\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, 0, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, 0, collection);\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionsList = getCollectionList(clusterState, collection);\n      if (collectionsList.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n      if(shardKeys == null) {\n        shardKeys = reqParams.get(ShardParams.SHARD_KEYS); // deprecated\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionsList) {\n        DocCollection col = clusterState.getCollection(collectionName);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        // System.out.println(\"leaders:\" + theUrlList);\n        // System.out.println(\"replicas:\" + theReplicas);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    // System.out.println(\"########################## MAKING REQUEST TO \" +\n    // theUrlList);\n    \n    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, theUrlList);\n    LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#request(SolrRequest).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#request(SolrRequest).mjava","sourceNew":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, 0, collection);\n  }\n\n","sourceOld":"  @Override\n  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {\n    SolrParams reqParams = request.getParams();\n    String collection = (reqParams != null) ? reqParams.get(\"collection\", getDefaultCollection()) : getDefaultCollection();\n    return requestWithRetryOnStaleState(request, 0, collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd08c10a09eda889d5a981853fce5f82ac904d22":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d334938e866757266d62025305edd378ac505a06"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","dd08c10a09eda889d5a981853fce5f82ac904d22"],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["d334938e866757266d62025305edd378ac505a06"],"14f5fb047085ab89f16696609c848b225b51b482":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bafca15d8e408346a67f4282ad1143b88023893b":["9279b175e5e66258442d2123a50f052219a9cc1b"],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["2fcc7dc05d7e9a978d67a2bc37a6c5d557636184"],"a6c028637b33774cb89eeb72e4de3f2b837fc20b":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"e7754464847b06ced605515bd48219280ede29e9":["c5a558d54519c651068ddb202f03befefb1514a7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["8fd5be977c105554c6a7b68afcdbc511439723ab","2c30e4c1cee08b3b229a77991882594fe7250b66"],"2fcc7dc05d7e9a978d67a2bc37a6c5d557636184":["719a344a9f4424f4ca57e4453bb44b954df0a512"],"719a344a9f4424f4ca57e4453bb44b954df0a512":["fa64435b5902ce266c23755a4a00691a3285dab8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e086a6377e06f1ff139e957e119d766644bbce89":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"f2126b84bd093fa3d921582a109a0ee578c28126":["fa64435b5902ce266c23755a4a00691a3285dab8","5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["fd9b79570dbb7dde96e0d8bf42339245b30df35b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6c028637b33774cb89eeb72e4de3f2b837fc20b"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"407687e67faf6e1f02a211ca078d8e3eed631027":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a","e7754464847b06ced605515bd48219280ede29e9"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["dd08c10a09eda889d5a981853fce5f82ac904d22","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"fd9b79570dbb7dde96e0d8bf42339245b30df35b":["da94fd5fcff99442877e118f00fb42094b59f497"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["d6f074e73200c07d54f242d3880a8da5a35ff97b","a6c028637b33774cb89eeb72e4de3f2b837fc20b"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"2e94f03e4cb1d65fde70cc354ea6ae54bd44424a":["e086a6377e06f1ff139e957e119d766644bbce89"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["dd08c10a09eda889d5a981853fce5f82ac904d22"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"d334938e866757266d62025305edd378ac505a06":["e7754464847b06ced605515bd48219280ede29e9"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["2e94f03e4cb1d65fde70cc354ea6ae54bd44424a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5a558d54519c651068ddb202f03befefb1514a7":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["dd08c10a09eda889d5a981853fce5f82ac904d22","2c30e4c1cee08b3b229a77991882594fe7250b66"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"da94fd5fcff99442877e118f00fb42094b59f497":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["14f5fb047085ab89f16696609c848b225b51b482"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"dd08c10a09eda889d5a981853fce5f82ac904d22":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["e086a6377e06f1ff139e957e119d766644bbce89"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"14f5fb047085ab89f16696609c848b225b51b482":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5e71cbdfcf34d779dd7e7ba148dfff6022f2005a":["f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"a6c028637b33774cb89eeb72e4de3f2b837fc20b":["fa64435b5902ce266c23755a4a00691a3285dab8","05a14b2611ead08655a2b2bdc61632eb31316e57"],"e7754464847b06ced605515bd48219280ede29e9":["407687e67faf6e1f02a211ca078d8e3eed631027","d334938e866757266d62025305edd378ac505a06"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"2fcc7dc05d7e9a978d67a2bc37a6c5d557636184":["5e71cbdfcf34d779dd7e7ba148dfff6022f2005a"],"719a344a9f4424f4ca57e4453bb44b954df0a512":["2fcc7dc05d7e9a978d67a2bc37a6c5d557636184"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"e086a6377e06f1ff139e957e119d766644bbce89":["2e94f03e4cb1d65fde70cc354ea6ae54bd44424a"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a6c028637b33774cb89eeb72e4de3f2b837fc20b","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["14f5fb047085ab89f16696609c848b225b51b482"],"fa64435b5902ce266c23755a4a00691a3285dab8":["719a344a9f4424f4ca57e4453bb44b954df0a512","f2126b84bd093fa3d921582a109a0ee578c28126"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"fd9b79570dbb7dde96e0d8bf42339245b30df35b":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"9279b175e5e66258442d2123a50f052219a9cc1b":["bafca15d8e408346a67f4282ad1143b88023893b"],"2e94f03e4cb1d65fde70cc354ea6ae54bd44424a":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","da94fd5fcff99442877e118f00fb42094b59f497"],"d334938e866757266d62025305edd378ac505a06":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","1cfa38e36fa296bb93d77df7d5556257dffa4535"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c5a558d54519c651068ddb202f03befefb1514a7":["e7754464847b06ced605515bd48219280ede29e9"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["dd08c10a09eda889d5a981853fce5f82ac904d22","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"da94fd5fcff99442877e118f00fb42094b59f497":["fd9b79570dbb7dde96e0d8bf42339245b30df35b"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","c7869f64c874ebf7f317d22c00baf2b6857797a6","f2126b84bd093fa3d921582a109a0ee578c28126","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}