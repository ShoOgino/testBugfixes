{"path":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","commits":[{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d4707b60e1780a8b3e3d4a8fda80126e889deb5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d7f2f39556d99cecd24f152bdece2b6432458c3","date":1077651298,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"35c39157e8b6bc585e3a07e703d75db0f2ad56b2","date":1082672595,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"99ee715b9c02dd47d9e69a18607a5192c1ebd82b","date":1085007927,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s2 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s1 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse c = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse c = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba534479820dee396d07f520ba2a55400a1b6e7d","date":1085439102,"type":3,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s2 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s1 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = collators[i].compare (s2, s1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t\t// put first.\n\t\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s2 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s1 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse c = s2.compareTo(s1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse c = s1.compareTo(s2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c66de67505ac16f9dfbad38a316661be9ddc4fa","date":1123611330,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.\n\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 < r2) c = -1;\n\t\t\t\t\t\tif (r1 > r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 > i2) c = -1;\n\t\t\t\t\t\tif (i1 < i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\tif (s2 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s1 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\t\tc = s2.compareTo(s1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = collators[i].compare (s2, s1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 > f2) c = -1;\n\t\t\t\t\t\tif (f1 < f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docB.fields[i].compareTo (docA.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.DOC:\n\t\t\t\t\tcase SortField.INT:\n\t\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.STRING:\n\t\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t\t// put first.\n\t\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t\t// FLOAT both contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":null,"bugIntro":["ca63621c3d63233090c26fc637033de9726f76c6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca63621c3d63233090c26fc637033de9726f76c6","date":1131602252,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.\n\t\t\t\t\tif (s1 == null) c = -1;      // could be null if there are\n\t\t\t\t\telse if (s2 == null) c = 1;  // no terms in the given field\n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":["5c66de67505ac16f9dfbad38a316661be9ddc4fa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d4707b60e1780a8b3e3d4a8fda80126e889deb5","date":1131678790,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\t\treturn c > 0;\n\t}\n\n","bugFix":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8408bef84cc9eadfe3d6bf05cac61d5cb5a71f04","date":1193794105,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.DOC:\n\t\t\t\tcase SortField.INT:\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.STRING:\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.FLOAT:\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.CUSTOM:\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SortField.AUTO:\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n\t\t\t}\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a20974f34ae56da194b058e7307c8c52b32444d8","date":1201921568,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":5,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(FieldDoc,FieldDoc).mjava","pathOld":"src/java/org/apache/lucene/search/FieldDocSortedHitQueue#lessThan(Object,Object).mjava","sourceNew":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final FieldDoc docA, final FieldDoc docB) {\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns whether <code>a</code> is less relevant than <code>b</code>.\n\t * @param a ScoreDoc\n\t * @param b ScoreDoc\n\t * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.\n\t */\n\tprotected final boolean lessThan (final Object a, final Object b) {\n\t\tfinal FieldDoc docA = (FieldDoc) a;\n\t\tfinal FieldDoc docB = (FieldDoc) b;\n\t\tfinal int n = fields.length;\n\t\tint c = 0;\n\t\tfor (int i=0; i<n && c==0; ++i) {\n\t\t\tfinal int type = fields[i].getType();\n\t\t\tswitch (type) {\n\t\t\t\tcase SortField.SCORE:{\n\t\t\t\t\tfloat r1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat r2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (r1 > r2) c = -1;\n\t\t\t\t\tif (r1 < r2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOC:\n\t\t\t\tcase SortField.INT:{\n\t\t\t\t\tint i1 = ((Integer)docA.fields[i]).intValue();\n\t\t\t\t\tint i2 = ((Integer)docB.fields[i]).intValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.LONG:{\n\t\t\t\t\tlong l1 = ((Long)docA.fields[i]).longValue();\n\t\t\t\t\tlong l2 = ((Long)docB.fields[i]).longValue();\n\t\t\t\t\tif (l1 < l2) c = -1;\n\t\t\t\t\tif (l1 > l2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.STRING:{\n\t\t\t\t\tString s1 = (String) docA.fields[i];\n\t\t\t\t\tString s2 = (String) docB.fields[i];\n\t\t\t\t\t// null values need to be sorted first, because of how FieldCache.getStringIndex()\n\t\t\t\t\t// works - in that routine, any documents without a value in the given field are\n\t\t\t\t\t// put first.  If both are null, the next SortField is used\n\t\t\t\t\tif (s1 == null) c = (s2==null) ? 0 : -1;\n\t\t\t\t\telse if (s2 == null) c = 1;  // \n\t\t\t\t\telse if (fields[i].getLocale() == null) {\n\t\t\t\t\t\tc = s1.compareTo(s2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = collators[i].compare (s1, s2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n        }\n        case SortField.FLOAT:{\n\t\t\t\t\tfloat f1 = ((Float)docA.fields[i]).floatValue();\n\t\t\t\t\tfloat f2 = ((Float)docB.fields[i]).floatValue();\n\t\t\t\t\tif (f1 < f2) c = -1;\n\t\t\t\t\tif (f1 > f2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.DOUBLE:{\n\t\t\t\t\tdouble d1 = ((Double)docA.fields[i]).doubleValue();\n\t\t\t\t\tdouble d2 = ((Double)docB.fields[i]).doubleValue();\n\t\t\t\t\tif (d1 < d2) c = -1;\n\t\t\t\t\tif (d1 > d2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.BYTE:{\n\t\t\t\t\tint i1 = ((Byte)docA.fields[i]).byteValue();\n\t\t\t\t\tint i2 = ((Byte)docB.fields[i]).byteValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.SHORT:{\n\t\t\t\t\tint i1 = ((Short)docA.fields[i]).shortValue();\n\t\t\t\t\tint i2 = ((Short)docB.fields[i]).shortValue();\n\t\t\t\t\tif (i1 < i2) c = -1;\n\t\t\t\t\tif (i1 > i2) c = 1;\n\t\t\t\t\tbreak;\n        }\n        case SortField.CUSTOM:{\n\t\t\t\t\tc = docA.fields[i].compareTo (docB.fields[i]);\n\t\t\t\t\tbreak;\n        }\n        case SortField.AUTO:{\n\t\t\t\t\t// we cannot handle this - even if we determine the type of object (Float or\n\t\t\t\t\t// Integer), we don't necessarily know how to compare them (both SCORE and\n\t\t\t\t\t// FLOAT contain floats, but are sorted opposite of each other). Before\n\t\t\t\t\t// we get here, each AUTO should have been replaced with its actual value.\n\t\t\t\t\tthrow new RuntimeException (\"FieldDocSortedHitQueue cannot use an AUTO SortField\");\n        }\n        default:{\n\t\t\t\t\tthrow new RuntimeException (\"invalid SortField type: \"+type);\n        }\n      }\n\t\t\tif (fields[i].getReverse()) {\n\t\t\t\tc = -c;\n\t\t\t}\n\t\t}\n\n    // avoid random sort order that could lead to duplicates (bug #31241):\n    if (c == 0)\n      return docA.doc > docB.doc;\n\n    return c > 0;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d4707b60e1780a8b3e3d4a8fda80126e889deb5":["ca63621c3d63233090c26fc637033de9726f76c6"],"5c66de67505ac16f9dfbad38a316661be9ddc4fa":["ba534479820dee396d07f520ba2a55400a1b6e7d"],"9d7f2f39556d99cecd24f152bdece2b6432458c3":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"ba534479820dee396d07f520ba2a55400a1b6e7d":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8408bef84cc9eadfe3d6bf05cac61d5cb5a71f04":["4d4707b60e1780a8b3e3d4a8fda80126e889deb5"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["9d7f2f39556d99cecd24f152bdece2b6432458c3"],"a20974f34ae56da194b058e7307c8c52b32444d8":["8408bef84cc9eadfe3d6bf05cac61d5cb5a71f04"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["a20974f34ae56da194b058e7307c8c52b32444d8"],"ca63621c3d63233090c26fc637033de9726f76c6":["5c66de67505ac16f9dfbad38a316661be9ddc4fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"]},"commit2Childs":{"4d4707b60e1780a8b3e3d4a8fda80126e889deb5":["8408bef84cc9eadfe3d6bf05cac61d5cb5a71f04"],"5c66de67505ac16f9dfbad38a316661be9ddc4fa":["ca63621c3d63233090c26fc637033de9726f76c6"],"9d7f2f39556d99cecd24f152bdece2b6432458c3":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"],"ba534479820dee396d07f520ba2a55400a1b6e7d":["5c66de67505ac16f9dfbad38a316661be9ddc4fa"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["9d7f2f39556d99cecd24f152bdece2b6432458c3"],"99ee715b9c02dd47d9e69a18607a5192c1ebd82b":["ba534479820dee396d07f520ba2a55400a1b6e7d"],"8408bef84cc9eadfe3d6bf05cac61d5cb5a71f04":["a20974f34ae56da194b058e7307c8c52b32444d8"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["99ee715b9c02dd47d9e69a18607a5192c1ebd82b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"a20974f34ae56da194b058e7307c8c52b32444d8":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca63621c3d63233090c26fc637033de9726f76c6":["4d4707b60e1780a8b3e3d4a8fda80126e889deb5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}