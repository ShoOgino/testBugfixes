{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#publishFlushedSegments(boolean).mjava","commits":[{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#publishFlushedSegments(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Publishes the flushed segment, segment-private deletes (if any) and its\n   * associated global delete (if present) to IndexWriter.  The actual\n   * publishing operation is synced on {@code IW -> BDS} so that the {@link SegmentInfo}'s\n   * delete generation is always GlobalPacket_deleteGeneration + 1\n   * @param forced if <code>true</code> this call will block on the ticket queue if the lock is held by another thread.\n   *               if <code>false</code> the call will try to acquire the queue lock and exits if it's held by another thread.\n   *\n   */\n  void publishFlushedSegments(boolean forced) throws IOException {\n    docWriter.purgeFlushTickets(forced, ticket -> {\n      DocumentsWriterPerThread.FlushedSegment newSegment = ticket.getFlushedSegment();\n      FrozenBufferedUpdates bufferedUpdates = ticket.getFrozenUpdates();\n      ticket.markPublished();\n      if (newSegment == null) { // this is a flushed global deletes package - not a segments\n        if (bufferedUpdates != null && bufferedUpdates.any()) { // TODO why can this be null?\n          publishFrozenUpdates(bufferedUpdates);\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"flush: push buffered updates: \" + bufferedUpdates);\n          }\n        }\n      } else {\n        assert newSegment.segmentInfo != null;\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"publishFlushedSegment seg-private updates=\" + newSegment.segmentUpdates);\n        }\n        if (newSegment.segmentUpdates != null && infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"IW\", \"flush: push buffered seg private updates: \" + newSegment.segmentUpdates);\n        }\n        // now publish!\n        publishFlushedSegment(newSegment.segmentInfo, newSegment.fieldInfos, newSegment.segmentUpdates,\n            bufferedUpdates, newSegment.sortMap);\n      }\n    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#publishFlushedSegments(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#publishFlushedSegments(boolean).mjava","sourceNew":"  /**\n   * Publishes the flushed segment, segment-private deletes (if any) and its\n   * associated global delete (if present) to IndexWriter.  The actual\n   * publishing operation is synced on {@code IW -> BDS} so that the {@link SegmentInfo}'s\n   * delete generation is always GlobalPacket_deleteGeneration + 1\n   * @param forced if <code>true</code> this call will block on the ticket queue if the lock is held by another thread.\n   *               if <code>false</code> the call will try to acquire the queue lock and exits if it's held by another thread.\n   *\n   */\n  private void publishFlushedSegments(boolean forced) throws IOException {\n    docWriter.purgeFlushTickets(forced, ticket -> {\n      DocumentsWriterPerThread.FlushedSegment newSegment = ticket.getFlushedSegment();\n      FrozenBufferedUpdates bufferedUpdates = ticket.getFrozenUpdates();\n      ticket.markPublished();\n      if (newSegment == null) { // this is a flushed global deletes package - not a segments\n        if (bufferedUpdates != null && bufferedUpdates.any()) { // TODO why can this be null?\n          publishFrozenUpdates(bufferedUpdates);\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"flush: push buffered updates: \" + bufferedUpdates);\n          }\n        }\n      } else {\n        assert newSegment.segmentInfo != null;\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"publishFlushedSegment seg-private updates=\" + newSegment.segmentUpdates);\n        }\n        if (newSegment.segmentUpdates != null && infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"IW\", \"flush: push buffered seg private updates: \" + newSegment.segmentUpdates);\n        }\n        // now publish!\n        publishFlushedSegment(newSegment.segmentInfo, newSegment.fieldInfos, newSegment.segmentUpdates,\n            bufferedUpdates, newSegment.sortMap);\n      }\n    });\n  }\n\n","sourceOld":"  /**\n   * Publishes the flushed segment, segment-private deletes (if any) and its\n   * associated global delete (if present) to IndexWriter.  The actual\n   * publishing operation is synced on {@code IW -> BDS} so that the {@link SegmentInfo}'s\n   * delete generation is always GlobalPacket_deleteGeneration + 1\n   * @param forced if <code>true</code> this call will block on the ticket queue if the lock is held by another thread.\n   *               if <code>false</code> the call will try to acquire the queue lock and exits if it's held by another thread.\n   *\n   */\n  void publishFlushedSegments(boolean forced) throws IOException {\n    docWriter.purgeFlushTickets(forced, ticket -> {\n      DocumentsWriterPerThread.FlushedSegment newSegment = ticket.getFlushedSegment();\n      FrozenBufferedUpdates bufferedUpdates = ticket.getFrozenUpdates();\n      ticket.markPublished();\n      if (newSegment == null) { // this is a flushed global deletes package - not a segments\n        if (bufferedUpdates != null && bufferedUpdates.any()) { // TODO why can this be null?\n          publishFrozenUpdates(bufferedUpdates);\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"flush: push buffered updates: \" + bufferedUpdates);\n          }\n        }\n      } else {\n        assert newSegment.segmentInfo != null;\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"publishFlushedSegment seg-private updates=\" + newSegment.segmentUpdates);\n        }\n        if (newSegment.segmentUpdates != null && infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"IW\", \"flush: push buffered seg private updates: \" + newSegment.segmentUpdates);\n        }\n        // now publish!\n        publishFlushedSegment(newSegment.segmentInfo, newSegment.fieldInfos, newSegment.segmentUpdates,\n            bufferedUpdates, newSegment.sortMap);\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6b8498afacfc8322268ca0d659d274fcce08d557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["6b8498afacfc8322268ca0d659d274fcce08d557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"]},"commit2Childs":{"6b8498afacfc8322268ca0d659d274fcce08d557":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b8498afacfc8322268ca0d659d274fcce08d557"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}