{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.CrossingEdgeIterator#countCrossingPoint(GeoPoint,Plane,Edge).mjava","commits":[{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.CrossingEdgeIterator#countCrossingPoint(GeoPoint,Plane,Edge).mjava","pathOld":"/dev/null","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Plane plane, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":6,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.CrossingEdgeIterator#countCrossingPoint(GeoPoint,Plane,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      final Plane plane;\n      final Plane abovePlane;\n      final Plane belowPlane;\n      final SidedPlane bound1;\n      final SidedPlane bound2;\n      if (isSecondLeg) {\n        plane = travelPlane;\n        abovePlane = travelAbovePlane;\n        belowPlane = travelBelowPlane;\n        bound1 = checkPointCutoffPlane;\n        bound2 = checkPointOtherCutoffPlane;\n      } else {\n        plane = testPointPlane;\n        abovePlane = testPointAbovePlane;\n        belowPlane = testPointBelowPlane;\n        bound1 = testPointCutoffPlane;\n        bound2 = testPointOtherCutoffPlane;\n      }\n      \n      // MHL - this code below is temporary code copied from LinearCrossing above\n      \n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Plane plane, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff44d836e8863507fa8711d2b1b2dd723516ca0","date":1461653163,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.LinearCrossingEdgeIterator#countCrossingPoint(GeoPoint,Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.CrossingEdgeIterator#countCrossingPoint(GeoPoint,Plane,Edge).mjava","sourceNew":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","sourceOld":"    private void countCrossingPoint(final GeoPoint crossingPoint, final Plane plane, final Edge edge) {\n      if (crossingPoint.isNumericallyIdentical(edge.startPoint)) {\n        // We have to figure out if this crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.previous;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // To handle the latter situation, we need to know if the other edge will be looked at also, and then we can make\n        // a decision whether to count or not based on that.\n        \n        // Compute the crossing points of this other edge.\n        final GeoPoint[] otherCrossingPoints = plane.findCrossings(planetModel, assessEdge.plane, bound1, bound2, assessEdge.startPlane, assessEdge.endPlane);\n        \n        // Look for a matching endpoint.  If the other endpoint doesn't show up, it is either out of bounds (in which case the\n        // transition won't be counted for that edge), or it is not a crossing for that edge (so, same conclusion).\n        for (final GeoPoint otherCrossingPoint : otherCrossingPoints) {\n          if (otherCrossingPoint.isNumericallyIdentical(assessEdge.endPoint)) {\n            // Found it!\n            // Both edges will try to contribute to the crossing count.  By convention, we'll only include the earlier one.\n            // Since we're the latter point, we exit here in that case.\n            return;\n          }\n        }\n        \n        // Both edges will not count the same point, so we can proceed.  We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n        \n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n        \n      } else if (crossingPoint.isNumericallyIdentical(edge.endPoint)) {\n        // Figure out if the crossing should be counted.\n        \n        // Does the crossing for this edge go up, or down?  Or can't we tell?\n        final GeoPoint[] aboveIntersections = abovePlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        final GeoPoint[] belowIntersections = belowPlane.findIntersections(planetModel, edge.plane, edge.startPlane, edge.endPlane);\n        \n        assert !(aboveIntersections.length > 0 && belowIntersections.length > 0) : \"edge that ends in a crossing can't both up and down\";\n        \n        if (aboveIntersections.length == 0 && belowIntersections.length == 0) {\n          return;\n        }\n\n        final boolean edgeCrossesAbove = aboveIntersections.length > 0;\n\n        // This depends on the previous edge that first departs from identicalness.\n        Edge assessEdge = edge;\n        GeoPoint[] assessAboveIntersections;\n        GeoPoint[] assessBelowIntersections;\n        while (true) {\n          assessEdge = assessEdge.next;\n          assessAboveIntersections = abovePlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n          assessBelowIntersections = belowPlane.findIntersections(planetModel, assessEdge.plane, assessEdge.startPlane, assessEdge.endPlane);\n\n          assert !(assessAboveIntersections.length > 0 && assessBelowIntersections.length > 0) : \"assess edge that ends in a crossing can't both up and down\";\n\n          if (assessAboveIntersections.length == 0 && assessBelowIntersections.length == 0) {\n            continue;\n          }\n          break;\n        }\n        \n        // Basically, we now want to assess whether both edges that come together at this endpoint leave the plane in opposite\n        // directions.  If they do, then we should count it as a crossing; if not, we should not.  We also have to remember that\n        // each edge we look at can also be looked at again if it, too, seems to cross the plane.\n        \n        // By definition, we're the earlier plane in this case, so any crossing we detect we must count, by convention.  It is unnecessary\n        // to consider what the other edge does, because when we get to it, it will look back and figure out what we did for this one.\n        \n        // We need to determine the direction of both edges at the\n        // point where they hit the plane.  This may be complicated by the 3D geometry; it may not be safe just to look at the endpoints of the edges\n        // and make an assessment that way, since a single edge can intersect the plane at more than one point.\n\n        final boolean assessEdgeAbove = assessAboveIntersections.length > 0;\n        if (assessEdgeAbove != edgeCrossesAbove) {\n          crossingCount++;\n        }\n\n      } else {\n        crossingCount++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8ff44d836e8863507fa8711d2b1b2dd723516ca0":[],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["8ff44d836e8863507fa8711d2b1b2dd723516ca0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8ff44d836e8863507fa8711d2b1b2dd723516ca0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}