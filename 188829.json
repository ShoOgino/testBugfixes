{"path":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","commits":[{"id":"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a","date":1443442239,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \" + collection +\n                    \" not found in /clusterstate.json or /collections/\" + collection + \"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \" + collStatePath + \" due to: \" + childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {     \n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);          \n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String,Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n          \n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter = \n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;           \n          Set<String> liveNodes = applyStatusFilter ? \n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n          \n          SortedMap<String,Object> collectionStates = new TreeMap<String,Object>(pagingSupport);          \n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {              \n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);                \n              }              \n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {              \n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \"+collection+\n                    \" not found in /clusterstate.json or /collections/\"+collection+\"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \"+collStatePath+\" due to: \"+childErr);\n              }\n              \n              if (childDataStr != null) {\n                Map<String,Object> extColl = (Map<String,Object>)ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n                \n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String,Object>)collectionState,liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);                \n                }              \n              }              \n            }            \n          }\n          \n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n            \n            // rebuild the Map of state data\n            SortedMap<String,Object> map = new TreeMap<String,Object>(pagingSupport);                      \n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }          \n          \n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3714bcf66a68a1600e9dd11442fc1b33b62ef088","date":1556832005,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) Utils.fromJSONString(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \" + collection +\n                    \" not found in /clusterstate.json or /collections/\" + collection + \"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \" + collStatePath + \" due to: \" + childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) Utils.fromJSONString(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) ObjectBuilder.fromJSON(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \" + collection +\n                    \" not found in /clusterstate.json or /collections/\" + collection + \"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \" + collStatePath + \" due to: \" + childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) ObjectBuilder.fromJSON(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) Utils.fromJSONString(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection {} not found in /clusterstate.json or /collections/{}/state.json!\"\n                    , collection, collection);\n              } catch (Exception childErr) {\n                log.error(\"Failed to get {} due to\", collStatePath, childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) Utils.fromJSONString(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) Utils.fromJSONString(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection \" + collection +\n                    \" not found in /clusterstate.json or /collections/\" + collection + \"/state.json!\");\n              } catch (Exception childErr) {\n                log.error(\"Failed to get \" + collStatePath + \" due to: \" + childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) Utils.fromJSONString(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printZnode(JSONWriter,String).mjava","sourceNew":"    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","sourceOld":"    @SuppressWarnings(\"unchecked\")\n    boolean printZnode(JSONWriter json, String path) throws IOException {\n      try {\n        String dataStr = null;\n        String dataStrErr = null;\n        Stat stat = new Stat();\n        // Trickily, the call to zkClient.getData fills in the stat variable\n        byte[] data = zkClient.getData(path, null, stat, true);\n        if (null != data) {\n          try {\n            dataStr = (new BytesRef(data)).utf8ToString();\n          } catch (Exception e) {\n            dataStrErr = \"data is not parsable as a utf8 String: \" + e.toString();\n          }\n        }\n        // support paging of the collections graph view (in case there are many collections)\n        if (page != null) {\n          // we've already pulled the data for /clusterstate.json from ZooKeeper above,\n          // but it needs to be parsed into a map so we can lookup collection states before\n          // trying to find them in the /collections/?/state.json znode\n          Map<String, Object> clusterstateJsonMap = null;\n          if (dataStr != null) {\n            try {\n              clusterstateJsonMap = (Map<String, Object>) Utils.fromJSONString(dataStr);\n            } catch (Exception e) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"Failed to parse /clusterstate.json from ZooKeeper due to: \" + e, e);\n            }\n          } else {\n            clusterstateJsonMap = Utils.makeMap();\n          }\n\n          // fetch the requested page of collections and then retrieve the state for each \n          page = pagingSupport.fetchPage(page, zkClient);\n          // keep track of how many collections match the filter\n          boolean applyStatusFilter =\n              (page.filterType == FilterType.status && page.filter != null);\n          List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n          Set<String> liveNodes = applyStatusFilter ?\n              zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n          SortedMap<String, Object> collectionStates = new TreeMap<String, Object>(pagingSupport);\n          for (String collection : page.selected) {\n            Object collectionState = clusterstateJsonMap.get(collection);\n            if (collectionState != null) {\n              // collection state was in /clusterstate.json\n              if (applyStatusFilter) {\n                // verify this collection matches the status filter\n                if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                  matchesStatusFilter.add(collection);\n                  collectionStates.put(collection, collectionState);\n                }\n              } else {\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              // looks like an external collection ...\n              String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n              String childDataStr = null;\n              try {\n                byte[] childData = zkClient.getData(collStatePath, null, null, true);\n                if (childData != null)\n                  childDataStr = (new BytesRef(childData)).utf8ToString();\n              } catch (KeeperException.NoNodeException nne) {\n                log.warn(\"State for collection {} not found in /clusterstate.json or /collections/{}/state.json!\"\n                    , collection, collection);\n              } catch (Exception childErr) {\n                log.error(\"Failed to get {} due to\", collStatePath, childErr);\n              }\n\n              if (childDataStr != null) {\n                Map<String, Object> extColl = (Map<String, Object>) Utils.fromJSONString(childDataStr);\n                collectionState = extColl.get(collection);\n\n                if (applyStatusFilter) {\n                  // verify this collection matches the filtered state\n                  if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                    matchesStatusFilter.add(collection);\n                    collectionStates.put(collection, collectionState);\n                  }\n                } else {\n                  collectionStates.put(collection, collectionState);\n                }\n              }\n            }\n          }\n\n          if (applyStatusFilter) {\n            // update the paged navigation info after applying the status filter\n            page.selectPage(matchesStatusFilter);\n\n            // rebuild the Map of state data\n            SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n            for (String next : page.selected)\n              map.put(next, collectionStates.get(next));\n            collectionStates = map;\n          }\n\n          if (collectionStates != null) {\n            CharArr out = new CharArr();\n            new JSONWriter(out, 2).write(collectionStates);\n            dataStr = out.toString();\n          }\n        }\n\n        json.writeString(\"znode\");\n        json.writeNameSeparator();\n        json.startObject();\n\n        writeKeyValue(json, PATH, path, true);\n\n        json.writeValueSeparator();\n        json.writeString(\"prop\");\n        json.writeNameSeparator();\n        json.startObject();\n        writeKeyValue(json, \"version\", stat.getVersion(), true);\n        writeKeyValue(json, \"aversion\", stat.getAversion(), false);\n        writeKeyValue(json, \"children_count\", stat.getNumChildren(), false);\n        writeKeyValue(json, \"ctime\", time(stat.getCtime()), false);\n        writeKeyValue(json, \"cversion\", stat.getCversion(), false);\n        writeKeyValue(json, \"czxid\", stat.getCzxid(), false);\n        writeKeyValue(json, \"ephemeralOwner\", stat.getEphemeralOwner(), false);\n        writeKeyValue(json, \"mtime\", time(stat.getMtime()), false);\n        writeKeyValue(json, \"mzxid\", stat.getMzxid(), false);\n        writeKeyValue(json, \"pzxid\", stat.getPzxid(), false);\n        writeKeyValue(json, \"dataLength\", stat.getDataLength(), false);\n        if (null != dataStrErr) {\n          writeKeyValue(json, \"dataNote\", dataStrErr, false);\n        }\n        json.endObject();\n\n        if (null != dataStr) {\n          writeKeyValue(json, \"data\", dataStr, false);\n        }\n\n        if (page != null) {\n          writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n        }\n\n        json.endObject();\n      } catch (KeeperException e) {\n        writeError(500, e.toString());\n        return false;\n      } catch (InterruptedException e) {\n        writeError(500, e.toString());\n        return false;\n      }\n      return true;\n    }\n\n","bugFix":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500","b693a83132c9e45afcd564fd65a25b60ed80388b","575e66bd4b2349209027f6801184da7fc3cba13f","80ebe5b1d946f7c2ed9c46206b0c7254dc21206a","3714bcf66a68a1600e9dd11442fc1b33b62ef088","d69bac0909e90a1213b0850137b00ac371f866e1","9279b175e5e66258442d2123a50f052219a9cc1b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["575e66bd4b2349209027f6801184da7fc3cba13f"],"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["80ebe5b1d946f7c2ed9c46206b0c7254dc21206a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"80ebe5b1d946f7c2ed9c46206b0c7254dc21206a":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80ebe5b1d946f7c2ed9c46206b0c7254dc21206a"],"575e66bd4b2349209027f6801184da7fc3cba13f":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}