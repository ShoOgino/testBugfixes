{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void corruptUnknownFiles() throws IOException {\n\n    System.out.println(\"MDW: corrupt unknown files\");\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        knownFiles.addAll(SegmentInfos.readCommit(this, fileName).files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a8ec0889b27701f0ad90a25c95b75454e898cf3","date":1454871481,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","sourceNew":"  public synchronized void corruptUnknownFiles() throws IOException {\n\n    System.out.println(\"MDW: corrupt unknown files\");\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        SegmentInfos infos;\n        try {\n          infos = SegmentInfos.readCommit(this, fileName);\n        } catch (IOException ioe) {\n          System.out.println(\"MDW: exception reading segment infos \" + fileName + \"; files: \" + Arrays.toString(listAll()));\n          throw ioe;\n        }\n        knownFiles.addAll(infos.files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","sourceOld":"  public synchronized void corruptUnknownFiles() throws IOException {\n\n    System.out.println(\"MDW: corrupt unknown files\");\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        knownFiles.addAll(SegmentInfos.readCommit(this, fileName).files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void corruptUnknownFiles() throws IOException {\n\n    System.out.println(\"MDW: corrupt unknown files\");\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        SegmentInfos infos;\n        try {\n          infos = SegmentInfos.readCommit(this, fileName);\n        } catch (IOException ioe) {\n          System.out.println(\"MDW: exception reading segment infos \" + fileName + \"; files: \" + Arrays.toString(listAll()));\n          throw ioe;\n        }\n        knownFiles.addAll(infos.files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptUnknownFiles().mjava","sourceNew":"  public synchronized void corruptUnknownFiles() throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"MDW: corrupt unknown files\");\n    }\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        }\n        SegmentInfos infos;\n        try {\n          infos = SegmentInfos.readCommit(this, fileName);\n        } catch (IOException ioe) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"MDW: exception reading segment infos \" + fileName + \"; files: \" + Arrays.toString(listAll()));\n          }\n          throw ioe;\n        }\n        knownFiles.addAll(infos.files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","sourceOld":"  public synchronized void corruptUnknownFiles() throws IOException {\n\n    System.out.println(\"MDW: corrupt unknown files\");\n    Set<String> knownFiles = new HashSet<>();\n    for(String fileName : listAll()) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        System.out.println(\"MDW: read \" + fileName + \" to gather files it references\");\n        SegmentInfos infos;\n        try {\n          infos = SegmentInfos.readCommit(this, fileName);\n        } catch (IOException ioe) {\n          System.out.println(\"MDW: exception reading segment infos \" + fileName + \"; files: \" + Arrays.toString(listAll()));\n          throw ioe;\n        }\n        knownFiles.addAll(infos.files(true));\n      }\n    }\n\n    Set<String> toCorrupt = new HashSet<>();\n    Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n    for(String fileName : listAll()) {\n      m.reset(fileName);\n      if (knownFiles.contains(fileName) == false &&\n          fileName.endsWith(\"write.lock\") == false &&\n          (m.matches() || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {\n        toCorrupt.add(fileName);\n      }\n    }\n\n    corruptFiles(toCorrupt);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"264935965977b4a9e2f3920420647072c9c49176":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["264935965977b4a9e2f3920420647072c9c49176"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["68496c2200e559fb7802f7575427b7a482659afb"],"264935965977b4a9e2f3920420647072c9c49176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["264935965977b4a9e2f3920420647072c9c49176"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}