{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","commits":[{"id":"2f033e640613edeb07d8952279368806db4ab299","date":1511393468,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (type.equals(DistanceType.euclidean)) {\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return euclideanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.manhattan)) {\n        ManhattanDistance manhattanDistance = new ManhattanDistance();\n        return manhattanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n\n      } else if (type.equals(DistanceType.canberra)) {\n        CanberraDistance canberraDistance = new CanberraDistance();\n        return canberraDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.earthMovers)) {\n        EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n        return earthMoversDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else {\n        return null;\n      }\n    } else if(values.length == 1) {\n      if(values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix)values[0];\n        if (type.equals(DistanceType.euclidean)) {\n          EuclideanDistance euclideanDistance = new EuclideanDistance();\n          return distance(euclideanDistance, matrix);\n        } else if (type.equals(DistanceType.canberra)) {\n          CanberraDistance canberraDistance = new CanberraDistance();\n          return distance(canberraDistance, matrix);\n        } else if (type.equals(DistanceType.manhattan)) {\n          ManhattanDistance manhattanDistance = new ManhattanDistance();\n          return distance(manhattanDistance, matrix);\n        } else if (type.equals(DistanceType.earthMovers)) {\n          EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n          return distance(earthMoversDistance, matrix);\n        } else {\n          return null;\n        }\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54","date":1512439781,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (type.equals(DistanceType.euclidean)) {\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return euclideanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.manhattan)) {\n        ManhattanDistance manhattanDistance = new ManhattanDistance();\n        return manhattanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n\n      } else if (type.equals(DistanceType.canberra)) {\n        CanberraDistance canberraDistance = new CanberraDistance();\n        return canberraDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.earthMovers)) {\n        EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n        return earthMoversDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else {\n        return null;\n      }\n    } else if(values.length == 1) {\n      if(values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix)values[0];\n        if (type.equals(DistanceType.euclidean)) {\n          EuclideanDistance euclideanDistance = new EuclideanDistance();\n          return distance(euclideanDistance, matrix);\n        } else if (type.equals(DistanceType.canberra)) {\n          CanberraDistance canberraDistance = new CanberraDistance();\n          return distance(canberraDistance, matrix);\n        } else if (type.equals(DistanceType.manhattan)) {\n          ManhattanDistance manhattanDistance = new ManhattanDistance();\n          return distance(manhattanDistance, matrix);\n        } else if (type.equals(DistanceType.earthMovers)) {\n          EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n          return distance(earthMoversDistance, matrix);\n        } else {\n          return null;\n        }\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (type.equals(DistanceType.euclidean)) {\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return euclideanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.manhattan)) {\n        ManhattanDistance manhattanDistance = new ManhattanDistance();\n        return manhattanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n\n      } else if (type.equals(DistanceType.canberra)) {\n        CanberraDistance canberraDistance = new CanberraDistance();\n        return canberraDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.earthMovers)) {\n        EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n        return earthMoversDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray()\n        );\n      } else {\n        return null;\n      }\n    } else if(values.length == 1) {\n      if(values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix)values[0];\n        if (type.equals(DistanceType.euclidean)) {\n          EuclideanDistance euclideanDistance = new EuclideanDistance();\n          return distance(euclideanDistance, matrix);\n        } else if (type.equals(DistanceType.canberra)) {\n          CanberraDistance canberraDistance = new CanberraDistance();\n          return distance(canberraDistance, matrix);\n        } else if (type.equals(DistanceType.manhattan)) {\n          ManhattanDistance manhattanDistance = new ManhattanDistance();\n          return distance(manhattanDistance, matrix);\n        } else if (type.equals(DistanceType.earthMovers)) {\n          EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n          return distance(earthMoversDistance, matrix);\n        } else {\n          return null;\n        }\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d0b4707f3bab526e78877bedeebf53368dbc3d7","date":1524706692,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 1) {\n      if (values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix) values[0];\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return distance(euclideanDistance, matrix);\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if(first instanceof Matrix) {\n        Matrix matrix = (Matrix) first;\n        DistanceMeasure distanceMeasure = (DistanceMeasure)second;\n        return distance(distanceMeasure, matrix);\n      } else {\n        if (!(first instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        if (!(second instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        DistanceMeasure distanceMeasure = new EuclideanDistance();\n        return distanceMeasure.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      }\n    } else if (values.length == 3) {\n      Object first = values[0];\n      Object second = values[1];\n      DistanceMeasure distanceMeasure = (DistanceMeasure)values[2];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      return distanceMeasure.compute(\n          ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n          ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n      );\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (type.equals(DistanceType.euclidean)) {\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return euclideanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.manhattan)) {\n        ManhattanDistance manhattanDistance = new ManhattanDistance();\n        return manhattanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n\n      } else if (type.equals(DistanceType.canberra)) {\n        CanberraDistance canberraDistance = new CanberraDistance();\n        return canberraDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.earthMovers)) {\n        EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n        return earthMoversDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else {\n        return null;\n      }\n    } else if(values.length == 1) {\n      if(values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix)values[0];\n        if (type.equals(DistanceType.euclidean)) {\n          EuclideanDistance euclideanDistance = new EuclideanDistance();\n          return distance(euclideanDistance, matrix);\n        } else if (type.equals(DistanceType.canberra)) {\n          CanberraDistance canberraDistance = new CanberraDistance();\n          return distance(canberraDistance, matrix);\n        } else if (type.equals(DistanceType.manhattan)) {\n          ManhattanDistance manhattanDistance = new ManhattanDistance();\n          return distance(manhattanDistance, matrix);\n        } else if (type.equals(DistanceType.earthMovers)) {\n          EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n          return distance(earthMoversDistance, matrix);\n        } else {\n          return null;\n        }\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"960f089602da7f0df48fb0e23de1ecbc791b95f0","date":1524725963,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 1) {\n      if (values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix) values[0];\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return distance(euclideanDistance, matrix);\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if(first instanceof Matrix) {\n        Matrix matrix = (Matrix) first;\n        DistanceMeasure distanceMeasure = (DistanceMeasure)second;\n        return distance(distanceMeasure, matrix);\n      } else {\n        if (!(first instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        if (!(second instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        DistanceMeasure distanceMeasure = new EuclideanDistance();\n        return distanceMeasure.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      }\n    } else if (values.length == 3) {\n      Object first = values[0];\n      Object second = values[1];\n      DistanceMeasure distanceMeasure = (DistanceMeasure)values[2];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      return distanceMeasure.compute(\n          ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n          ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n      );\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (type.equals(DistanceType.euclidean)) {\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return euclideanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.manhattan)) {\n        ManhattanDistance manhattanDistance = new ManhattanDistance();\n        return manhattanDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n\n      } else if (type.equals(DistanceType.canberra)) {\n        CanberraDistance canberraDistance = new CanberraDistance();\n        return canberraDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else if (type.equals(DistanceType.earthMovers)) {\n        EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n        return earthMoversDistance.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      } else {\n        return null;\n      }\n    } else if(values.length == 1) {\n      if(values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix)values[0];\n        if (type.equals(DistanceType.euclidean)) {\n          EuclideanDistance euclideanDistance = new EuclideanDistance();\n          return distance(euclideanDistance, matrix);\n        } else if (type.equals(DistanceType.canberra)) {\n          CanberraDistance canberraDistance = new CanberraDistance();\n          return distance(canberraDistance, matrix);\n        } else if (type.equals(DistanceType.manhattan)) {\n          ManhattanDistance manhattanDistance = new ManhattanDistance();\n          return distance(manhattanDistance, matrix);\n        } else if (type.equals(DistanceType.earthMovers)) {\n          EarthMoversDistance earthMoversDistance = new EarthMoversDistance();\n          return distance(earthMoversDistance, matrix);\n        } else {\n          return null;\n        }\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","date":1591579911,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DistanceEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 1) {\n      if (values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix) values[0];\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return distance(euclideanDistance, matrix);\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if(first instanceof Matrix) {\n        Matrix matrix = (Matrix) first;\n        DistanceMeasure distanceMeasure = (DistanceMeasure)second;\n        return distance(distanceMeasure, matrix);\n      } else {\n        if (!(first instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        if (!(second instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        DistanceMeasure distanceMeasure = new EuclideanDistance();\n        return distanceMeasure.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      }\n    } else if (values.length == 3) {\n      Object first = values[0];\n      Object second = values[1];\n      DistanceMeasure distanceMeasure = (DistanceMeasure)values[2];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      return distanceMeasure.compute(\n          ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n          ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n      );\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object ... values) throws IOException{\n\n    if(values.length == 1) {\n      if (values[0] instanceof Matrix) {\n        Matrix matrix = (Matrix) values[0];\n        EuclideanDistance euclideanDistance = new EuclideanDistance();\n        return distance(euclideanDistance, matrix);\n      } else {\n        throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n      }\n    } else if(values.length == 2) {\n      Object first = values[0];\n      Object second = values[1];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if(first instanceof Matrix) {\n        Matrix matrix = (Matrix) first;\n        DistanceMeasure distanceMeasure = (DistanceMeasure)second;\n        return distance(distanceMeasure, matrix);\n      } else {\n        if (!(first instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        if (!(second instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n        }\n\n        DistanceMeasure distanceMeasure = new EuclideanDistance();\n        return distanceMeasure.compute(\n            ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n            ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n        );\n      }\n    } else if (values.length == 3) {\n      Object first = values[0];\n      Object second = values[1];\n      DistanceMeasure distanceMeasure = (DistanceMeasure)values[2];\n\n      if (null == first) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the first value\", toExpression(constructingFactory)));\n      }\n\n      if (null == second) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - null found for the second value\", toExpression(constructingFactory)));\n      }\n\n      if (!(first instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      if (!(second instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a list of numbers\", toExpression(constructingFactory), first.getClass().getSimpleName()));\n      }\n\n      return distanceMeasure.compute(\n          ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray(),\n          ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray()\n      );\n    } else {\n      throw new IOException(\"distance function operates on either two numeric arrays or a single matrix as parameters.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2f033e640613edeb07d8952279368806db4ab299":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["960f089602da7f0df48fb0e23de1ecbc791b95f0"],"5d0b4707f3bab526e78877bedeebf53368dbc3d7":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["2f033e640613edeb07d8952279368806db4ab299"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"960f089602da7f0df48fb0e23de1ecbc791b95f0":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54","5d0b4707f3bab526e78877bedeebf53368dbc3d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"]},"commit2Childs":{"2f033e640613edeb07d8952279368806db4ab299":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5d0b4707f3bab526e78877bedeebf53368dbc3d7":["960f089602da7f0df48fb0e23de1ecbc791b95f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2f033e640613edeb07d8952279368806db4ab299"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["5d0b4707f3bab526e78877bedeebf53368dbc3d7","960f089602da7f0df48fb0e23de1ecbc791b95f0"],"960f089602da7f0df48fb0e23de1ecbc791b95f0":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}