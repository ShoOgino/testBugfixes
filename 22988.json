{"path":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279c7cd47f17e1e8b674a3741ff5f040bc680be","date":1341675760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dcc555744b1a581a4beccd0b75f8d3fe49735a2f","date":1367588265,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        spare.copyUTF8Bytes(s.term);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e253750c2f7c232c8e818a2803aa8e42bc4684a","date":1577097716,"type":3,"author":"Andy Webb","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    String text = term.text();\n\n    int textLength = text.codePointCount(0, text.length());\n    if (textLength < minQueryLength || textLength > maxQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        spare.copyUTF8Bytes(s.term);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        spare.copyUTF8Bytes(s.term);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","date":1577276097,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    String text = term.text();\n\n    int textLength = text.codePointCount(0, text.length());\n    if (textLength < minQueryLength || textLength > maxQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        spare.copyUTF8Bytes(s.term);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRefBuilder spare = new CharsRefBuilder();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ROOT));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        spare.copyUTF8Bytes(s.term);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.timSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["2acf500f78aa12b92e371fd89c719291986b6b90"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2acf500f78aa12b92e371fd89c719291986b6b90":["b89678825b68eccaf09e6ab71675fc0b0af1e099","9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"46d8ada1fff8d18cb197c38c7983225162599948":["b89678825b68eccaf09e6ab71675fc0b0af1e099","2acf500f78aa12b92e371fd89c719291986b6b90"],"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","2e253750c2f7c232c8e818a2803aa8e42bc4684a"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"2e253750c2f7c232c8e818a2803aa8e42bc4684a":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2e253750c2f7c232c8e818a2803aa8e42bc4684a"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["dcc555744b1a581a4beccd0b75f8d3fe49735a2f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","2e253750c2f7c232c8e818a2803aa8e42bc4684a"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["9279c7cd47f17e1e8b674a3741ff5f040bc680be","2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"dcc555744b1a581a4beccd0b75f8d3fe49735a2f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2e253750c2f7c232c8e818a2803aa8e42bc4684a":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["46d8ada1fff8d18cb197c38c7983225162599948","96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}