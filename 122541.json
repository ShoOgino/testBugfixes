{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","commits":[{"id":"0088660bdc1c051f58fbc38626d61ccf22dfd3e0","date":1427444574,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n      int maxDeterminizedStates) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      // NOTE: only approximate, because automaton may not be minimal:\n      } else if (Operations.isTotal(automaton)) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      } else {\n\n        automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n        final String commonPrefix = Operations.getCommonPrefix(automaton);\n        final String singleton;\n\n        if (commonPrefix.length() > 0 && Operations.sameLanguage(automaton, Automata.makeString(commonPrefix))) {\n          singleton = commonPrefix;\n        } else {\n          singleton = null;\n        }\n\n        if (singleton != null) {\n          // matches a fixed string\n          type = AUTOMATON_TYPE.SINGLE;\n          term = new BytesRef(singleton);\n          commonSuffixRef = null;\n          runAutomaton = null;\n          this.automaton = null;\n          this.finite = null;\n          return;\n        } else if (commonPrefix.length() > 0) {\n          Automaton other = Operations.concatenate(Automata.makeString(commonPrefix), Automata.makeAnyString());\n          other = Operations.determinize(other, maxDeterminizedStates);\n          assert Operations.hasDeadStates(other) == false;\n          if (Operations.sameLanguage(automaton, other)) {\n            // matches a constant prefix\n            type = AUTOMATON_TYPE.PREFIX;\n            term = new BytesRef(commonPrefix);\n            commonSuffixRef = null;\n            runAutomaton = null;\n            this.automaton = null;\n            this.finite = null;\n            return;\n          }\n        }\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton utf8 = new UTF32ToUTF8().convert(automaton);\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(utf8, maxDeterminizedStates);\n    }\n    runAutomaton = new ByteRunAutomaton(utf8, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b839a1609f1d92a26ff6a2449601bfe6ec8ccc72","date":1427479616,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      commonSuffixRef = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n        sinkState = -1;\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice... we could do a fast match\n      // by looking for a sink state (which means it has no common suffix).  Or maybe we shouldn't do it when simplify is false?:\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n\n    // TODO: this is a bit fragile because if the automaton is not minimized there could be more than 1 sink state but auto-prefix will fail\n    // to run for those:\n    sinkState = findSinkState(this.automaton);\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n        sinkState = -1;\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice... we could do a fast match\n      // by looking for a sink state (which means it has no common suffix).  Or maybe we shouldn't do it when simplify is false?:\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n\n    // TODO: this is a bit fragile because if the automaton is not minimized there could be more than 1 sink state but auto-prefix will fail\n    // to run for those:\n    sinkState = findSinkState(this.automaton);\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice...\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#CompiledAutomaton(Automaton,Boolean,boolean,int,boolean).mjava","sourceNew":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the automaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n        sinkState = -1;\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice... we could do a fast match\n      // by looking for a sink state (which means it has no common suffix).  Or maybe we shouldn't do it when simplify is false?:\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n\n    // TODO: this is a bit fragile because if the automaton is not minimized there could be more than 1 sink state but auto-prefix will fail\n    // to run for those:\n    sinkState = findSinkState(this.automaton);\n  }\n\n","sourceOld":"  /** Create this.  If finite is null, we use {@link Operations#isFinite}\n   *  to determine whether it is finite.  If simplify is true, we run\n   *  possibly expensive operations to determine if the automaton is one\n   *  the cases in {@link CompiledAutomaton.AUTOMATON_TYPE}. If simplify\n   *  requires determinizing the autaomaton then only maxDeterminizedStates\n   *  will be created.  Any more than that will cause a\n   *  TooComplexToDeterminizeException.\n   */\n  public CompiledAutomaton(Automaton automaton, Boolean finite, boolean simplify,\n                           int maxDeterminizedStates, boolean isBinary) {\n    if (automaton.getNumStates() == 0) {\n      automaton = new Automaton();\n      automaton.createState();\n    }\n\n    if (simplify) {\n\n      // Test whether the automaton is a \"simple\" form and\n      // if so, don't create a runAutomaton.  Note that on a\n      // large automaton these tests could be costly:\n\n      if (Operations.isEmpty(automaton)) {\n        // matches nothing\n        type = AUTOMATON_TYPE.NONE;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      boolean isTotal;\n\n      // NOTE: only approximate, because automaton may not be minimal:\n      if (isBinary) {\n        isTotal = Operations.isTotal(automaton, 0, 0xff);\n      } else {\n        isTotal = Operations.isTotal(automaton);\n      }\n\n      if (isTotal) {\n        // matches all possible strings\n        type = AUTOMATON_TYPE.ALL;\n        term = null;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n        sinkState = -1;\n        return;\n      }\n\n      automaton = Operations.determinize(automaton, maxDeterminizedStates);\n\n      IntsRef singleton = Operations.getSingleton(automaton);\n\n      if (singleton != null) {\n        // matches a fixed string\n        type = AUTOMATON_TYPE.SINGLE;\n        commonSuffixRef = null;\n        runAutomaton = null;\n        this.automaton = null;\n        this.finite = null;\n\n        if (isBinary) {\n          term = StringHelper.intsRefToBytesRef(singleton);\n        } else {\n          term = new BytesRef(UnicodeUtil.newString(singleton.ints, singleton.offset, singleton.length));\n        }\n        sinkState = -1;\n        return;\n      }\n    }\n\n    type = AUTOMATON_TYPE.NORMAL;\n    term = null;\n\n    if (finite == null) {\n      this.finite = Operations.isFinite(automaton);\n    } else {\n      this.finite = finite;\n    }\n\n    Automaton binary;\n    if (isBinary) {\n      // Caller already built binary automaton themselves, e.g. PrefixQuery\n      // does this since it can be provided with a binary (not necessarily\n      // UTF8!) term:\n      binary = automaton;\n    } else {\n      // Incoming automaton is unicode, and we must convert to UTF8 to match what's in the index:\n      binary = new UTF32ToUTF8().convert(automaton);\n    }\n\n    if (this.finite) {\n      commonSuffixRef = null;\n    } else {\n      // NOTE: this is a very costly operation!  We should test if it's really warranted in practice... we could do a fast match\n      // by looking for a sink state (which means it has no common suffix).  Or maybe we shouldn't do it when simplify is false?:\n      BytesRef suffix = Operations.getCommonSuffixBytesRef(binary, maxDeterminizedStates);\n      if (suffix.length == 0) {\n        commonSuffixRef = null;\n      } else {\n        commonSuffixRef = suffix;\n      }\n    }\n\n    // This will determinize the binary automaton for us:\n    runAutomaton = new ByteRunAutomaton(binary, true, maxDeterminizedStates);\n\n    this.automaton = runAutomaton.automaton;\n\n    // TODO: this is a bit fragile because if the automaton is not minimized there could be more than 1 sink state but auto-prefix will fail\n    // to run for those:\n    sinkState = findSinkState(this.automaton);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b839a1609f1d92a26ff6a2449601bfe6ec8ccc72"],"0088660bdc1c051f58fbc38626d61ccf22dfd3e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["3e8715d826e588419327562287d5d6a8040d63d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["b839a1609f1d92a26ff6a2449601bfe6ec8ccc72"],"b839a1609f1d92a26ff6a2449601bfe6ec8ccc72":["0088660bdc1c051f58fbc38626d61ccf22dfd3e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"0088660bdc1c051f58fbc38626d61ccf22dfd3e0":["b839a1609f1d92a26ff6a2449601bfe6ec8ccc72"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0088660bdc1c051f58fbc38626d61ccf22dfd3e0"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","d2638f781be724518ff6c2263d14a48cf6e68017"],"b839a1609f1d92a26ff6a2449601bfe6ec8ccc72":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}