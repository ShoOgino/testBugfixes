{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","commits":[{"id":"3ce36a160d1241ae9c70e109dc3fdfdfb009674a","date":1307033216,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d62f5453a200cec2cbb60148de159dbf55591e9d","date":1307049300,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c715a0f99152be7566591f323c6c5a25725a1bcb","date":1307118449,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bfa39296944e5fddc334aa89243d91f9cbb8367","date":1330973284,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#collect(int).mjava","sourceNew":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void collect(int doc) throws IOException {\n\n    // System.out.println(\"C \" + doc);\n\n    if (doc > groupEndDocID) {\n      // Group changed\n      if (subDocUpto != 0) {\n        processGroup();\n      }\n      groupEndDocID = lastDocPerGroupBits.advance(doc);\n      //System.out.println(\"  adv \" + groupEndDocID + \" \" + lastDocPerGroupBits);\n      subDocUpto = 0;\n      groupCompetes = !queueFull;\n    }\n\n    totalHitCount++;\n\n    // Always cache doc/score within this group:\n    if (subDocUpto == pendingSubDocs.length) {\n      pendingSubDocs = ArrayUtil.grow(pendingSubDocs);\n    }\n    pendingSubDocs[subDocUpto] = doc;\n    if (needsScores) {\n      if (subDocUpto == pendingSubScores.length) {\n        pendingSubScores = ArrayUtil.grow(pendingSubScores);\n      }\n      pendingSubScores[subDocUpto] = scorer.score();\n    }\n    subDocUpto++;\n\n    if (groupCompetes) {\n      if (subDocUpto == 1) {\n        assert !queueFull;\n\n        //System.out.println(\"    init copy to bottomSlot=\" + bottomSlot);\n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      } else {\n        // Compare to bottomSlot\n        for (int compIDX = 0;; compIDX++) {\n          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive -- done\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (compIDX == compIDXEnd) {\n            // Ties with bottom, except we know this docID is\n            // > docID in the queue (docs are visited in\n            // order), so not competitive:\n            return;\n          }\n        }\n\n        //System.out.println(\"       best w/in group!\");\n        \n        for (FieldComparator<?> fc : comparators) {\n          fc.copy(bottomSlot, doc);\n          // Necessary because some comparators cache\n          // details of bottom slot; this forces them to\n          // re-cache:\n          fc.setBottom(bottomSlot);\n        }        \n        topGroupDoc = doc;\n      }\n    } else {\n      // We're not sure this group will make it into the\n      // queue yet\n      for (int compIDX = 0;; compIDX++) {\n        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);\n        if (c < 0) {\n          // Definitely not competitive -- done\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        } else if (c > 0) {\n          // Definitely competitive.\n          break;\n        } else if (compIDX == compIDXEnd) {\n          // Ties with bottom, except we know this docID is\n          // > docID in the queue (docs are visited in\n          // order), so not competitive:\n          //System.out.println(\"    doc doesn't compete w/ top groups\");\n          return;\n        }\n      }\n      groupCompetes = true;\n      for (FieldComparator<?> fc : comparators) {\n        fc.copy(bottomSlot, doc);\n        // Necessary because some comparators cache\n        // details of bottom slot; this forces them to\n        // re-cache:\n        fc.setBottom(bottomSlot);\n      }\n      topGroupDoc = doc;\n      //System.out.println(\"        doc competes w/ top groups\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["8bfa39296944e5fddc334aa89243d91f9cbb8367"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a","8bfa39296944e5fddc334aa89243d91f9cbb8367"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c715a0f99152be7566591f323c6c5a25725a1bcb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"8bfa39296944e5fddc334aa89243d91f9cbb8367":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d","8bfa39296944e5fddc334aa89243d91f9cbb8367"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d"],"c715a0f99152be7566591f323c6c5a25725a1bcb":[],"d62f5453a200cec2cbb60148de159dbf55591e9d":[],"8bfa39296944e5fddc334aa89243d91f9cbb8367":["b89678825b68eccaf09e6ab71675fc0b0af1e099","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}