{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/WithinPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/WithinPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/WithinPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    return new VisitorTemplate(context) {\n      private FixedBitSet inside;\n      private FixedBitSet outside;\n\n      @Override\n      protected void start() {\n        inside = new FixedBitSet(maxDoc);\n        outside = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        inside.andNot(outside);\n        return new BitDocIdSet(inside);\n      }\n\n      @Override\n      protected CellIterator findSubCellsToVisit(Cell cell) {\n        //use buffered query shape instead of orig.  Works with null too.\n        return cell.getNextLevelCells(bufferedQueryShape);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        //cell.relate is based on the bufferedQueryShape; we need to examine what\n        // the relation is against the queryShape\n        SpatialRelation visitRelation = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel) {\n          collectDocs(visitRelation.intersects() ? inside : outside);\n          return false;\n        } else if (visitRelation == SpatialRelation.WITHIN) {\n          collectDocs(inside);\n          return false;\n        } else if (visitRelation == SpatialRelation.DISJOINT) {\n          collectDocs(outside);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        if (allCellsIntersectQuery(cell))\n          collectDocs(inside);\n        else\n          collectDocs(outside);\n      }\n\n      /** Returns true if the provided cell, and all its sub-cells down to\n       * detailLevel all intersect the queryShape.\n       */\n      private boolean allCellsIntersectQuery(Cell cell) {\n        SpatialRelation relate = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel)\n          return relate.intersects();\n        if (relate == SpatialRelation.WITHIN)\n          return true;\n        if (relate == SpatialRelation.DISJOINT)\n          return false;\n        // Note: Generating all these cells just to determine intersection is not ideal.\n        // The real solution is LUCENE-4869.\n        CellIterator subCells = cell.getNextLevelCells(null);\n        while (subCells.hasNext()) {\n          Cell subCell = subCells.next();\n          if (!allCellsIntersectQuery(subCell))//recursion\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        visitLeaf(cell);//collects as we want, even if not a leaf\n//        if (cell.isLeaf()) {\n//          visitLeaf(cell);\n//        } else {\n//          visitPrefix(cell);\n//        }\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    return new VisitorTemplate(context) {\n      private FixedBitSet inside;\n      private FixedBitSet outside;\n\n      @Override\n      protected void start() {\n        inside = new FixedBitSet(maxDoc);\n        outside = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        inside.andNot(outside);\n        return new BitDocIdSet(inside);\n      }\n\n      @Override\n      protected CellIterator findSubCellsToVisit(Cell cell) {\n        //use buffered query shape instead of orig.  Works with null too.\n        return cell.getNextLevelCells(bufferedQueryShape);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        //cell.relate is based on the bufferedQueryShape; we need to examine what\n        // the relation is against the queryShape\n        SpatialRelation visitRelation = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel) {\n          collectDocs(visitRelation.intersects() ? inside : outside);\n          return false;\n        } else if (visitRelation == SpatialRelation.WITHIN) {\n          collectDocs(inside);\n          return false;\n        } else if (visitRelation == SpatialRelation.DISJOINT) {\n          collectDocs(outside);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        if (allCellsIntersectQuery(cell))\n          collectDocs(inside);\n        else\n          collectDocs(outside);\n      }\n\n      /** Returns true if the provided cell, and all its sub-cells down to\n       * detailLevel all intersect the queryShape.\n       */\n      private boolean allCellsIntersectQuery(Cell cell) {\n        SpatialRelation relate = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel)\n          return relate.intersects();\n        if (relate == SpatialRelation.WITHIN)\n          return true;\n        if (relate == SpatialRelation.DISJOINT)\n          return false;\n        // Note: Generating all these cells just to determine intersection is not ideal.\n        // The real solution is LUCENE-4869.\n        CellIterator subCells = cell.getNextLevelCells(null);\n        while (subCells.hasNext()) {\n          Cell subCell = subCells.next();\n          if (!allCellsIntersectQuery(subCell))//recursion\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        visitLeaf(cell);//collects as we want, even if not a leaf\n//        if (cell.isLeaf()) {\n//          visitLeaf(cell);\n//        } else {\n//          visitPrefix(cell);\n//        }\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/WithinPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/WithinPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    return new VisitorTemplate(context) {\n      private FixedBitSet inside;\n      private FixedBitSet outside;\n\n      @Override\n      protected void start() {\n        inside = new FixedBitSet(maxDoc);\n        outside = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        inside.andNot(outside);\n        return new BitDocIdSet(inside);\n      }\n\n      @Override\n      protected CellIterator findSubCellsToVisit(Cell cell) {\n        //use buffered query shape instead of orig.  Works with null too.\n        return cell.getNextLevelCells(bufferedQueryShape);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        //cell.relate is based on the bufferedQueryShape; we need to examine what\n        // the relation is against the queryShape\n        SpatialRelation visitRelation = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel) {\n          collectDocs(visitRelation.intersects() ? inside : outside);\n          return false;\n        } else if (visitRelation == SpatialRelation.WITHIN) {\n          collectDocs(inside);\n          return false;\n        } else if (visitRelation == SpatialRelation.DISJOINT) {\n          collectDocs(outside);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        if (allCellsIntersectQuery(cell))\n          collectDocs(inside);\n        else\n          collectDocs(outside);\n      }\n\n      /** Returns true if the provided cell, and all its sub-cells down to\n       * detailLevel all intersect the queryShape.\n       */\n      private boolean allCellsIntersectQuery(Cell cell) {\n        SpatialRelation relate = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel)\n          return relate.intersects();\n        if (relate == SpatialRelation.WITHIN)\n          return true;\n        if (relate == SpatialRelation.DISJOINT)\n          return false;\n        // Note: Generating all these cells just to determine intersection is not ideal.\n        // The real solution is LUCENE-4869.\n        CellIterator subCells = cell.getNextLevelCells(null);\n        while (subCells.hasNext()) {\n          Cell subCell = subCells.next();\n          if (!allCellsIntersectQuery(subCell))//recursion\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        visitLeaf(cell);//collects as we want, even if not a leaf\n//        if (cell.isLeaf()) {\n//          visitLeaf(cell);\n//        } else {\n//          visitPrefix(cell);\n//        }\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    return new VisitorTemplate(context) {\n      private FixedBitSet inside;\n      private FixedBitSet outside;\n\n      @Override\n      protected void start() {\n        inside = new FixedBitSet(maxDoc);\n        outside = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        inside.andNot(outside);\n        return new BitDocIdSet(inside);\n      }\n\n      @Override\n      protected CellIterator findSubCellsToVisit(Cell cell) {\n        //use buffered query shape instead of orig.  Works with null too.\n        return cell.getNextLevelCells(bufferedQueryShape);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        //cell.relate is based on the bufferedQueryShape; we need to examine what\n        // the relation is against the queryShape\n        SpatialRelation visitRelation = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel) {\n          collectDocs(visitRelation.intersects() ? inside : outside);\n          return false;\n        } else if (visitRelation == SpatialRelation.WITHIN) {\n          collectDocs(inside);\n          return false;\n        } else if (visitRelation == SpatialRelation.DISJOINT) {\n          collectDocs(outside);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        if (allCellsIntersectQuery(cell))\n          collectDocs(inside);\n        else\n          collectDocs(outside);\n      }\n\n      /** Returns true if the provided cell, and all its sub-cells down to\n       * detailLevel all intersect the queryShape.\n       */\n      private boolean allCellsIntersectQuery(Cell cell) {\n        SpatialRelation relate = cell.getShape().relate(queryShape);\n        if (cell.getLevel() == detailLevel)\n          return relate.intersects();\n        if (relate == SpatialRelation.WITHIN)\n          return true;\n        if (relate == SpatialRelation.DISJOINT)\n          return false;\n        // Note: Generating all these cells just to determine intersection is not ideal.\n        // The real solution is LUCENE-4869.\n        CellIterator subCells = cell.getNextLevelCells(null);\n        while (subCells.hasNext()) {\n          Cell subCell = subCells.next();\n          if (!allCellsIntersectQuery(subCell))//recursion\n            return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitScanned(Cell cell) throws IOException {\n        visitLeaf(cell);//collects as we want, even if not a leaf\n//        if (cell.isLeaf()) {\n//          visitLeaf(cell);\n//        } else {\n//          visitPrefix(cell);\n//        }\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}