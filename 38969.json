{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9","date":1457128438,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"922ddd897402a6df25c766ea8300443be5e82b3d","date":1457157606,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac46f295250a5795494e8272686b5d8dd49517c6","date":1457798383,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98e0f1aa9ab98b9d47cc76e3d38926353c75b571","date":1457996850,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if (latMax < box1.minLat || latMin > box1.maxLat) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if ((lonMax < box1.minLon || lonMin > box1.maxLon) && (box2 == null || lonMax < box2.minLon)) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["976a394d3766ec527a334072ea20ed791d81e330"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff57c1600282020c039865d992b53e8e58e099c5","date":1458055095,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(LatLonPointDistanceComparator.haversin1(latitude, longitude, latitude, box.maxLon),\n                                    LatLonPointDistanceComparator.haversin1(latitude, longitude, box.maxLat, longitude));\n      assert LatLonPointDistanceComparator.haversin2(minPartialDistance) >= radiusMeters;\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = LatLonPointDistanceComparator.haversin1(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (LatLonPointDistanceComparator.haversin2(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if (latMax < box1.minLat || latMin > box1.maxLat) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if ((lonMax < box1.minLon || lonMin > box1.maxLon) && (box2 == null || lonMax < box2.minLon)) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n                if (GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["ec60431d008a694828dacb4bc3cda775b6c44a9f","748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec60431d008a694828dacb4bc3cda775b6c44a9f","date":1458570843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(LatLonPointDistanceComparator.haversin1(latitude, longitude, latitude, box.maxLon),\n                                    LatLonPointDistanceComparator.haversin1(latitude, longitude, box.maxLat, longitude));\n      assert LatLonPointDistanceComparator.haversin2(minPartialDistance) >= radiusMeters;\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = LatLonPointDistanceComparator.haversin1(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (LatLonPointDistanceComparator.haversin2(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["976a394d3766ec527a334072ea20ed791d81e330","ff57c1600282020c039865d992b53e8e58e099c5"],"bugIntro":["748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32cebcc2128763561399e79a5415bfdfe8a7a5b1","date":1458683229,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double minPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      minPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      minPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > minPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86fcb04ff2d63aad8754270211d5fc084d3526b9","date":1459278881,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = GeoUtils.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+GeoUtils.AXISLAT_ERROR < latMin || axisLat-GeoUtils.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43ddc1b7a872fafd838d3f3129984ca661e29b36","date":1459526591,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoRect.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = GeoRect.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+GeoRect.AXISLAT_ERROR < latMin || axisLat-GeoRect.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = GeoUtils.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+GeoUtils.AXISLAT_ERROR < latMin || axisLat-GeoUtils.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoRect.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = GeoRect.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+GeoRect.AXISLAT_ERROR < latMin || axisLat-GeoRect.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","date":1460056040,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = decodeLatitude((int)(encoded >> 32));\n                double docLongitude = decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09f15823cf5eb6e807005579e875e117d8598f95","date":1460066385,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = decodeLatitude((int)(encoded >> 32));\n                double docLongitude = decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(LatLonPoint.encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(LatLonPoint.encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));\n                double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"748351837d2259e6539ff3ac4867e16e0ad2b2bd","date":1460577424,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in visit()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                             double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                             if (h1 <= maxPartialDistance) {\n                               // fully confirm with part 2:\n                               if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                                 result.add(docID);\n                               }\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = decodeLatitude((int)(encoded >> 32));\n                double docLongitude = decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["32cebcc2128763561399e79a5415bfdfe8a7a5b1","ec60431d008a694828dacb4bc3cda775b6c44a9f","86fcb04ff2d63aad8754270211d5fc084d3526b9","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","ff57c1600282020c039865d992b53e8e58e099c5","ac46f295250a5795494e8272686b5d8dd49517c6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in visit()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                             double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                             if (h1 <= maxPartialDistance) {\n                               // fully confirm with part 2:\n                               if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                                 result.add(docID);\n                               }\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in matches()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // approximation (postfiltering has not yet been applied)\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        // subset of documents that need no postfiltering, this is purely an optimization\n        final BitSet preApproved;\n        // dumb heuristic: if the field is really sparse, use a sparse impl\n        if (values.getDocCount(field) * 100L < reader.maxDoc()) {\n          preApproved = new SparseFixedBitSet(reader.maxDoc());\n        } else {\n          preApproved = new FixedBitSet(reader.maxDoc());\n        }\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                             preApproved.set(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:\n                             // this reduces the amount of docvalues fetches (improves approximation)\n\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             result.add(docID);\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // return two-phase iterator using docvalues to postfilter candidates\n        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);\n        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {\n          @Override\n          public boolean matches() throws IOException {\n            int docId = disi.docID();\n            if (preApproved.get(docId)) {\n              return true;\n            } else {\n              docValues.setDocument(docId);\n              int count = docValues.count();\n              for (int i = 0; i < count; i++) {\n                long encoded = docValues.valueAt(i);\n                double docLatitude = decodeLatitude((int)(encoded >> 32));\n                double docLongitude = decodeLongitude((int)(encoded & 0xFFFFFFFF));\n\n                // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                if (h1 > maxPartialDistance) {\n                  continue;\n                }\n\n                // fully confirm with part 2:\n                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                  return true;\n                }\n              }\n              return false;\n            }\n          }\n\n          @Override\n          public float matchCost() {\n            return 20; // TODO: make this fancier\n          }\n        };\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"932f181b36aa461684654122cea4d8f0321e55af","date":1460588531,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute a maximum partial haversin: unless our box is crazy, we can use this bound\n    // to reject edge cases faster in visit()\n    final double maxPartialDistance;\n    if (box.maxLon - longitude < 90 && longitude - box.minLon < 90) {\n      maxPartialDistance = Math.max(SloppyMath.haversinSortKey(latitude, longitude, latitude, box.maxLon),\n                                    SloppyMath.haversinSortKey(latitude, longitude, box.maxLat, longitude));\n    } else {\n      maxPartialDistance = Double.POSITIVE_INFINITY;\n    }\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // first check the partial distance, if its more than that, it can't be <= radiusMeters\n                             double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);\n                             if (h1 <= maxPartialDistance) {\n                               // fully confirm with part 2:\n                               if (SloppyMath.haversinMeters(h1) <= radiusMeters) {\n                                 result.add(docID);\n                               }\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) > radiusMeters &&\n                                   SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) > radiusMeters) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 SloppyMath.haversinMeters(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","date":1461676641,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        DocIdSet set = result.build();\n        final DocIdSetIterator disi = set.iterator();\n        if (disi == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","date":1461772947,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f976862431a9be6f9f76f958b5a9a04aa2342747","date":1464099811,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":["976a394d3766ec527a334072ea20ed791d81e330","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","932f181b36aa461684654122cea4d8f0321e55af","d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a62e86d7b9cc6dec3c09f771166aa2393fd95c99","date":1466437108,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = GeoUtils.distanceQuerySortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = GeoUtils.distanceQuerySortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = GeoUtils.distanceQuerySortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = GeoUtils.distanceQuerySortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           DocIdSetBuilder.BulkAdder adder;\n\n                           @Override\n                           public void grow(int count) {\n                             adder = result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             adder.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               adder.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    Rectangle box = Rectangle.fromPointDistance(latitude, longitude, radiusMeters);\n    // create bounding box(es) for the distance range\n    // these are pre-encoded with LatLonPoint's encoding\n    final byte minLat[] = new byte[Integer.BYTES];\n    final byte maxLat[] = new byte[Integer.BYTES];\n    final byte minLon[] = new byte[Integer.BYTES];\n    final byte maxLon[] = new byte[Integer.BYTES];\n    // second set of longitude ranges to check (for cross-dateline case)\n    final byte minLon2[] = new byte[Integer.BYTES];\n\n    NumericUtils.intToSortableBytes(encodeLatitude(box.minLat), minLat, 0);\n    NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat), maxLat, 0);\n\n    // crosses dateline: split\n    if (box.crossesDateline()) {\n      // box1\n      NumericUtils.intToSortableBytes(Integer.MIN_VALUE, minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // box2\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon2, 0);\n    } else {\n      NumericUtils.intToSortableBytes(encodeLongitude(box.minLon), minLon, 0);\n      NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon), maxLon, 0);\n      // disable box2\n      NumericUtils.intToSortableBytes(Integer.MAX_VALUE, minLon2, 0);\n    }\n\n    // compute exact sort key: avoid any asin() computations\n    final double sortKey = sortKey(radiusMeters);\n\n    final double axisLat = Rectangle.axisLat(latitude, radiusMeters);\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        // matching docids\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             // bounding box check\n                             if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, packedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return;\n                             }\n\n                             double docLatitude = decodeLatitude(packedValue, 0);\n                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);\n\n                             // its a match only if its sortKey <= our sortKey\n                             if (SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude) <= sortKey) {\n                               result.add(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. check if the subtree is disjoint. it may cross the bounding box but not intersect with circle\n                           // 3. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 4.\n                           // 4. recurse naively (subtrees crossing over circle edge)\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             if (StringHelper.compare(Integer.BYTES, minPackedValue, 0, maxLat, 0) > 0 ||\n                                 StringHelper.compare(Integer.BYTES, maxPackedValue, 0, minLat, 0) < 0) {\n                               // latitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             if ((StringHelper.compare(Integer.BYTES, minPackedValue, Integer.BYTES, maxLon, 0) > 0 ||\n                                  StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon, 0) < 0)\n                                 && StringHelper.compare(Integer.BYTES, maxPackedValue, Integer.BYTES, minLon2, 0) < 0) {\n                               // longitude out of bounding box range\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n\n                             double latMin = decodeLatitude(minPackedValue, 0);\n                             double lonMin = decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = decodeLatitude(maxPackedValue, 0);\n                             double lonMax = decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if ((longitude < lonMin || longitude > lonMax) && (axisLat+ Rectangle.AXISLAT_ERROR < latMin || axisLat- Rectangle.AXISLAT_ERROR > latMax)) {\n                               // circle not fully inside / crossing axis\n                               if (SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) > sortKey &&\n                                   SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) > sortKey) {\n                                 // no points inside\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n                             }\n\n                             if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMin, lonMax) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMin) <= sortKey &&\n                                 SloppyMath.haversinSortKey(latitude, longitude, latMax, lonMax) <= sortKey) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ac46f295250a5795494e8272686b5d8dd49517c6":["922ddd897402a6df25c766ea8300443be5e82b3d"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["932f181b36aa461684654122cea4d8f0321e55af","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["86fcb04ff2d63aad8754270211d5fc084d3526b9"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["09f15823cf5eb6e807005579e875e117d8598f95","748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"748351837d2259e6539ff3ac4867e16e0ad2b2bd":["09f15823cf5eb6e807005579e875e117d8598f95"],"ff57c1600282020c039865d992b53e8e58e099c5":["98e0f1aa9ab98b9d47cc76e3d38926353c75b571"],"32cebcc2128763561399e79a5415bfdfe8a7a5b1":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"f976862431a9be6f9f76f958b5a9a04aa2342747":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"09f15823cf5eb6e807005579e875e117d8598f95":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"a62e86d7b9cc6dec3c09f771166aa2393fd95c99":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"922ddd897402a6df25c766ea8300443be5e82b3d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","b4c23ea9b61b3e6ad2f2b3684e33f528711744d9"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","f976862431a9be6f9f76f958b5a9a04aa2342747"],"83870855d82aba6819217abeff5a40779dbb28b4":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","0e121d43b5a10f2df530f406f935102656e9c4e8"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"86fcb04ff2d63aad8754270211d5fc084d3526b9":["32cebcc2128763561399e79a5415bfdfe8a7a5b1"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"932f181b36aa461684654122cea4d8f0321e55af":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"98e0f1aa9ab98b9d47cc76e3d38926353c75b571":["ac46f295250a5795494e8272686b5d8dd49517c6"],"ec60431d008a694828dacb4bc3cda775b6c44a9f":["ff57c1600282020c039865d992b53e8e58e099c5"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["0e121d43b5a10f2df530f406f935102656e9c4e8","a62e86d7b9cc6dec3c09f771166aa2393fd95c99"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["932f181b36aa461684654122cea4d8f0321e55af"],"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","94ee361295fb38310ac4d53cb4773d1622423d68"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"]},"commit2Childs":{"ac46f295250a5795494e8272686b5d8dd49517c6":["98e0f1aa9ab98b9d47cc76e3d38926353c75b571"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["32cebcc2128763561399e79a5415bfdfe8a7a5b1"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["932f181b36aa461684654122cea4d8f0321e55af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["94ee361295fb38310ac4d53cb4773d1622423d68","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"94ee361295fb38310ac4d53cb4773d1622423d68":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["09f15823cf5eb6e807005579e875e117d8598f95","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"748351837d2259e6539ff3ac4867e16e0ad2b2bd":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"ff57c1600282020c039865d992b53e8e58e099c5":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"32cebcc2128763561399e79a5415bfdfe8a7a5b1":["86fcb04ff2d63aad8754270211d5fc084d3526b9"],"f976862431a9be6f9f76f958b5a9a04aa2342747":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"09f15823cf5eb6e807005579e875e117d8598f95":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","748351837d2259e6539ff3ac4867e16e0ad2b2bd"],"a62e86d7b9cc6dec3c09f771166aa2393fd95c99":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"922ddd897402a6df25c766ea8300443be5e82b3d":["ac46f295250a5795494e8272686b5d8dd49517c6"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["a62e86d7b9cc6dec3c09f771166aa2393fd95c99","83870855d82aba6819217abeff5a40779dbb28b4","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"86fcb04ff2d63aad8754270211d5fc084d3526b9":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["f976862431a9be6f9f76f958b5a9a04aa2342747","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["09f15823cf5eb6e807005579e875e117d8598f95"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"932f181b36aa461684654122cea4d8f0321e55af":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005"],"98e0f1aa9ab98b9d47cc76e3d38926353c75b571":["ff57c1600282020c039865d992b53e8e58e099c5"],"ec60431d008a694828dacb4bc3cda775b6c44a9f":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"b4c23ea9b61b3e6ad2f2b3684e33f528711744d9":["922ddd897402a6df25c766ea8300443be5e82b3d"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["922ddd897402a6df25c766ea8300443be5e82b3d","b4c23ea9b61b3e6ad2f2b3684e33f528711744d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}