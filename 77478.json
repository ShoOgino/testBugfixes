{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","commits":[{"id":"4762743d2f10f32ae47dc222ef92e0807ffe2ab8","date":1429841956,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"/dev/null","sourceNew":"    /** Returns true if this plane and the other plane are identical within the margin of error.\n    */\n    protected boolean isNumericallyIdentical(final Plane p) {\n        // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n        // (using D) and see if it also on the other plane.\n        if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n        if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n        if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n\n        // Now, see whether the parallel planes are in fact on top of one another.  \n        final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n        return evaluateIsZero(- p.x * p.D * denom, - p.y * p.D * denom, - p.z * p.D * denom);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47619c5413e53c4d414c1ececa274bef0cd3c799","date":1430506189,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"    /** Returns true if this plane and the other plane are identical within the margin of error.\n    */\n    protected boolean isNumericallyIdentical(final Plane p) {\n        // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n        // (using D) and see if it also on the other plane.\n        if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n            return false;\n        if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n            return false;\n        if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n            return false;\n\n        // Now, see whether the parallel planes are in fact on top of one another. \n        // The math:\n        // We need a single point that fulfills:\n        // Ax + By + Cz + D = 0\n        // Pick:\n        // x0 = -(A * D) / (A^2 + B^2 + C^2)\n        // y0 = -(B * D) / (A^2 + B^2 + C^2)\n        // z0 = -(C * D) / (A^2 + B^2 + C^2)\n        // Check:\n        // A (x0) + B (y0) + C (z0) + D =? 0\n        // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n        // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n        // Yes.\n        final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n        return evaluateIsZero(- p.x * p.D * denom, - p.y * p.D * denom, - p.z * p.D * denom);\n    }\n\n","sourceOld":"    /** Returns true if this plane and the other plane are identical within the margin of error.\n    */\n    protected boolean isNumericallyIdentical(final Plane p) {\n        // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n        // (using D) and see if it also on the other plane.\n        if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n        if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n        if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION_SQUARED)\n            return false;\n\n        // Now, see whether the parallel planes are in fact on top of one another.  \n        final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n        return evaluateIsZero(- p.x * p.D * denom, - p.y * p.D * denom, - p.z * p.D * denom);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2997acf74723385bd84aff1ea0b12af4aefde77","date":1430745542,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"    /** Returns true if this plane and the other plane are identical within the margin of error.\n    */\n    protected boolean isNumericallyIdentical(final Plane p) {\n        // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n        // (using D) and see if it also on the other plane.\n        if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n            return false;\n        if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n            return false;\n        if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n            return false;\n\n        // Now, see whether the parallel planes are in fact on top of one another. \n        // The math:\n        // We need a single point that fulfills:\n        // Ax + By + Cz + D = 0\n        // Pick:\n        // x0 = -(A * D) / (A^2 + B^2 + C^2)\n        // y0 = -(B * D) / (A^2 + B^2 + C^2)\n        // z0 = -(C * D) / (A^2 + B^2 + C^2)\n        // Check:\n        // A (x0) + B (y0) + C (z0) + D =? 0\n        // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n        // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n        // Yes.\n        final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n        return evaluateIsZero(- p.x * p.D * denom, - p.y * p.D * denom, - p.z * p.D * denom);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c921d81476f94b6686d3f216daa1f6b076b4a6c0","date":1430922284,"type":0,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3022be5842502b7c2a57a5124199bbc30236f0a0","date":1436724252,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"47619c5413e53c4d414c1ececa274bef0cd3c799":["4762743d2f10f32ae47dc222ef92e0807ffe2ab8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3022be5842502b7c2a57a5124199bbc30236f0a0":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["47619c5413e53c4d414c1ececa274bef0cd3c799"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2997acf74723385bd84aff1ea0b12af4aefde77"],"4762743d2f10f32ae47dc222ef92e0807ffe2ab8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3022be5842502b7c2a57a5124199bbc30236f0a0"]},"commit2Childs":{"47619c5413e53c4d414c1ececa274bef0cd3c799":["e2997acf74723385bd84aff1ea0b12af4aefde77"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c921d81476f94b6686d3f216daa1f6b076b4a6c0","4762743d2f10f32ae47dc222ef92e0807ffe2ab8"],"3022be5842502b7c2a57a5124199bbc30236f0a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"4762743d2f10f32ae47dc222ef92e0807ffe2ab8":["47619c5413e53c4d414c1ececa274bef0cd3c799"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["3022be5842502b7c2a57a5124199bbc30236f0a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}