{"path":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","commits":[{"id":"66ab3886c1d845c59c9e5b23b2fb247b927db498","date":1193060587,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"/dev/null","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    Query altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altUserQuery = p.parse(altQ);\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    String[] boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    List<Query> boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71bbe672a26ef56876a0ce949b0a4de41f602057","date":1194896341,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    Query altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altUserQuery = p.parse(altQ);\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    String[] boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    List<Query> boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66f4f73f46badcff4112ae64dbd1a3eecfeedc04","date":1218747845,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = U.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aa56605b4f871d2f0b6bceecdca2275079fa37e","date":1219430523,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    Map<String,Float> phraseFields = U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    U.DisjunctionMaxQueryParser up =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    U.DisjunctionMaxQueryParser pp =\n      new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = U.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"caa77a22c8f4938b14fba3a3117867dd7e3a4093","date":1222460232,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3616f8882c8603140cdd1628080f85d2bf081fdf","date":1242991436,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58","date":1243018718,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/search/DisMaxQParser#parse().mjava","pathOld":"src/java/org/apache/solr/search/DismaxQParser[DisMaxQParserPlugin]#parse().mjava","sourceNew":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String, Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a generic parser for parsing regular lucene queries */\n    QueryParser p = schema.getSolrQueryParser(null);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n            new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n            tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if (userQuery == null || userQuery.trim().length() < 1) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get(DisMaxParams.ALTQ);\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add(altUserQuery, BooleanClause.Occur.MUST);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"missing query string\");\n      }\n    } else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery) dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\", \"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries = null;\n    if (boostParams != null && boostParams.length > 0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length() == 0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if (1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery) f).clauses()) {\n            query.add((BooleanClause) c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for (Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if (null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String, Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","sourceOld":"  public Query parse() throws ParseException {\n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    IndexSchema schema = req.getSchema();\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    Map<String,Float> phraseFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    /* a parser for dealing with user input, which will convert\n     * things to DisjunctionMaxQueries\n     */\n    SolrPluginUtils.DisjunctionMaxQueryParser up =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n    up.setPhraseSlop(qslop);\n\n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    SolrPluginUtils.DisjunctionMaxQueryParser pp =\n      new SolrPluginUtils.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, phraseFields);\n    pp.setPhraseSlop(pslop);\n\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.parse();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {\n      // There is a valid query string\n      userQuery = SolrPluginUtils.partialEscape(SolrPluginUtils.stripUnbalancedQuotes(userQuery)).toString();\n      userQuery = SolrPluginUtils.stripIllegalOperators(userQuery).toString();\n\n      String minShouldMatch = solrParams.get(DisMaxParams.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)dis);\n        SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n        parsedUserQuery = t;\n      }\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n\n      /* * * Add on Phrases for the Query * * */\n\n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, strip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = SolrPluginUtils.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).parse();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      if(1 == boostQueries.size() && 1 == boostParams.length) {\n        /* legacy logic */\n        Query f = boostQueries.get(0);\n        if (1.0f == f.getBoost() && f instanceof BooleanQuery) {\n          /* if the default boost was used, and we've got a BooleanQuery\n           * extract the subqueries out and use them directly\n           */\n          for (Object c : ((BooleanQuery)f).clauses()) {\n            query.add((BooleanClause)c);\n          }\n        } else {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        for(Query f : boostQueries) {\n          query.add(f, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).parse();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n    return query;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66f4f73f46badcff4112ae64dbd1a3eecfeedc04":["71bbe672a26ef56876a0ce949b0a4de41f602057"],"71bbe672a26ef56876a0ce949b0a4de41f602057":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"3616f8882c8603140cdd1628080f85d2bf081fdf":["caa77a22c8f4938b14fba3a3117867dd7e3a4093"],"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58":["3616f8882c8603140cdd1628080f85d2bf081fdf"],"1aa56605b4f871d2f0b6bceecdca2275079fa37e":["66f4f73f46badcff4112ae64dbd1a3eecfeedc04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"caa77a22c8f4938b14fba3a3117867dd7e3a4093":["1aa56605b4f871d2f0b6bceecdca2275079fa37e"]},"commit2Childs":{"66f4f73f46badcff4112ae64dbd1a3eecfeedc04":["1aa56605b4f871d2f0b6bceecdca2275079fa37e"],"71bbe672a26ef56876a0ce949b0a4de41f602057":["66f4f73f46badcff4112ae64dbd1a3eecfeedc04"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["71bbe672a26ef56876a0ce949b0a4de41f602057"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3616f8882c8603140cdd1628080f85d2bf081fdf":["bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58"],"bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58":[],"1aa56605b4f871d2f0b6bceecdca2275079fa37e":["caa77a22c8f4938b14fba3a3117867dd7e3a4093"],"caa77a22c8f4938b14fba3a3117867dd7e3a4093":["3616f8882c8603140cdd1628080f85d2bf081fdf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bf4d5ca2c75db0d2c7a9bd0ce5a8f92475ebae58","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}