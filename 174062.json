{"path":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   * @throws ParseException\n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws ParseException {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new ParseException(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new ParseException(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n   protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n     return parseValueSource( doConsumeDelimiter ? (FLAG_DEFAULT | FLAG_CONSUME_DELIMITER) : (FLAG_DEFAULT & ~FLAG_CONSUME_DELIMITER) );\n   }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FunctionQParser#parseValueSource(boolean).mjava","sourceNew":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n   protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n     return parseValueSource( doConsumeDelimiter ? (FLAG_DEFAULT | FLAG_CONSUME_DELIMITER) : (FLAG_DEFAULT & ~FLAG_CONSUME_DELIMITER) );\n   }\n\n","sourceOld":"  /**\n   * Parse an individual value source.\n   * \n   * @param doConsumeDelimiter whether to consume a delimiter following the ValueSource  \n   */\n  protected ValueSource parseValueSource(boolean doConsumeDelimiter) throws SyntaxError {\n    ValueSource valueSource;\n    \n    int ch = sp.peek();\n    if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n      Number num = sp.getNumber();\n      if (num instanceof Long) {\n        valueSource = new LongConstValueSource(num.longValue());\n      } else if (num instanceof Double) {\n        valueSource = new DoubleConstValueSource(num.doubleValue());\n      } else {\n        // shouldn't happen\n        valueSource = new ConstValueSource(num.floatValue());\n      }\n    } else if (ch == '\"' || ch == '\\''){\n      valueSource = new LiteralValueSource(sp.getQuotedString());\n    } else if (ch == '$') {\n      sp.pos++;\n      String param = sp.getId();\n      String val = getParam(param);\n      if (val == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n\n      QParser subParser = subQuery(val, \"func\");\n      if (subParser instanceof FunctionQParser) {\n        ((FunctionQParser)subParser).setParseMultipleSources(true);\n      }\n      Query subQuery = subParser.getQuery();\n      if (subQuery instanceof FunctionQuery) {\n        valueSource = ((FunctionQuery) subQuery).getValueSource();\n      } else {\n        valueSource = new QueryValueSource(subQuery, 0.0f);\n      }\n\n      /***\n       // dereference *simple* argument (i.e., can't currently be a function)\n       // In the future we could support full function dereferencing via a stack of ValueSource (or StringParser) objects\n      ch = val.length()==0 ? '\\0' : val.charAt(0);\n\n      if (ch>='0' && ch<='9'  || ch=='.' || ch=='+' || ch=='-') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        Number num = sp.getNumber();\n        if (num instanceof Long) {\n          valueSource = new LongConstValueSource(num.longValue());\n        } else if (num instanceof Double) {\n          valueSource = new DoubleConstValueSource(num.doubleValue());\n        } else {\n          // shouldn't happen\n          valueSource = new ConstValueSource(num.floatValue());\n        }\n      } else if (ch == '\"' || ch == '\\'') {\n        QueryParsing.StrParser sp = new QueryParsing.StrParser(val);\n        val = sp.getQuotedString();\n        valueSource = new LiteralValueSource(val);\n      } else {\n        if (val.length()==0) {\n          valueSource = new LiteralValueSource(val);\n        } else {\n          String id = val;\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n       ***/\n\n    } else {\n\n      String id = sp.getId();\n      if (sp.opt(\"(\")) {\n        // a function... look it up.\n        ValueSourceParser argParser = req.getCore().getValueSourceParser(id);\n        if (argParser==null) {\n          throw new SyntaxError(\"Unknown function \" + id + \" in FunctionQuery(\" + sp + \")\");\n        }\n        valueSource = argParser.parse(this);\n        sp.expect(\")\");\n      }\n      else {\n        if (\"true\".equals(id)) {\n          valueSource = new BoolConstValueSource(true);\n        } else if (\"false\".equals(id)) {\n          valueSource = new BoolConstValueSource(false);\n        } else {\n          SchemaField f = req.getSchema().getField(id);\n          valueSource = f.getType().getValueSource(f, this);\n        }\n      }\n\n    }\n    \n    if (doConsumeDelimiter)\n      consumeArgumentDelimiter();\n    \n    return valueSource;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c26f00b574427b55127e869b935845554afde1fa"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["19275ba31e621f6da1b83bf13af75233876fd3d4","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3cdb67100dc016748799a77218aa409478372d79","19275ba31e621f6da1b83bf13af75233876fd3d4"],"3cdb67100dc016748799a77218aa409478372d79":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","3cdb67100dc016748799a77218aa409478372d79"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["3cdb67100dc016748799a77218aa409478372d79"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"3cdb67100dc016748799a77218aa409478372d79":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","19275ba31e621f6da1b83bf13af75233876fd3d4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}