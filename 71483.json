{"path":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","commits":[{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending. */\n  synchronized ThreadState getThreadState(Document doc) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        threadStates = newArray;\n        state = threadStates[threadStates.length-1] = new ThreadState();\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039","8560794cda5bcd510c60e38ed553e9c5a6204983","ac1242ce6d99813874fddfe4ca5f57779beddb22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a826b3c934f8c245ee092134bcd712d1e573188","date":1183723038,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending. */\n  synchronized ThreadState getThreadState(Document doc) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending. */\n  synchronized ThreadState getThreadState(Document doc) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        threadStates = newArray;\n        state = threadStates[threadStates.length-1] = new ThreadState();\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fde68de507dbf344495d7b5e8052866fe5f254ab","date":1189434831,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document,Term).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#getThreadState(Document).mjava","sourceNew":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending.  If delTerm is non-null then we\n   * buffer this deleted term after the thread state has\n   * been acquired. */\n  synchronized ThreadState getThreadState(Document doc, Term delTerm) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    if (delTerm != null)\n      addDeleteTerm(delTerm, state.docID);\n\n    return state;\n  }\n\n","sourceOld":"  /** Returns a free (idle) ThreadState that may be used for\n   * indexing this one document.  This call also pauses if a\n   * flush is pending. */\n  synchronized ThreadState getThreadState(Document doc) throws IOException {\n\n    // First, find a thread state.  If this thread already\n    // has affinity to a specific ThreadState, use that one\n    // again.\n    ThreadState state = (ThreadState) threadBindings.get(Thread.currentThread());\n    if (state == null) {\n      // First time this thread has called us since last flush\n      ThreadState minThreadState = null;\n      for(int i=0;i<threadStates.length;i++) {\n        ThreadState ts = threadStates[i];\n        if (minThreadState == null || ts.numThreads < minThreadState.numThreads)\n          minThreadState = ts;\n      }\n      if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {\n        state = minThreadState;\n        state.numThreads++;\n      } else {\n        // Just create a new \"private\" thread state\n        ThreadState[] newArray = new ThreadState[1+threadStates.length];\n        if (threadStates.length > 0)\n          System.arraycopy(threadStates, 0, newArray, 0, threadStates.length);\n        state = newArray[threadStates.length] = new ThreadState();\n        threadStates = newArray;\n      }\n      threadBindings.put(Thread.currentThread(), state);\n    }\n\n    // Next, wait until my thread state is idle (in case\n    // it's shared with other threads) and for threads to\n    // not be paused nor a flush pending:\n    while(!state.isIdle || pauseThreads != 0 || flushPending)\n      try {\n        wait();\n      } catch (InterruptedException e) {}\n\n    if (segment == null)\n      segment = writer.newSegmentName();\n\n    numDocsInRAM++;\n\n    // We must at this point commit to flushing to ensure we\n    // always get N docs when we flush by doc count, even if\n    // > 1 thread is adding documents:\n    /* new merge policy\n    if (!flushPending && maxBufferedDocs > 0 && numDocsInRAM >= maxBufferedDocs) {\n    */\n    if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {\n      flushPending = true;\n      state.doFlushAfter = true;\n    } else\n      state.doFlushAfter = false;\n\n    state.isIdle = false;\n\n    boolean success = false;\n    try {\n      state.init(doc, nextDocID++);\n      success = true;\n    } finally {\n      if (!success) {\n        state.isIdle = true;\n        if (state.doFlushAfter) {\n          state.doFlushAfter = false;\n          flushPending = false;\n        }\n        abort();\n      }\n    }\n\n    return state;\n  }\n\n","bugFix":null,"bugIntro":["8560794cda5bcd510c60e38ed553e9c5a6204983"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"fde68de507dbf344495d7b5e8052866fe5f254ab":["6a826b3c934f8c245ee092134bcd712d1e573188"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6a826b3c934f8c245ee092134bcd712d1e573188":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fde68de507dbf344495d7b5e8052866fe5f254ab"]},"commit2Childs":{"fde68de507dbf344495d7b5e8052866fe5f254ab":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"6a826b3c934f8c245ee092134bcd712d1e573188":["fde68de507dbf344495d7b5e8052866fe5f254ab"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["6a826b3c934f8c245ee092134bcd712d1e573188"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}